C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Debug\ADC.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\ADC.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB WL(2) PR(.\DP
                    -8051_Keil_951\Debug/ADC.lst) CD OT(2,SIZE) OJ(.\DP8051_Keil_951\Debug\ADC.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: ADC.c
   3          * Version 3.20
   4          *
   5          * Description:
   6          *  This file provides the source code to the API for the Delta-Sigma ADC
   7          *  Component.
   8          *
   9          * Note:
  10          *
  11          ********************************************************************************
  12          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  13          * You may use this file only in accordance with the license, terms, conditions,
  14          * disclaimers, and limitations in the end user license agreement accompanying
  15          * the software package with which this file was provided.
  16          *******************************************************************************/
  17          
  18          #include "ADC.h"
  19          
  20          #if(ADC_DEFAULT_INTERNAL_CLK)
  21              #include "ADC_theACLK.h"
  22          #endif /* ADC_DEFAULT_INTERNAL_CLK */
  23          
  24          #include "ADC_Ext_CP_Clk.h"
  25          
  26          #if(ADC_DEFAULT_INPUT_MODE)
  27              #include "ADC_AMux.h"
  28          #endif /* ADC_DEFAULT_INPUT_MODE */
  29          
  30          
  31          /***************************************
  32          * Global data allocation
  33          ***************************************/
  34          
  35          /* Software flag for checking conversion completed or not */
  36          volatile uint8 ADC_convDone = 0u;
  37          
  38          /* Software flag to stop conversion for single sample conversion mode
  39          *   with resolution above 16 bits 
  40          */
  41          volatile uint8 ADC_stopConversion = 0u;
  42          
  43          /* To run the initialization block only at the start up */
  44          uint8 ADC_initVar = 0u;
  45          
  46          /* To check whether ADC started or not before switching the configuration */
  47          volatile uint8 ADC_started = 0u;
  48          
  49          /* Flag to hold ADC config number. By default active config is 1. */
  50          volatile uint8 ADC_Config = 1u;
  51          
  52          volatile int32 ADC_Offset;
  53          volatile int32 ADC_CountsPerVolt;
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 2   

  54          
  55          
  56          /***************************************
  57          * Local data allocation
  58          ***************************************/
  59          
  60          /* The array with precalculated gain compensation coefficients */
  61          static ADC_GCOR_STRUCT ADC_gcor[ADC_DEFAULT_NUM_CONFIGS];
  62          
  63          
  64          
  65          /***************************************
  66          * Forward function references
  67          ***************************************/
  68          static void ADC_InitConfig(uint8 config) ;
  69          static void ADC_GainCompensation(uint8 inputRange, uint16 idealDecGain, uint16 idealOddDecGain, 
  70                                      uint8 resolution, uint8 config) ;
  71          static void ADC_SetDSMRef0Reg(uint8 value) ;
  72          
  73          
  74          /******************************************************************************
  75          * Function Name: ADC_Init
  76          *******************************************************************************
  77          *
  78          * Summary:
  79          *  Initialize component's parameters to the parameters set by user in the
  80          *  customizer of the component placed onto schematic. Usually called in
  81          * ADC_Start().
  82          *
  83          *
  84          * Parameters:
  85          *  None
  86          *
  87          * Return:
  88          *  None
  89          *
  90          *******************************************************************************/
  91          void ADC_Init(void) 
  92          {
  93   1      
  94   1          ADC_Config = 1u;
  95   1          ADC_convDone = 0u;
  96   1      
  97   1          ADC_Ext_CP_Clk_SetMode(CYCLK_DUTY);
  98   1      
  99   1          /* This is only valid if there is an internal clock */
 100   1          #if(ADC_DEFAULT_INTERNAL_CLK)
 101   1              ADC_theACLK_SetMode(CYCLK_DUTY);
 102   1          #endif /* ADC_DEFAULT_INTERNAL_CLK */
 103   1      
 104   1          #if(ADC_IRQ_REMOVE == 0u)
 105   1              /* Set interrupt priority */
 106   1              CyIntSetPriority(ADC_INTC_NUMBER, ADC_INTC_PRIOR_NUMBER);
 107   1          #endif   /* End ADC_IRQ_REMOVE */
 108   1      
 109   1          /* Init static registers with common configuration */
 110   1          ADC_DSM_DEM0_REG    = ADC_CFG1_DSM_DEM0;
 111   1          ADC_DSM_DEM1_REG    = ADC_CFG1_DSM_DEM1;
 112   1          ADC_DSM_MISC_REG    = ADC_CFG1_DSM_MISC;
 113   1          ADC_DSM_CLK_REG    |= ADC_CFG1_DSM_CLK;
 114   1          ADC_DSM_REF1_REG    = ADC_CFG1_DSM_REF1;
 115   1      
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 3   

 116   1          ADC_DSM_OUT0_REG    = ADC_CFG1_DSM_OUT0;
 117   1          ADC_DSM_OUT1_REG    = ADC_CFG1_DSM_OUT1;
 118   1      
 119   1          ADC_DSM_CR0_REG     = ADC_CFG1_DSM_CR0;
 120   1          ADC_DSM_CR1_REG     = ADC_CFG1_DSM_CR1;
 121   1      #if(ADC_MI_ENABLE != 0u) /* Enable Modulator Input */
                  ADC_DSM_CR3_REG     |= ADC_DSM_MODBIT_EN;
              #else
 124   1          ADC_DSM_CR3_REG     = ADC_CFG1_DSM_CR3;
 125   1      #endif /* ADC_MI_ENABLE != 0u*/    
 126   1          ADC_DSM_CR8_REG     = ADC_CFG1_DSM_CR8;
 127   1          ADC_DSM_CR9_REG     = ADC_CFG1_DSM_CR9;
 128   1          ADC_DSM_CR13_REG    = ADC_CFG1_DSM_CR13;
 129   1      
 130   1          ADC_DEC_SR_REG      = ADC_CFG1_DEC_SR;
 131   1      
 132   1          /* Calculate Gain compensation coefficients for all configurations */
 133   1          ADC_GainCompensation(ADC_CFG1_INPUT_RANGE,
 134   1                                            ADC_CFG1_IDEAL_DEC_GAIN,
 135   1                                            ADC_CFG1_IDEAL_ODDDEC_GAIN,
 136   1                                            ADC_CFG1_RESOLUTION,
 137   1                                            ADC_CFG1);
 138   1          #if(ADC_DEFAULT_NUM_CONFIGS > 1)
                      ADC_GainCompensation(ADC_CFG2_INPUT_RANGE,
                                                        ADC_CFG2_IDEAL_DEC_GAIN,
                                                        ADC_CFG2_IDEAL_ODDDEC_GAIN,
                                                        ADC_CFG2_RESOLUTION,
                                                        ADC_CFG2);
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 1 */
 145   1          #if(ADC_DEFAULT_NUM_CONFIGS > 2)
                      ADC_GainCompensation(ADC_CFG3_INPUT_RANGE,
                                                        ADC_CFG3_IDEAL_DEC_GAIN,
                                                        ADC_CFG3_IDEAL_ODDDEC_GAIN,
                                                        ADC_CFG3_RESOLUTION,
                                                        ADC_CFG3);
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 2 */
 152   1          #if(ADC_DEFAULT_NUM_CONFIGS > 3)
                      ADC_GainCompensation(ADC_CFG4_INPUT_RANGE,
                                                        ADC_CFG4_IDEAL_DEC_GAIN,
                                                        ADC_CFG4_IDEAL_ODDDEC_GAIN,
                                                        ADC_CFG4_RESOLUTION,
                                                        ADC_CFG4);
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 3 */
 159   1      
 160   1          /* Set GCOR register for config1 */
 161   1          ADC_DEC_GVAL_REG = ADC_gcor[ADC_Config - 1u].gval;
 162   1          CY_SET_REG16(ADC_DEC_GCOR_16B_PTR, ADC_gcor[ADC_Config - 1u].gcor);
 163   1      
 164   1          /* Initialize the registers with default customizer settings for config1 */
 165   1          ADC_InitConfig(ADC_Config);
 166   1      }
 167          
 168          
 169          /******************************************************************************
 170          * Function Name: ADC_Enable
 171          *******************************************************************************
 172          *
 173          * Summary:
 174          *  Enables the ADC DelSig block operation.
 175          *
 176          *
 177          * Parameters:
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 4   

 178          *  None
 179          *
 180          * Return:
 181          *  None
 182          *
 183          *******************************************************************************/
 184          void ADC_Enable(void) 
 185          {
 186   1              uint8 config;
 187   1          uint8 enableInterrupts;
 188   1          enableInterrupts = CyEnterCriticalSection();
 189   1      
 190   1          /* Read volatile variable to the local variable */
 191   1          config = ADC_Config;
 192   1          
 193   1          /* Enable active mode power for ADC */
 194   1          ADC_PWRMGR_DEC_REG |= ADC_ACT_PWR_DEC_EN;
 195   1          ADC_PWRMGR_DSM_REG |= ADC_ACT_PWR_DSM_EN;
 196   1      
 197   1           /* Enable alternative active mode power for ADC */
 198   1          ADC_STBY_PWRMGR_DEC_REG |= ADC_STBY_PWR_DEC_EN;
 199   1          ADC_STBY_PWRMGR_DSM_REG |= ADC_STBY_PWR_DSM_EN;
 200   1      
 201   1          /* Disable PRES, Enable power to VCMBUF0, REFBUF0 and REFBUF1, enable PRES */
 202   1          ADC_RESET_CR4_REG |= ADC_IGNORE_PRESA1;
 203   1          ADC_RESET_CR5_REG |= ADC_IGNORE_PRESA2;
 204   1      
 205   1          ADC_DSM_CR17_REG |= (ADC_DSM_EN_BUF_VREF | ADC_DSM_EN_BUF_VCM);
 206   1      
 207   1          /* Code to disable the REFBUF0 if reference chosen is External ref */
 208   1          #if (((ADC_CFG1_REFERENCE == ADC_EXT_REF_ON_P03) || \
 209   1                (ADC_CFG1_REFERENCE == ADC_EXT_REF_ON_P32)) || \
 210   1               ((ADC_DEFAULT_NUM_CONFIGS > 1) && \
 211   1                ((ADC_CFG2_REFERENCE == ADC_EXT_REF_ON_P03) ||  \
 212   1                 (ADC_CFG2_REFERENCE == ADC_EXT_REF_ON_P32))) || \
 213   1               ((ADC_DEFAULT_NUM_CONFIGS > 2) && \
 214   1                ((ADC_CFG3_REFERENCE == ADC_EXT_REF_ON_P03) ||  \
 215   1                 (ADC_CFG3_REFERENCE == ADC_EXT_REF_ON_P32))) || \
 216   1               ((ADC_DEFAULT_NUM_CONFIGS > 3) && \
 217   1                ((ADC_CFG4_REFERENCE == ADC_EXT_REF_ON_P03) || \
 218   1                 (ADC_CFG4_REFERENCE == ADC_EXT_REF_ON_P32))))
                      if (((config == 1u) &&
                          ((ADC_CFG1_REFERENCE == ADC_EXT_REF_ON_P03) ||
                           (ADC_CFG1_REFERENCE == ADC_EXT_REF_ON_P32))) ||
                          ((config == 2u) &&
                          ((ADC_CFG2_REFERENCE == ADC_EXT_REF_ON_P03) ||
                           (ADC_CFG2_REFERENCE == ADC_EXT_REF_ON_P32))) ||
                          ((config == 3u) &&
                          ((ADC_CFG3_REFERENCE == ADC_EXT_REF_ON_P03) ||
                           (ADC_CFG3_REFERENCE == ADC_EXT_REF_ON_P32))) ||
                          ((config == 4u) &&
                          ((ADC_CFG4_REFERENCE == ADC_EXT_REF_ON_P03) ||
                           (ADC_CFG4_REFERENCE == ADC_EXT_REF_ON_P32))))
                      {
                          /* Disable the REFBUF0 */
                          ADC_DSM_CR17_REG &= (uint8)~ADC_DSM_EN_BUF_VREF;
                      }
                  #endif /* External ref */
 236   1      
 237   1          #if (((ADC_CFG1_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) || \
 238   1               ((ADC_DEFAULT_NUM_CONFIGS > 1) && \
 239   1                (ADC_CFG2_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)) || \
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 5   

 240   1               ((ADC_DEFAULT_NUM_CONFIGS > 2) && \
 241   1                (ADC_CFG3_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)) || \
 242   1               ((ADC_DEFAULT_NUM_CONFIGS > 3) && \
 243   1                (ADC_CFG4_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF))))
                      if(((config == 1u) &&
                          (ADC_CFG1_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) &&
                          ((ADC_CFG1_REFERENCE != ADC_EXT_REF_ON_P03) &&
                           (ADC_CFG1_REFERENCE != ADC_EXT_REF_ON_P32))) ||
                           ((config == 2u) &&
                            (ADC_CFG2_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) &&
                           ((ADC_CFG2_REFERENCE != ADC_EXT_REF_ON_P03) &&
                           (ADC_CFG2_REFERENCE != ADC_EXT_REF_ON_P32))) ||
                           ((config == 3u) &&
                            (ADC_CFG3_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) &&
                           ((ADC_CFG3_REFERENCE != ADC_EXT_REF_ON_P03) &&
                           (ADC_CFG3_REFERENCE != ADC_EXT_REF_ON_P32))) ||
                           ((config == 4u) &&
                            (ADC_CFG4_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) &&
                           ((ADC_CFG4_REFERENCE != ADC_EXT_REF_ON_P03) &&
                           (ADC_CFG4_REFERENCE != ADC_EXT_REF_ON_P32))))
                      {
                          /* Enable the REFBUF1 */
                          ADC_DSM_REF0_REG |= ADC_DSM_EN_BUF_VREF_INN;
                      }
                  #endif /* VSSA_TO_2VREF */
 265   1          if(config != 0u)
 266   1          {
 267   2              /* Suppress compiler warning */
 268   2          }
 269   1      
 270   1          /* Wait for 3 microseconds */
 271   1          CyDelayUs(ADC_PRES_DELAY_TIME);
 272   1      
 273   1          /* Enable the press circuit */
 274   1          ADC_RESET_CR4_REG &= (uint8)~ADC_IGNORE_PRESA1;
 275   1          ADC_RESET_CR5_REG &= (uint8)~ADC_IGNORE_PRESA2;
 276   1      
 277   1          /* Enable negative pumps for DSM  */
 278   1          ADC_PUMP_CR1_REG  |= ( ADC_PUMP_CR1_CLKSEL | ADC_PUMP_CR1_FORCE );
 279   1      
 280   1          /* Enable Modulator Chopping if required */
 281   1          ADC_DSM_CR2_REG = ADC_CFG1_DSM_CR2;
 282   1      
 283   1          /* This is only valid if there is an internal clock */
 284   1          #if(ADC_DEFAULT_INTERNAL_CLK)
 285   1              ADC_PWRMGR_CLK_REG |= ADC_ACT_PWR_CLK_EN;
 286   1              ADC_STBY_PWRMGR_CLK_REG |= ADC_STBY_PWR_CLK_EN;
 287   1          #endif /* ADC_DEFAULT_INTERNAL_CLK */
 288   1      
 289   1          /* Enable the active and alternate active power for charge pump clock */
 290   1          ADC_PWRMGR_CHARGE_PUMP_CLK_REG |= ADC_ACT_PWR_CHARGE_PUMP_CLK_EN;
 291   1          ADC_STBY_PWRMGR_CHARGE_PUMP_CLK_REG |= ADC_STBY_PWR_CHARGE_PUMP_CLK_EN;
 292   1      
 293   1          #if(ADC_IRQ_REMOVE == 0u)
 294   1              /* Clear a pending interrupt */
 295   1              CyIntClearPending(ADC_INTC_NUMBER);
 296   1              /* Enable interrupt */
 297   1              CyIntEnable(ADC_INTC_NUMBER);
 298   1          #endif   /* End ADC_IRQ_REMOVE */
 299   1      
 300   1          CyExitCriticalSection(enableInterrupts);
 301   1      
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 6   

 302   1      }
 303          
 304          
 305          /*******************************************************************************
 306          * Function Name: ADC_Start
 307          ********************************************************************************
 308          *
 309          * Summary:
 310          *  Performs all required initialization for this component and enables
 311          *  the power. It configure all the register the first time it is called.
 312          *  Subsequent calls of the Start function only enable the ADC and turn
 313          *  on the power. If multiple configurations are selected, it will
 314          *  configure the ADC for configuration 1 by default, unless the
 315          *  ADC_SelectConfiguration( ) function has been called to change
 316          *  the default setting.
 317          *
 318          * Parameters:
 319          *  None
 320          *
 321          * Return:
 322          *  None
 323          *
 324          * Global variables:
 325          *  ADC_initVar:  Used to check the initial configuration,
 326          *  modified when this function is called for the first time.
 327          *
 328          *******************************************************************************/
 329          void ADC_Start(void) 
 330          {
 331   1          if(ADC_initVar == 0u)
 332   1          {
 333   2              if(ADC_started == 0u)
 334   2              {
 335   3                  ADC_Init();
 336   3              }
 337   2              ADC_initVar = 1u;
 338   2          }
 339   1      
 340   1          /* Enable the ADC */
 341   1          ADC_Enable();
 342   1      }
 343          
 344          
 345          /*******************************************************************************
 346          * Function Name: ADC_Stop
 347          ********************************************************************************
 348          *
 349          * Summary:
 350          *  This function stops and powers down the ADC component and the internal
 351          *  clock if the external clock is not selected. If an external clock is
 352          *  used, it is up to the designer to power down the external clock it
 353          *  required.
 354          *
 355          * Parameters:
 356          *  None
 357          *
 358          * Return:
 359          *  None
 360          *
 361          *******************************************************************************/
 362          void ADC_Stop(void) 
 363          {
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 7   

 364   1          uint8 enableInterrupts;
 365   1          enableInterrupts = CyEnterCriticalSection();
 366   1      
 367   1          /* Stop conversions */
 368   1          ADC_DEC_CR_REG &= (uint8)~ADC_DEC_START_CONV;
 369   1          ADC_DEC_SR_REG |=  ADC_DEC_INTR_CLEAR;
 370   1      
 371   1          /* Disable PRES, Disable power to VCMBUF0, REFBUF0 and REFBUF1,
 372   1             enable PRES */
 373   1          ADC_RESET_CR4_REG |= ADC_IGNORE_PRESA1;
 374   1          ADC_RESET_CR5_REG |= ADC_IGNORE_PRESA2;
 375   1      
 376   1          ADC_DSM_CR17_REG &= (uint8)~(ADC_DSM_EN_BUF_VREF | ADC_DSM_EN_BUF_VCM);
 377   1          ADC_DSM_REF0_REG &= (uint8)~ADC_DSM_EN_BUF_VREF_INN;
 378   1      
 379   1          /* Wait for 3 microseconds. */
 380   1          CyDelayUs(ADC_PRES_DELAY_TIME);
 381   1      
 382   1          /* Enable the press circuit */
 383   1          ADC_RESET_CR4_REG &= (uint8)~ADC_IGNORE_PRESA1;
 384   1          ADC_RESET_CR5_REG &= (uint8)~ADC_IGNORE_PRESA2;
 385   1      
 386   1          /* Disable power to the ADC */
 387   1          ADC_PWRMGR_DSM_REG &= (uint8)~ADC_ACT_PWR_DSM_EN;
 388   1      
 389   1          /* Disable power to Decimator block */
 390   1          ADC_PWRMGR_DEC_REG &= (uint8)~ADC_ACT_PWR_DEC_EN;
 391   1      
 392   1          /* Disable alternative active power to the ADC */
 393   1          ADC_STBY_PWRMGR_DEC_REG &= (uint8)~ADC_STBY_PWR_DEC_EN;
 394   1          ADC_STBY_PWRMGR_DSM_REG &= (uint8)~ADC_STBY_PWR_DSM_EN;
 395   1      
 396   1         /* Disable negative pumps for DSM  */
 397   1          ADC_PUMP_CR1_REG &= (uint8)~(ADC_PUMP_CR1_CLKSEL | ADC_PUMP_CR1_FORCE );
 398   1      
 399   1          /* This is only valid if there is an internal clock */
 400   1          #if(ADC_DEFAULT_INTERNAL_CLK)
 401   1              ADC_PWRMGR_CLK_REG &= (uint8)~ADC_ACT_PWR_CLK_EN;
 402   1              ADC_STBY_PWRMGR_CLK_REG &= (uint8)~ADC_STBY_PWR_CLK_EN;
 403   1          #endif /* ADC_DEFAULT_INTERNAL_CLK */
 404   1      
 405   1          /* Disable Modulator Chopping */
 406   1          ADC_DSM_CR2_REG &= (uint8)~ADC_DSM_MOD_CHOP_EN;
 407   1          /* Disable power to charge pump clock */
 408   1          ADC_PWRMGR_CHARGE_PUMP_CLK_REG &= (uint8)~ADC_ACT_PWR_CHARGE_PUMP_CLK_EN;
 409   1          ADC_STBY_PWRMGR_CHARGE_PUMP_CLK_REG &= (uint8)~ADC_STBY_PWR_CHARGE_PUMP_CLK_EN;
 410   1          
 411   1          CyExitCriticalSection(enableInterrupts);
 412   1      }
 413          
 414          
 415          /*******************************************************************************
 416          * Function Name: ADC_SetBufferGain
 417          ********************************************************************************
 418          *
 419          * Summary:
 420          *  Sets input buffer gain.
 421          *
 422          * Parameters:
 423          *  gain:  Two bit value to select a gain of 1, 2, 4, or 8.
 424          *
 425          * Return:
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 8   

 426          *  None
 427          *
 428          *******************************************************************************/
 429          void ADC_SetBufferGain(uint8 gain) 
 430          {
 431   1          uint8 tmpReg;
 432   1          tmpReg = ADC_DSM_BUF1_REG & (uint8)~ADC_DSM_GAIN_MASK;
 433   1          tmpReg |= (uint8)(gain << ADC_DSM_GAIN_SHIFT) & ADC_DSM_GAIN_MASK;
 434   1          ADC_DSM_BUF1_REG = tmpReg;
 435   1      }
 436          
 437          
 438          /*******************************************************************************
 439          * Function Name: ADC_SetCoherency
 440          ********************************************************************************
 441          *
 442          * Summary:
 443          *  This function allows the user to change which of the ADC's 3 word
 444          *  result will trigger a coherency unlock. The ADC's result will not be
 445          *  updated until the set byte is read either by the ADC or DMA. 
 446          *  By default the LSB is the coherency byte for right alignment data format. 
 447          *  The middle or high byte is set automatically depend on left alignment 
 448          *  configuration for DMA data transfer.
 449          *  If DMA or if a custom API requires different byte to be read the last,
 450          *  this API should be used to set the last byte of the ADC result that is read. 
 451          *  If a multibyte read is performed either by DMA or the ARM processor, the
 452          *  coherency can be set to any byte in the last word read.
 453          *
 454          * Parameters:
 455          *  coherency:  Two bit value to set the coherency bit.
 456          *           00-Coherency checking off
 457          *           01-low byte is key byte
 458          *           02-middle byte is the key byte
 459          *           03-high byte is the key byte
 460          *
 461          * Return:
 462          *  None
 463          *
 464          *******************************************************************************/
 465          void ADC_SetCoherency(uint8 coherency) 
 466          {
 467   1          uint8 tmpReg;
 468   1      
 469   1          tmpReg = ADC_DEC_COHER_REG & (uint8)~ADC_DEC_SAMP_KEY_MASK;
 470   1          tmpReg |= coherency & ADC_DEC_SAMP_KEY_MASK;
 471   1          ADC_DEC_COHER_REG = tmpReg;
 472   1      }
 473          
 474          
 475          /*******************************************************************************
 476          * Function Name: ADC_SetGCOR
 477          ********************************************************************************
 478          *
 479          * Summary:
 480          *  Calculates a new GCOR value and writes it into the GCOR register. 
 481          *  The GCOR value is a 16-bit value that represents a gain of 0 to 2. 
 482          *  The ADC result is multiplied by this value before it is placed in the ADC 
 483          *  output registers. The numerical format for the GCOR value is:
 484          *  0x0000 -> 0.000
 485          *  0x8000 -> 1.000
 486          *  0xFFFF -> 1.99997
 487          *  When executing the function, the old GCOR value is multiplied by
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 9   

 488          *  gainAdjust and reloaded into the GCOR register.
 489          *
 490          * Parameters:
 491          *  gainAdjust:  floating point value to set GCOR registers.
 492          *
 493          * Return:
 494          *  uint8: 0 - if GCOR value is within the expected range.
 495          *         1 - the correction value is outside GCOR value range of
 496          *             0.00 to 1.9999.
 497          *
 498          * Side Effects:  The GVAL register is set to the amount of valid bits in the
 499          *                GCOR  register minus one. If GVAL is 15 (0x0F), all 16 bits
 500          *                of the GCOR registers will be valid. If for example GVAL is
 501          *                11 (0x0B) only 12 bits will be valid. The least 4 bits will
 502          *                be lost when the GCOR value is shifted 4 places to the right.
 503          *
 504          ******************************************************************************/
 505          uint8 ADC_SetGCOR(float32 gainAdjust) 
 506          {
 507   1          uint16 tmpReg;
 508   1          uint8 status;
 509   1          float32 tmpValue;
 510   1      
 511   1          tmpReg = ADC_gcor[ADC_Config - 1u].gcor;
 512   1          tmpValue = ((float32)tmpReg / (float32)ADC_IDEAL_GAIN_CONST);
 513   1          tmpValue = tmpValue * gainAdjust;
 514   1      
 515   1          if (tmpValue > 1.9999)
 516   1          {
 517   2              status = 1u;
 518   2          }
 519   1          else
 520   1          {
 521   2              tmpValue *= (float32)ADC_IDEAL_GAIN_CONST;
 522   2                      tmpReg = (uint16)tmpValue;
 523   2              CY_SET_REG16(ADC_DEC_GCOR_16B_PTR, tmpReg);
 524   2              /* Update gain array to be used by SelectConfiguration() API */
 525   2             ADC_gcor[ADC_Config - 1u].gcor = tmpReg;
 526   2      
 527   2              status = 0u;
 528   2      
 529   2          }
 530   1          return(status);
 531   1      }
 532          
 533          
 534          /******************************************************************************
 535          * Function Name: ADC_ReadGCOR
 536          *******************************************************************************
 537          *
 538          * Summary:
 539          *  This API returns the current GCOR register value, normalized based on the
 540          *  GVAL register settings.
 541          *  For example, if the GCOR value is 0x0812 and the GVAL register is set to 
 542          *  11 (0x0B) then the returned value will be shifted by for bits to the left.
 543          *  (Actual GCOR value = 0x0812, returned value = 0x8120)
 544          *
 545          * Parameters:
 546          *  None
 547          *
 548          * Return:
 549          *  uint16:  Normalized GCOR value.
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 10  

 550          *
 551          *******************************************************************************/
 552          uint16 ADC_ReadGCOR(void) 
 553          {
 554   1          uint8 gValue;
 555   1          uint16 gcorValue;
 556   1      
 557   1          gValue = ADC_DEC_GVAL_REG;
 558   1          gcorValue = CY_GET_REG16(ADC_DEC_GCOR_16B_PTR);
 559   1      
 560   1          if (gValue < ADC_MAX_GVAL)
 561   1          {
 562   2              gcorValue <<= ADC_MAX_GVAL - gValue;
 563   2          }
 564   1      
 565   1          return gcorValue;
 566   1      }
 567          
 568          
 569          /*******************************************************************************
 570          * Function Name: ADC_StartConvert
 571          ********************************************************************************
 572          *
 573          * Summary:
 574          *  Forces the ADC to initiate a conversion. If in the "Single Sample"
 575          *  mode, one conversion will be performed then the ADC will halt. If in
 576          *  one of the other three conversion modes, the ADC will run
 577          *  continuously until the ADC_Stop() or ADC_StopConvert() is called.
 578          *
 579          * Parameters:
 580          *  None
 581          *
 582          * Return:
 583          *  None
 584          *
 585          *******************************************************************************/
 586          void ADC_StartConvert(void) 
 587          {
 588   1          /* Start the conversion */
 589   1          ADC_DEC_CR_REG |= ADC_DEC_START_CONV;
 590   1      }
 591          
 592          
 593          /*******************************************************************************
 594          * Function Name: ADC_StopConvert
 595          ********************************************************************************
 596          *
 597          * Summary:
 598          *  Forces the ADC to stop all conversions. If the ADC is in the middle of a
 599          *  conversion, the ADC will be reset and not provide a result for that partial
 600          *  conversion.
 601          *
 602          * Parameters:
 603          *  None
 604          *
 605          * Return:
 606          *  None
 607          *
 608          *******************************************************************************/
 609          void ADC_StopConvert(void) 
 610          {
 611   1          /* Stop all conversions */
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 11  

 612   1          ADC_DEC_CR_REG &= (uint8)~ADC_DEC_START_CONV;
 613   1      }
 614          
 615          
 616          /*******************************************************************************
 617          * Function Name: ADC_IsEndConversion
 618          ********************************************************************************
 619          *
 620          * Summary:
 621          *  Checks the status that the most recently started conversion has completed.
 622          *  The status is cleared by any of ADC_GetResult8(), ADC_GetResult16() or 
 623          *  ADC_GetResult32() API.
 624          *  This function provides the programmer with two options. In one mode this 
 625          *  function immediately returns with the conversion status. In the other mode,
 626          *  the function does not return (blocking) until the conversion has completed.
 627          *
 628          * Parameters:
 629          *  retMode: Check conversion return mode. See the following table for options.
 630          *   ADC_RETURN_STATUS -   Immediately returns conversion result
 631          *                                      status.
 632          *   ADC_WAIT_FOR_RESULT - Does not return until ADC conversion
 633          *                                      is complete.
 634          *
 635          * Return:
 636          *  If a nonzero value is returned, the last conversion has completed.
 637          *  If the returned value is zero, the ADC is still calculating the last result.
 638          *
 639          * Global variables:
 640          *  ADC_convDone:  Used to check whether conversion is complete
 641          *  or not for single sample mode with resolution is above 16
 642          *
 643          *******************************************************************************/
 644          uint8 ADC_IsEndConversion(uint8 retMode) 
 645          {
 646   1          uint8 status;
 647   1      
 648   1          do
 649   1          {
 650   2              /* Check for stop convert if conversion mode is Single Sample with
 651   2              *   resolution above 16 bit
 652   2              */
 653   2              if(ADC_stopConversion != 0u)
 654   2              {
 655   3                  status = ADC_convDone;
 656   3              }
 657   2              else
 658   2              {
 659   3                  status = ADC_DEC_SR_REG & ADC_DEC_CONV_DONE;
 660   3              }
 661   2          }while((status != ADC_DEC_CONV_DONE) && (retMode == ADC_WAIT_FOR_RESULT));
 662   1      
 663   1          return(status);
 664   1      }
 665          
 666          
 667          /*******************************************************************************
 668          * Function Name: ADC_GetResult8
 669          ********************************************************************************
 670          *
 671          * Summary:
 672          *  This function returns the result of an 8-bit conversion. If the
 673          *  resolution is set greater than 8-bits, the LSB of the result will be
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 12  

 674          *  returned. When the ADC is configured for 8-bit single ended mode,
 675          *  the ADC_GetResult16() function should be used instead. This
 676          *  function returns only signed 8-bit values. The maximum positive
 677          *  signed 8-bit value is 127, but in singled ended 8-bit mode, the
 678          *  maximum positive value is 255.
 679          *
 680          * Parameters:
 681          *  None
 682          *
 683          * Return:
 684          *  int8: The LSB of the last ADC conversion.
 685          *
 686          * Global variables:
 687          *  ADC_convDone:  Cleared in single sample mode with resolution
 688          *                              above 16 bits
 689          *
 690          *******************************************************************************/
 691          int8 ADC_GetResult8( void ) 
 692          {
 693   1          int8 result;
 694   1          uint8 coherency;
 695   1      
 696   1          /* Read active coherency configuration */
 697   1          coherency = ADC_DEC_COHER_REG & ADC_DEC_SAMP_KEY_MASK;
 698   1      
 699   1          result = (int8)ADC_DEC_SAMP_REG;
 700   1      
 701   1          if(coherency == ADC_DEC_SAMP_KEY_MID)
 702   1          {   /* Dummy read of the middle byte to unlock the coherency */
 703   2              (void)ADC_DEC_SAMPM_REG;
 704   2          }
 705   1          else  if(coherency == ADC_DEC_SAMP_KEY_HIGH)
 706   1          {   /* Dummy read of the MSB byte to unlock the coherency */
 707   2              (void)ADC_DEC_SAMPH_REG;
 708   2          }
 709   1          else /*No action required for other coherency */
 710   1          {
 711   2          }
 712   1          /* Clear conversion complete status in Single Sample mode with resolution above 16 bit */
 713   1          if(ADC_stopConversion != 0u)
 714   1          {
 715   2              ADC_convDone = 0u;
 716   2          }
 717   1          return (result);
 718   1      }
 719          
 720          
 721          /*******************************************************************************
 722          * Function Name: ADC_GetResult16
 723          ********************************************************************************
 724          *
 725          * Summary:
 726          *  Returns a 16-bit result for a conversion with a result that has a
 727          *  resolution of 8 to 16 bits. If the resolution is set greater than 16-bits,
 728          *  it will return the 16 least significant bits of the result. When the ADC
 729          *  is configured for 16-bit single ended mode, the ADC_GetResult32()
 730          *  function should be used instead. This function returns only signed
 731          *  16-bit result, which allows a maximum positive value of 32767, not 65535.
 732          *  This function supports different coherency settings.
 733          *
 734          * Parameters:
 735          *   void
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 13  

 736          *
 737          * Return:
 738          *  int16:  ADC result.
 739          *
 740          * Global variables:
 741          *  ADC_convDone:  Cleared in single sample mode with resolution
 742          *                              above 16 bits
 743          *
 744          *******************************************************************************/
 745          int16 ADC_GetResult16(void) 
 746          {
 747   1          uint16 result;
 748   1          uint8 coherency;
 749   1      
 750   1          /* Read active coherency configuration */
 751   1          coherency = ADC_DEC_COHER_REG & ADC_DEC_SAMP_KEY_MASK;
 752   1      
 753   1          if(coherency <= ADC_DEC_SAMP_KEY_LOW)
 754   1          {   /*  Use default method to read result registers i.e. LSB byte read at the end*/
 755   2              #if (CY_PSOC3)
 756   2                  result = ADC_DEC_SAMPM_REG;
 757   2                  result = (result << 8u) | ADC_DEC_SAMP_REG;
 758   2              #else
                          result = (CY_GET_REG16(ADC_DEC_SAMP_16B_PTR));
                      #endif /* CY_PSOC3 */
 761   2          }
 762   1          else /* MID or HIGH */
 763   1          {   /* Read middle byte at the end */
 764   2              #if (CY_PSOC3)
 765   2                  result = (CY_GET_REG16(ADC_DEC_SAMP_16B_PTR));
 766   2              #else
                          result = ADC_DEC_SAMP_REG;
                          result |=  (uint16)((uint16)ADC_DEC_SAMPM_REG << 8u);
                      #endif /* CY_PSOC3 */
 770   2              if(coherency == ADC_DEC_SAMP_KEY_HIGH)
 771   2              {   /* Dummy read of the MSB byte to unlock the coherency */
 772   3                  (void)ADC_DEC_SAMPH_REG;
 773   3              }
 774   2          }
 775   1          /* Clear conversion complete status in Single Sample mode with resolution above 16 bit */
 776   1          if(ADC_stopConversion != 0u)
 777   1          {
 778   2              ADC_convDone = 0u;
 779   2          }
 780   1      
 781   1          return ((int16)result);
 782   1      }
 783          
 784          
 785          /*******************************************************************************
 786          * Function Name: ADC_GetResult32
 787          ********************************************************************************
 788          *
 789          * Summary:
 790          *  Returns a 32-bit result for a conversion with a result that has a
 791          *  resolution of 8 to 20 bits.
 792          *  This function supports different coherency settings.
 793          *
 794          * Parameters:
 795          *  None
 796          *
 797          * Return:
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 14  

 798          *  int32: Result of the last ADC conversion.
 799          *
 800          * Global variables:
 801          *  ADC_convDone:  Cleared in single sample mode with resolution
 802          *                              above 16 bits
 803          *
 804          *******************************************************************************/
 805          int32 ADC_GetResult32(void) 
 806          {
 807   1          uint32 result;
 808   1          uint8 coherency;
 809   1          #if (CY_PSOC3)
 810   1                  uint16 tmp;
 811   1          #endif /* CY_PSOC3 */
 812   1      
 813   1          /* Read active coherency configuration */
 814   1          coherency = ADC_DEC_COHER_REG & ADC_DEC_SAMP_KEY_MASK;
 815   1      
 816   1          if(coherency <= ADC_DEC_SAMP_KEY_LOW)
 817   1          {   /*  Use default method to read result registers i.e. LSB byte read at the end*/
 818   2              #if (CY_PSOC3)
 819   2                  result = ADC_DEC_SAMPH_REG;
 820   2                  if((result & 0x80u) != 0u)
 821   2                  {   /* Sign extend */
 822   3                      result |= 0xFF00u;
 823   3                  }
 824   2                  result = (result << 8u) | ADC_DEC_SAMPM_REG;
 825   2                  result = (result << 8u) | ADC_DEC_SAMP_REG;
 826   2              #else
                          result = CY_GET_REG16(ADC_DEC_SAMPH_16B_PTR);
                          result = (result << 16u) | (CY_GET_REG16(ADC_DEC_SAMP_16B_PTR));
                      #endif /* CY_PSOC3 */
 830   2          }
 831   1          else if(coherency == ADC_DEC_SAMP_KEY_MID)
 832   1          {   /* Read middle byte at the end */
 833   2              #if (CY_PSOC3)
 834   2                  result = ADC_DEC_SAMPH_REG;
 835   2                  if((result & 0x80u) != 0u)
 836   2                  {   /* Sign extend */
 837   3                      result |= 0xFF00u;
 838   3                  }
 839   2                  result = (result << 16u) | (CY_GET_REG16(ADC_DEC_SAMP_16B_PTR));
 840   2              #else
                          result = CY_GET_REG16(ADC_DEC_SAMPH_16B_PTR);
                          result = (result << 16u) | ADC_DEC_SAMP_REG;
                          result |=  (uint32)((uint32)ADC_DEC_SAMPM_REG << 8u);
                      #endif /* CY_PSOC3 */
 845   2          }
 846   1          else /*ADC_DEC_SAMP_KEY_HIGH */
 847   1          {
 848   2              /* Read MSB byte at the end */
 849   2              #if (CY_PSOC3)
 850   2                  result = CY_GET_REG16(ADC_DEC_SAMP_16B_PTR);
 851   2                              tmp = ADC_DEC_SAMPH_REG;
 852   2                  if((tmp & 0x80u) != 0u)
 853   2                  {   /* Sign extend */
 854   3                      tmp |= 0xFF00u;
 855   3                  }
 856   2                  result |= (uint32)tmp << 16u;
 857   2              #else
                          result = CY_GET_REG16(ADC_DEC_SAMP_16B_PTR);
                          result |= (uint32)((uint32)CY_GET_REG16(ADC_DEC_SAMPH_16B_PTR) << 16u);
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 15  

                      #endif /* CY_PSOC3 */
 861   2          }
 862   1          /* Clear conversion complete status in Single Sample mode with resolution above 16 bit */
 863   1          if(ADC_stopConversion != 0u)
 864   1          {
 865   2              ADC_convDone = 0u;
 866   2          }
 867   1      
 868   1          return ((int32)result);
 869   1      }
 870          
 871          
 872          /*******************************************************************************
 873          * Function Name: ADC_SetOffset
 874          ********************************************************************************
 875          *
 876          * Summary:
 877          *  Sets the ADC offset which is used by the functions ADC_CountsTo_uVolts, 
 878          *  ADC_CountsTo_mVolts, and ADC_CountsTo_Volts to subtract the offset from the 
 879          *  given reading before calculating the voltage conversion.
 880          *
 881          * Parameters:
 882          *  int32:  This value is a measured value when the inputs are shorted or 
 883          *          connected to the same input voltage.
 884          *
 885          * Return:
 886          *  None
 887          *
 888          * Global variables:
 889          *  ADC_Offset:  Modified to set the user provided offset. This
 890          *  variable is used for offset calibration purpose.
 891          *
 892          * Side Effects:
 893          *  Affects the ADC_CountsTo_Volts,
 894          *  ADC_CountsTo_mVolts, ADC_CountsTo_uVolts functions
 895          *  by subtracting the given offset.
 896          *
 897          *******************************************************************************/
 898          void ADC_SetOffset(int32 offset) 
 899          {
 900   1      
 901   1          ADC_Offset = offset;
 902   1      }
 903          
 904          
 905          /*******************************************************************************
 906          * Function Name: ADC_SetGain
 907          ********************************************************************************
 908          *
 909          * Summary:
 910          *  Sets the ADC gain in counts per volt for the voltage conversion
 911          *  functions below. This value is set by default by the reference and
 912          *  input range settings. It should only be used to further calibrate the
 913          *  ADC with a known input or if an external reference is used. This
 914          *  function may also be used to calibrate an entire signal chain, not
 915          *  just the ADC.
 916          *
 917          * Parameters:
 918          *  int32: ADC gain in counts per volt.
 919          *
 920          * Return:
 921          *  None
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 16  

 922          *
 923          * Global variables:
 924          *  ADC_CountsPerVolt:  modified to set the ADC gain in counts
 925          *   per volt.
 926          *
 927          * Side Effects:
 928          *  Affects the ADC_CountsTo_Volts,
 929          *  ADC_CountsTo_mVolts, ADC_CountsTo_uVolts functions
 930          *  supplying the correct conversion between ADC counts and voltage.
 931          *
 932          *******************************************************************************/
 933          void ADC_SetGain(int32 adcGain) 
 934          {
 935   1          ADC_CountsPerVolt = adcGain;
 936   1      }
 937          
 938          
 939          /*******************************************************************************
 940          * Function Name: ADC_CountsTo_mVolts
 941          ********************************************************************************
 942          *
 943          * Summary:
 944          *  Converts the ADC counts output to mVolts as a 16-bit integer. For
 945          *  example, if the ADC measured 0.534 volts, the return value would
 946          *  be 534 mVolts.
 947          *
 948          * Parameters:
 949          *  int32: adcCounts Result from the ADC conversion.
 950          *
 951          * Return:
 952          *  int16:  Result in mVolts
 953          *
 954          * Global variables:
 955          *  ADC_CountsPerVolt:  used to convert ADC counts to mVolts.
 956          *  ADC_Offset:  Used as the offset while converting ADC counts
 957          *   to mVolts.
 958          *
 959          *******************************************************************************/
 960          int16 ADC_CountsTo_mVolts(int32 adcCounts) 
 961          {
 962   1      
 963   1          int16 mVolts;
 964   1      
 965   1          /* Convert adcCounts to the right align if left option selected */
 966   1          #if(ADC_CFG1_DEC_DIV != 0)
                      if(ADC_Config == ADC_CFG1)
                      {
                          adcCounts /= ADC_CFG1_DEC_DIV;
                      }
                  #endif /* ADC_CFG1_DEC_DIV */
 972   1          #if((ADC_CFG2_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 1))
                      if(ADC_Config == ADC_CFG2)
                      {
                          adcCounts /= ADC_CFG2_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
 978   1          #if((ADC_CFG3_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 2))
                      if(ADC_Config == ADC_CFG3)
                      {
                          adcCounts /= ADC_CFG3_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 17  

 984   1          #if((ADC_CFG4_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 3))
                      if(ADC_Config == ADC_CFG4)
                      {
                          adcCounts /= ADC_CFG4_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
 990   1      
 991   1          /* Subtract ADC offset */
 992   1          adcCounts -= ADC_Offset;
 993   1      
 994   1          mVolts = (int16)(( adcCounts * ADC_1MV_COUNTS ) / ADC_CountsPerVolt) ;
 995   1      
 996   1          return(mVolts);
 997   1      }
 998          
 999          
1000          /*******************************************************************************
1001          * Function Name: ADC_CountsTo_Volts
1002          ********************************************************************************
1003          *
1004          * Summary:
1005          *  Converts the ADC output to Volts as a floating point number. For
1006          *  example, if the ADC measure a voltage of 1.2345 Volts, the
1007          *  returned result would be +1.2345 Volts.
1008          *
1009          * Parameters:
1010          *  int32 adcCounts:  Result from the ADC conversion.
1011          *
1012          * Return:
1013          *  float32: Result in Volts
1014          *
1015          * Global variables:
1016          *  ADC_CountsPerVolt:  used to convert to Volts.
1017          *  ADC_Offset:  Used as the offset while converting ADC counts
1018          *   to Volts.
1019          *
1020          *******************************************************************************/
1021          float32 ADC_CountsTo_Volts(int32 adcCounts) 
1022          {
1023   1      
1024   1          float32 Volts;
1025   1      
1026   1          /* Convert adcCounts to the right align if left option selected */
1027   1          #if(ADC_CFG1_DEC_DIV != 0)
                      if(ADC_Config == ADC_CFG1)
                      {
                          adcCounts /= ADC_CFG1_DEC_DIV;
                      }
                  #endif /* ADC_CFG1_DEC_DIV */
1033   1          #if((ADC_CFG2_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 1))
                      if(ADC_Config == ADC_CFG2)
                      {
                          adcCounts /= ADC_CFG2_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
1039   1          #if((ADC_CFG3_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 2))
                      if(ADC_Config == ADC_CFG3)
                      {
                          adcCounts /= ADC_CFG3_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
1045   1          #if((ADC_CFG4_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 3))
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 18  

                      if(ADC_Config == ADC_CFG4)
                      {
                          adcCounts /= ADC_CFG4_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
1051   1      
1052   1          /* Subtract ADC offset */
1053   1          adcCounts -= ADC_Offset;
1054   1      
1055   1          Volts = (float32)adcCounts / (float32)ADC_CountsPerVolt;
1056   1      
1057   1          return( Volts );
1058   1      }
1059          
1060          
1061          /*******************************************************************************
1062          * Function Name: ADC_CountsTo_uVolts
1063          ********************************************************************************
1064          *
1065          * Summary:
1066          *  Converts the ADC output to uVolts as a 32-bit integer. For example,
1067          *  if the ADC measured -0.02345 Volts, the return value would be -23450 uVolts.
1068          *
1069          * Parameters:
1070          *  int32 adcCounts: Result from the ADC conversion.
1071          *
1072          * Return:
1073          *  int32:  Result in uVolts
1074          *
1075          * Global variables:
1076          *  ADC_CountsPerVolt:  used to convert ADC counts to mVolts.
1077          *  ADC_Offset:  Used as the offset while converting ADC counts
1078          *   to mVolts.
1079          *
1080          * Theory:
1081          *  Care must be taken to not exceed the maximum value for a 31 bit signed
1082          *  number in the conversion to uVolts and at the same time not lose resolution.
1083          *
1084          *  uVolts = ((A * adcCounts) / ((int32)ADC_CountsPerVolt / B));
1085          *
1086          *******************************************************************************/
1087          int32 ADC_CountsTo_uVolts(int32 adcCounts) 
1088          {
1089   1      
1090   1          int32 uVolts;
1091   1          int32 coefA;
1092   1          int32 coefB;
1093   1          uint8 resolution;
1094   1      
1095   1          /* Set the resolution based on the configuration */
1096   1          /* Convert adcCounts to the right align if left option selected */
1097   1          if (ADC_Config == ADC_CFG1)
1098   1          {
1099   2              resolution = ADC_CFG1_RESOLUTION;
1100   2              #if(ADC_CFG1_DEC_DIV != 0)
                          adcCounts /= ADC_CFG1_DEC_DIV;
                      #endif /* ADC_CFG1_DEC_DIV */
1103   2          }
1104   1          else if (ADC_Config == ADC_CFG2)
1105   1          {
1106   2              resolution = ADC_CFG2_RESOLUTION;
1107   2              #if(ADC_CFG2_DEC_DIV != 0)
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 19  

                          adcCounts /= ADC_CFG2_DEC_DIV;
                      #endif /* ADC_CFG2_DEC_DIV */
1110   2          }
1111   1          else if (ADC_Config == ADC_CFG3)
1112   1          {
1113   2              resolution = ADC_CFG3_RESOLUTION;
1114   2              #if(ADC_CFG3_DEC_DIV != 0)
                          adcCounts /= ADC_CFG3_DEC_DIV;
                      #endif /* ADC_CFG3_DEC_DIV */
1117   2          }
1118   1          else
1119   1          {
1120   2              resolution = ADC_CFG4_RESOLUTION;
1121   2              #if(ADC_CFG4_DEC_DIV != 0)
                          adcCounts /= ADC_CFG4_DEC_DIV;
                      #endif /* ADC_CFG4_DEC_DIV */
1124   2          }
1125   1      
1126   1          switch (resolution)
1127   1          {
1128   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_12) || \
1129   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_12) || \
1130   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_12) || \
1131   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_12) )
1132   2                  case (uint8)ADC__BITS_12:
1133   2                      coefA = ADC_1UV_COUNTS / ADC_DIVISOR_2;
1134   2                      coefB = ADC_DIVISOR_2;
1135   2                      break;
1136   2              #endif /* ADC__BITS_12 */    
1137   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_13) || \
1138   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_13) || \
1139   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_13) || \
1140   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_13) )
                          case (uint8)ADC__BITS_13:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_4;
                              coefB = ADC_DIVISOR_4;
                              break;
                      #endif /* ADC__BITS_13 */    
1146   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_14) || \
1147   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_14) || \
1148   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_14) || \
1149   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_14) )
                          case (uint8)ADC__BITS_14:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_8;
                              coefB = ADC_DIVISOR_8;
                              break;
                      #endif /* ADC__BITS_14 */    
1155   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_15) || \
1156   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_15) || \
1157   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_15) || \
1158   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_15) )
                          case (uint8)ADC__BITS_15:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_16;
                              coefB = ADC_DIVISOR_16;
                              break;
                      #endif /* ADC__BITS_15 */    
1164   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_16) || \
1165   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_16) || \
1166   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_16) || \
1167   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_16) )
1168   2                  case (uint8)ADC__BITS_16:
1169   2                      coefA = ADC_1UV_COUNTS / ADC_DIVISOR_32;
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 20  

1170   2                      coefB = ADC_DIVISOR_32;
1171   2                      break;
1172   2              #endif /* ADC__BITS_16 */    
1173   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_17) || \
1174   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_17) || \
1175   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_17) || \
1176   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_17) )
                          case (uint8)ADC__BITS_17:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_64;
                              coefB = ADC_DIVISOR_64;
                              break;
                      #endif /* ADC__BITS_17 */    
1182   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_18) || \
1183   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_18) || \
1184   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_18) || \
1185   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_18) )
                          case (uint8)ADC__BITS_18:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_125;
                              coefB = ADC_DIVISOR_125;
                              break;
                      #endif /* ADC__BITS_18 */    
1191   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_19) || \
1192   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_19) || \
1193   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_19) || \
1194   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_19) )
                          case (uint8)ADC__BITS_19:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_250;
                              coefB = ADC_DIVISOR_250;
                              break;
                      #endif /* ADC__BITS_19 */    
1200   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_20) || \
1201   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_20) || \
1202   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_20) || \
1203   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_20) )
                          case (uint8)ADC__BITS_20:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_500;
                              coefB = ADC_DIVISOR_500;
                              break;
                      #endif /* ADC__BITS_20 */    
1209   2              default:    /* resolution < 12 */
1210   2                  /* 11 bits ADC + 2^20(1048576) = 31 bits */
1211   2                  coefA = ADC_1UV_COUNTS;
1212   2                  coefB = ADC_DIVISOR_1;
1213   2                  break;
1214   2          }
1215   1          coefB = ADC_CountsPerVolt / coefB;
1216   1          uVolts = ((coefA * adcCounts) / coefB) - ((coefA * ADC_Offset) / coefB);
1217   1      
1218   1          return( uVolts );
1219   1      }
1220          
1221          
1222          /*******************************************************************************
1223          * Function Name: ADC_InitConfig(uint8 config)
1224          ********************************************************************************
1225          *
1226          * Summary:
1227          *  Initializes all registers based on customizer settings
1228          *
1229          * Parameters:
1230          *   void
1231          *
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 21  

1232          * Return:
1233          *  None
1234          *
1235          * Global variables:
1236          *  ADC_CountsPerVolt:  Used to set the default counts per volt.
1237          *
1238          * Side Effects: Rewrites the coherency set by ADC_SetCoherency()
1239          *   API to the default value.
1240          *
1241          *******************************************************************************/
1242          static void ADC_InitConfig(uint8 config) 
1243          {
1244   1          ADC_stopConversion = 0u;
1245   1      
1246   1          if (config == 1u)
1247   1          {
1248   2              /* Default Config */
1249   2              ADC_DEC_CR_REG      = ADC_CFG1_DEC_CR;
1250   2              ADC_DEC_SHIFT1_REG  = ADC_CFG1_DEC_SHIFT1;
1251   2              ADC_DEC_SHIFT2_REG  = ADC_CFG1_DEC_SHIFT2;
1252   2              ADC_DEC_DR2_REG     = ADC_CFG1_DEC_DR2;
1253   2              ADC_DEC_DR2H_REG    = ADC_CFG1_DEC_DR2H;
1254   2              ADC_DEC_DR1_REG     = ADC_CFG1_DEC_DR1;
1255   2              ADC_DEC_OCOR_REG    = ADC_CFG1_DEC_OCOR;
1256   2              ADC_DEC_OCORM_REG   = ADC_CFG1_DEC_OCORM;
1257   2              ADC_DEC_OCORH_REG   = ADC_CFG1_DEC_OCORH;
1258   2              ADC_DEC_COHER_REG   = ADC_CFG1_DEC_COHER;
1259   2      
1260   2              ADC_DSM_CR4_REG     = ADC_CFG1_DSM_CR4;
1261   2              ADC_DSM_CR5_REG     = ADC_CFG1_DSM_CR5;
1262   2              ADC_DSM_CR6_REG     = ADC_CFG1_DSM_CR6;
1263   2              ADC_DSM_CR7_REG     = ADC_CFG1_DSM_CR7;
1264   2              ADC_DSM_CR10_REG    = ADC_CFG1_DSM_CR10;
1265   2              ADC_DSM_CR11_REG    = ADC_CFG1_DSM_CR11;
1266   2              ADC_DSM_CR12_REG    = ADC_CFG1_DSM_CR12;
1267   2              ADC_DSM_CR14_REG    = ADC_CFG1_DSM_CR14;
1268   2              ADC_DSM_CR15_REG    = ADC_CFG1_DSM_CR15;
1269   2              ADC_DSM_CR16_REG    = ADC_CFG1_DSM_CR16;
1270   2              ADC_DSM_CR17_REG    = ADC_CFG1_DSM_CR17;
1271   2              /* Set DSM_REF0_REG by disabling and enabling the PRESS circuit */
1272   2              ADC_SetDSMRef0Reg(ADC_CFG1_DSM_REF0);
1273   2              ADC_DSM_REF2_REG    = ADC_CFG1_DSM_REF2;
1274   2              ADC_DSM_REF3_REG    = ADC_CFG1_DSM_REF3;
1275   2      
1276   2              ADC_DSM_BUF0_REG    = ADC_CFG1_DSM_BUF0;
1277   2              ADC_DSM_BUF1_REG    = ADC_CFG1_DSM_BUF1;
1278   2              ADC_DSM_BUF2_REG    = ADC_CFG1_DSM_BUF2;
1279   2              ADC_DSM_BUF3_REG    = ADC_CFG1_DSM_BUF3;
1280   2      
1281   2              /* To select either Vssa or Vref to -ve input of DSM depending on
1282   2              *  the input  range selected.
1283   2              */
1284   2              #if(ADC_DEFAULT_INPUT_MODE)
1285   2                  #if (ADC_CFG1_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)
                              ADC_AMux_Select(1u);
                          #else
1288   2                      ADC_AMux_Select(0u);
1289   2                  #endif /* ADC_IR_VSSA_TO_2VREF) */
1290   2              #endif /* ADC_DEFAULT_INPUT_MODE */
1291   2      
1292   2              /* Set the Conversion stop if resolution is above 16 bit and conversion
1293   2              *   mode is Single sample
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 22  

1294   2              */
1295   2              #if(ADC_CFG1_RESOLUTION > 16 && \
1296   2                  ADC_CFG1_CONV_MODE == ADC_MODE_SINGLE_SAMPLE)
                          ADC_stopConversion = 1u;
                      #endif /* Single sample with resolution above 16 bits. */
1299   2      
1300   2              ADC_CountsPerVolt = (int32)ADC_CFG1_COUNTS_PER_VOLT;
1301   2      
1302   2              ADC_Ext_CP_Clk_SetDividerRegister(ADC_CFG1_CP_CLK_DIVIDER, 1u);
1303   2      
1304   2              /* This is only valid if there is an internal clock */
1305   2              #if(ADC_DEFAULT_INTERNAL_CLK)
1306   2                  ADC_theACLK_SetDividerRegister(ADC_CFG1_ADC_CLK_DIVIDER, 1u);
1307   2              #endif /* ADC_DEFAULT_INTERNAL_CLK */
1308   2      
1309   2              #if(ADC_IRQ_REMOVE == 0u)
1310   2                  /* Set interrupt vector */
1311   2                  (void)CyIntSetVector(ADC_INTC_NUMBER, &ADC_ISR1);
1312   2              #endif   /* End ADC_IRQ_REMOVE */
1313   2          }
1314   1      
1315   1          #if(ADC_DEFAULT_NUM_CONFIGS > 1)
                      if(config == 2u)
                      {
                          /* Second Config */
                          ADC_DEC_CR_REG      = ADC_CFG2_DEC_CR;
                          ADC_DEC_SHIFT1_REG  = ADC_CFG2_DEC_SHIFT1;
                          ADC_DEC_SHIFT2_REG  = ADC_CFG2_DEC_SHIFT2;
                          ADC_DEC_DR2_REG     = ADC_CFG2_DEC_DR2;
                          ADC_DEC_DR2H_REG    = ADC_CFG2_DEC_DR2H;
                          ADC_DEC_DR1_REG     = ADC_CFG2_DEC_DR1;
                          ADC_DEC_OCOR_REG    = ADC_CFG2_DEC_OCOR;
                          ADC_DEC_OCORM_REG   = ADC_CFG2_DEC_OCORM;
                          ADC_DEC_OCORH_REG   = ADC_CFG2_DEC_OCORH;
                          ADC_DEC_COHER_REG   = ADC_CFG2_DEC_COHER;
              
                          ADC_DSM_CR4_REG     = ADC_CFG2_DSM_CR4;
                          ADC_DSM_CR5_REG     = ADC_CFG2_DSM_CR5;
                          ADC_DSM_CR6_REG     = ADC_CFG2_DSM_CR6;
                          ADC_DSM_CR7_REG     = ADC_CFG2_DSM_CR7;
                          ADC_DSM_CR10_REG    = ADC_CFG2_DSM_CR10;
                          ADC_DSM_CR11_REG    = ADC_CFG2_DSM_CR11;
                          ADC_DSM_CR12_REG    = ADC_CFG2_DSM_CR12;
                          ADC_DSM_CR14_REG    = ADC_CFG2_DSM_CR14;
                          ADC_DSM_CR15_REG    = ADC_CFG2_DSM_CR15;
                          ADC_DSM_CR16_REG    = ADC_CFG2_DSM_CR16;
                          ADC_DSM_CR17_REG    = ADC_CFG2_DSM_CR17;
                          /* Set DSM_REF0_REG by disabling and enabling the PRESS cirucit */
                          ADC_SetDSMRef0Reg(ADC_CFG2_DSM_REF0);
                          ADC_DSM_REF2_REG    = ADC_CFG2_DSM_REF2;
                          ADC_DSM_REF3_REG    = ADC_CFG2_DSM_REF3;
              
                          ADC_DSM_BUF0_REG    = ADC_CFG2_DSM_BUF0;
                          ADC_DSM_BUF1_REG    = ADC_CFG2_DSM_BUF1;
                          ADC_DSM_BUF2_REG    = ADC_CFG2_DSM_BUF2;
                          ADC_DSM_BUF3_REG    = ADC_CFG2_DSM_BUF3;
              
                          /* To select either Vssa or Vref to -ve input of DSM depending on
                          *  the input range selected.
                          */
              
                          #if(ADC_DEFAULT_INPUT_MODE)
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 23  

                              #if (ADC_CFG2_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)
                                  ADC_AMux_Select(1u);
                              #else
                                  ADC_AMux_Select(0u);
                              #endif /* ADC_IR_VSSA_TO_2VREF) */
                          #endif /* ADC_DEFAULT_INPUT_MODE */
              
                          /* Set the Conversion stop if resolution is above 16 bit and
                          *   conversion mode is Single sample
                          */
                          #if(ADC_CFG2_RESOLUTION > 16 && \
                              ADC_CFG2_CONV_MODE == ADC_MODE_SINGLE_SAMPLE)
                              ADC_stopConversion = 1u;
                          #endif /* Single sample with resolution above 16 bits. */
              
                          ADC_CountsPerVolt = (int32)ADC_CFG2_COUNTS_PER_VOLT;
              
                          ADC_Ext_CP_Clk_SetDividerRegister(ADC_CFG2_CP_CLK_DIVIDER, 1u);
              
                          /* This is only valid if there is an internal clock */
                          #if(ADC_DEFAULT_INTERNAL_CLK)
                              ADC_theACLK_SetDividerRegister(ADC_CFG2_ADC_CLK_DIVIDER, 1u);
                          #endif /* ADC_DEFAULT_INTERNAL_CLK */
              
                          #if(ADC_IRQ_REMOVE == 0u)
                              /* Set interrupt vector */
                              (void)CyIntSetVector(ADC_INTC_NUMBER, &ADC_ISR2);
                          #endif   /* End ADC_IRQ_REMOVE */
                      }
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 1 */
1386   1      
1387   1          #if(ADC_DEFAULT_NUM_CONFIGS > 2)
                      if(config == 3u)
                      {
                          /* Third Config */
                          ADC_DEC_CR_REG      = ADC_CFG3_DEC_CR;
                          ADC_DEC_SHIFT1_REG  = ADC_CFG3_DEC_SHIFT1;
                          ADC_DEC_SHIFT2_REG  = ADC_CFG3_DEC_SHIFT2;
                          ADC_DEC_DR2_REG     = ADC_CFG3_DEC_DR2;
                          ADC_DEC_DR2H_REG    = ADC_CFG3_DEC_DR2H;
                          ADC_DEC_DR1_REG     = ADC_CFG3_DEC_DR1;
                          ADC_DEC_OCOR_REG    = ADC_CFG3_DEC_OCOR;
                          ADC_DEC_OCORM_REG   = ADC_CFG3_DEC_OCORM;
                          ADC_DEC_OCORH_REG   = ADC_CFG3_DEC_OCORH;
                          ADC_DEC_COHER_REG   = ADC_CFG3_DEC_COHER;
              
                          ADC_DSM_CR4_REG     = ADC_CFG3_DSM_CR4;
                          ADC_DSM_CR5_REG     = ADC_CFG3_DSM_CR5;
                          ADC_DSM_CR6_REG     = ADC_CFG3_DSM_CR6;
                          ADC_DSM_CR7_REG     = ADC_CFG3_DSM_CR7;
                          ADC_DSM_CR10_REG    = ADC_CFG3_DSM_CR10;
                          ADC_DSM_CR11_REG    = ADC_CFG3_DSM_CR11;
                          ADC_DSM_CR12_REG    = ADC_CFG3_DSM_CR12;
                          ADC_DSM_CR14_REG    = ADC_CFG3_DSM_CR14;
                          ADC_DSM_CR15_REG    = ADC_CFG3_DSM_CR15;
                          ADC_DSM_CR16_REG    = ADC_CFG3_DSM_CR16;
                          ADC_DSM_CR17_REG    = ADC_CFG3_DSM_CR17;
                          /* Set DSM_REF0_REG by disabling and enabling the PRESS circuit */
                          ADC_SetDSMRef0Reg(ADC_CFG3_DSM_REF0);
                          ADC_DSM_REF2_REG    = ADC_CFG3_DSM_REF2;
                          ADC_DSM_REF3_REG    = ADC_CFG3_DSM_REF3;
              
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 24  

                          ADC_DSM_BUF0_REG    = ADC_CFG3_DSM_BUF0;
                          ADC_DSM_BUF1_REG    = ADC_CFG3_DSM_BUF1;
                          ADC_DSM_BUF2_REG    = ADC_CFG3_DSM_BUF2;
                          ADC_DSM_BUF3_REG    = ADC_CFG3_DSM_BUF3;
              
                          /* To select either Vssa or Vref to -ve input of DSM depending on
                          *  the input range selected.
                          */
                          #if(ADC_DEFAULT_INPUT_MODE)
                              #if (ADC_CFG3_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)
                                  ADC_AMux_Select(1u);
                              #else
                                  ADC_AMux_Select(0u);
                              #endif /* ADC_IR_VSSA_TO_2VREF) */
                          #endif /* ADC_DEFAULT_INPUT_MODE */
              
                          /* Set the Conversion stop if resolution is above 16 bit and
                             conversion  mode is Single sample */
                          #if(ADC_CFG3_RESOLUTION > 16 && \
                              ADC_CFG3_CONV_MODE == ADC_MODE_SINGLE_SAMPLE)
                              ADC_stopConversion = 1u;
                          #endif /* Single sample with resolution above 16 bits */
              
                          ADC_CountsPerVolt = (int32)ADC_CFG3_COUNTS_PER_VOLT;
              
                          ADC_Ext_CP_Clk_SetDividerRegister(ADC_CFG3_CP_CLK_DIVIDER, 1u);
              
                          /* This is only valid if there is an internal clock */
                          #if(ADC_DEFAULT_INTERNAL_CLK)
                              ADC_theACLK_SetDividerRegister(ADC_CFG3_ADC_CLK_DIVIDER, 1u);
                          #endif /* ADC_DEFAULT_INTERNAL_CLK */
              
                          #if(ADC_IRQ_REMOVE == 0u)
                              /* Set interrupt vector */
                              (void)CyIntSetVector(ADC_INTC_NUMBER, &ADC_ISR3);
                          #endif   /* End ADC_IRQ_REMOVE */
                      }
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 2 */
1456   1      
1457   1          #if(ADC_DEFAULT_NUM_CONFIGS > 3)
                      if (config == 4u)
                      {
                          /* Fourth Config */
                          ADC_DEC_CR_REG      = ADC_CFG4_DEC_CR;
                          ADC_DEC_SHIFT1_REG  = ADC_CFG4_DEC_SHIFT1;
                          ADC_DEC_SHIFT2_REG  = ADC_CFG4_DEC_SHIFT2;
                          ADC_DEC_DR2_REG     = ADC_CFG4_DEC_DR2;
                          ADC_DEC_DR2H_REG    = ADC_CFG4_DEC_DR2H;
                          ADC_DEC_DR1_REG     = ADC_CFG4_DEC_DR1;
                          ADC_DEC_OCOR_REG    = ADC_CFG4_DEC_OCOR;
                          ADC_DEC_OCORM_REG   = ADC_CFG4_DEC_OCORM;
                          ADC_DEC_OCORH_REG   = ADC_CFG4_DEC_OCORH;
                          ADC_DEC_COHER_REG   = ADC_CFG4_DEC_COHER;
              
                          ADC_DSM_CR4_REG     = ADC_CFG4_DSM_CR4;
                          ADC_DSM_CR5_REG     = ADC_CFG4_DSM_CR5;
                          ADC_DSM_CR6_REG     = ADC_CFG4_DSM_CR6;
                          ADC_DSM_CR7_REG     = ADC_CFG4_DSM_CR7;
                          ADC_DSM_CR10_REG    = ADC_CFG4_DSM_CR10;
                          ADC_DSM_CR11_REG    = ADC_CFG4_DSM_CR11;
                          ADC_DSM_CR12_REG    = ADC_CFG4_DSM_CR12;
                          ADC_DSM_CR14_REG    = ADC_CFG4_DSM_CR14;
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 25  

                          ADC_DSM_CR15_REG    = ADC_CFG4_DSM_CR15;
                          ADC_DSM_CR16_REG    = ADC_CFG4_DSM_CR16;
                          ADC_DSM_CR17_REG    = ADC_CFG4_DSM_CR17;
                          /* Set DSM_REF0_REG by disabling and enabling the PRESS circuit */
                          ADC_SetDSMRef0Reg(ADC_CFG4_DSM_REF0);
                          ADC_DSM_REF2_REG    = ADC_CFG4_DSM_REF2;
                          ADC_DSM_REF3_REG    = ADC_CFG4_DSM_REF3;
              
                          ADC_DSM_BUF0_REG    = ADC_CFG4_DSM_BUF0;
                          ADC_DSM_BUF1_REG    = ADC_CFG4_DSM_BUF1;
                          ADC_DSM_BUF2_REG    = ADC_CFG4_DSM_BUF2;
                          ADC_DSM_BUF3_REG    = ADC_CFG4_DSM_BUF3;
              
                          /* To select either Vssa or Vref to -ve input of DSM depending on
                          *  the input range selected.
                          */
                          #if(ADC_DEFAULT_INPUT_MODE)
                              #if (ADC_CFG4_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)
                                  ADC_AMux_Select(1u);
                              #else
                                  ADC_AMux_Select(0u);
                              #endif /* ADC_IR_VSSA_TO_2VREF) */
                          #endif /* ADC_DEFAULT_INPUT_MODE */
              
                          /* Set the Conversion stop if resolution is above 16 bit and
                             conversion mode is Single sample */
                          #if(ADC_CFG4_RESOLUTION > 16 && \
                              ADC_CFG4_CONV_MODE == ADC_MODE_SINGLE_SAMPLE)
                              ADC_stopConversion = 1u;
                          #endif /* Single sample with resolution above 16 bits */
              
                          ADC_CountsPerVolt = (int32)ADC_CFG4_COUNTS_PER_VOLT;
              
                          ADC_Ext_CP_Clk_SetDividerRegister(ADC_CFG4_CP_CLK_DIVIDER, 1u);
              
                          /* This is only valid if there is an internal clock */
                          #if(ADC_DEFAULT_INTERNAL_CLK)
                              ADC_theACLK_SetDividerRegister(ADC_CFG4_ADC_CLK_DIVIDER, 1u);
                          #endif /* ADC_DEFAULT_INTERNAL_CLK */
              
                          #if(ADC_IRQ_REMOVE == 0u)
                              /* Set interrupt vector */
                              (void)CyIntSetVector(ADC_INTC_NUMBER, &ADC_ISR4);
                          #endif   /* End ADC_IRQ_REMOVE */
                      }
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 3 */
1526   1      }
1527          
1528          
1529          /*******************************************************************************
1530          * Function Name: ADC_SelectCofiguration
1531          ********************************************************************************
1532          *
1533          * Summary:
1534          *  Sets one of up to four ADC configurations. Before setting the new
1535          *  configuration, the ADC is stopped and powered down. After setting
1536          *  the new configuration, the ADC can be powered and conversion
1537          *  can be restarted depending up on the value of second parameter
1538          *  restart. If the value of this parameter is 1, then ADC will be
1539          *  restarted. If this value is zero, then user must call ADC_Start
1540          *  and ADC_StartConvert() to restart the conversion.
1541          *
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 26  

1542          * Parameters:
1543          *  config:  configuration user wants to select.
1544          *           Valid range: 1..4
1545          *  restart:  Restart option. 1 means start the ADC and restart the conversion.
1546          *                            0 means do not start the ADC and conversion.
1547          *
1548          * Return:
1549          *  None
1550          *
1551          *******************************************************************************/
1552          void ADC_SelectConfiguration(uint8 config, uint8 restart)
1553                                                        
1554          {
1555   1          /* Check whether the configuration number is valid or not */
1556   1          if((config > 0u) && (config <= ADC_DEFAULT_NUM_CONFIGS))
1557   1          {
1558   2              /* Set the flag to ensure Start() API doesn't override the 
1559   2                      *  selected configuration
1560   2                      */
1561   2              if(ADC_initVar == 0u)
1562   2              {
1563   3                  ADC_started = 1u;
1564   3              }
1565   2      
1566   2              /* Update the config flag */
1567   2              ADC_Config = config;
1568   2      
1569   2              /* Stop the ADC  */
1570   2              ADC_Stop();
1571   2      
1572   2              /* Set the  ADC registers based on the configuration */
1573   2              ADC_InitConfig(config);
1574   2      
1575   2              /* Compensate the gain */
1576   2              ADC_DEC_GVAL_REG = ADC_gcor[config - 1u].gval;
1577   2              CY_SET_REG16(ADC_DEC_GCOR_16B_PTR, ADC_gcor[config - 1u].gcor);
1578   2      
1579   2              if(restart == 1u)
1580   2              {
1581   3                  /* Restart the ADC */
1582   3                  ADC_Start();
1583   3      
1584   3                  /* Restart the ADC conversion */
1585   3                  ADC_StartConvert();
1586   3              }
1587   2          }
1588   1          else
1589   1          {
1590   2              /* Halt CPU in debug mode if config is out of valid range */
1591   2              CYASSERT(0u != 0u);
1592   2          }
1593   1      }
1594          
1595          
1596          /*******************************************************************************
1597          * Function Name: ADC_GainCompensation
1598          ********************************************************************************
1599          *
1600          * Summary:
1601          *  This API calculates the trim value and then store this to gcor structure.
1602          *
1603          * Parameters:
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 27  

1604          *  inputRange:  input range for which trim value is to be calculated.
1605          *  IdealDecGain:  Ideal Decimator gain for the selected resolution and
1606          *                 conversion  mode.
1607          *  IdealOddDecGain:  Ideal odd decimation gain for the selected resolution and
1608                               conversion mode.
1609          *  resolution:  Resolution to select the proper flash location for trim value.
1610          *  config:      Specifies the configuration number
1611          *               Valid range: 1..4
1612          *
1613          * Return:
1614          *  None
1615          *
1616          *******************************************************************************/
1617          static void ADC_GainCompensation(uint8 inputRange, uint16 idealDecGain, uint16 idealOddDecGain,
1618                                        uint8 resolution, uint8 config) 
1619          {
1620   1          int8 flash;
1621   1              int32 normalised;
1622   1              uint16 gcorValue;
1623   1          uint32 gcorTmp;
1624   1      
1625   1          if((config > 0u) && (config <= ADC_DEFAULT_NUM_CONFIGS))
1626   1          {
1627   2              switch(inputRange)
1628   2              {
1629   3                  case ADC_IR_VNEG_VREF_DIFF:
1630   3                  case ADC_IR_VSSA_TO_2VREF:
1631   3                      /* Normalize the flash Value */
1632   3                      if(resolution > 15u)
1633   3                      {
1634   4                          flash = ADC_DEC_TRIM_VREF_DIFF_16_20;
1635   4                      }
1636   3                      else
1637   3                      {
1638   4                          flash = ADC_DEC_TRIM_VREF_DIFF_8_15;
1639   4                      }
1640   3                      break;
1641   3      
1642   3                  case ADC_IR_VNEG_VREF_2_DIFF:
1643   3                      /* Normalize the flash Value */
1644   3                      if(resolution > 15u)
1645   3                      {
1646   4                          flash = ADC_DEC_TRIM_VREF_2_DIFF_16_20;
1647   4                      }
1648   3                      else
1649   3                      {
1650   4                          flash = ADC_DEC_TRIM_VREF_2_DIFF_8_15;
1651   4                      }
1652   3                      break;
1653   3      
1654   3                  case ADC_IR_VNEG_VREF_4_DIFF:
1655   3                      /* Normalize the flash Value */
1656   3                      if(resolution > 15u)
1657   3                      {
1658   4                          flash = ADC_DEC_TRIM_VREF_4_DIFF_16_20;
1659   4                      }
1660   3                      else
1661   3                      {
1662   4                          flash = ADC_DEC_TRIM_VREF_4_DIFF_8_15;
1663   4                      }
1664   3                      break;
1665   3      
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 28  

1666   3                  case ADC_IR_VNEG_VREF_16_DIFF:
1667   3                      /* Normalize the flash Value */
1668   3                      if(resolution > 15u)
1669   3                      {
1670   4                          flash = ADC_DEC_TRIM_VREF_16_DIFF_16_20;
1671   4                      }
1672   3                      else
1673   3                      {
1674   4                          flash = ADC_DEC_TRIM_VREF_16_DIFF_8_15;
1675   4                      }
1676   3                      break;
1677   3      
1678   3                  default:
1679   3                      flash = 0;
1680   3                      break;
1681   3              }
1682   2      
1683   2              /* Add two values */
1684   2                      normalised = (int32)idealDecGain + ((int32)flash * 32);
1685   2              gcorTmp = (uint32)normalised * (uint32)idealOddDecGain;
1686   2              gcorValue = (uint16)(gcorTmp / ADC_IDEAL_GAIN_CONST);
1687   2      
1688   2              if (resolution < (ADC_MAX_GVAL - 1u))
1689   2              {
1690   3                  gcorValue = (gcorValue >> (ADC_MAX_GVAL - (resolution + 1u)));
1691   3                  ADC_gcor[config - 1u].gval = (resolution + 1u);
1692   3              }
1693   2              else
1694   2              {
1695   3                  /* Use all 16 bits */
1696   3                  ADC_gcor[config - 1u].gval = ADC_MAX_GVAL;
1697   3              }
1698   2      
1699   2              /* Save the gain correction register value */
1700   2              ADC_gcor[config - 1u].gcor = gcorValue;
1701   2          }
1702   1          else
1703   1          {
1704   2              /* Halt CPU in debug mode if config is out of valid range */
1705   2              CYASSERT(0u != 0u);
1706   2          }
1707   1      }
1708          
1709          
1710          /******************************************************************************
1711          * Function Name: ADC_SetDSMRef0Reg(uint8)
1712          ******************************************************************************
1713          *
1714          * Summary:
1715          *  This API sets the DSM_REF0 register. This is written for internal use.
1716          *
1717          * Parameters:
1718          *  value:  Value to be written to DSM_REF0 register.
1719          *
1720          * Return:
1721          *  None
1722          *
1723          ******************************************************************************/
1724          static void ADC_SetDSMRef0Reg(uint8 value) 
1725          {
1726   1          uint8 enableInterrupts;
1727   1          enableInterrupts = CyEnterCriticalSection();
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 29  

1728   1      
1729   1          /* Disable PRES, Enable power to VCMBUF0, REFBUF0 and REFBUF1, enable PRES */
1730   1          ADC_RESET_CR4_REG |= (ADC_IGNORE_PRESA1 | ADC_IGNORE_PRESD1);
1731   1          ADC_RESET_CR5_REG |= (ADC_IGNORE_PRESA2 | ADC_IGNORE_PRESD2);
1732   1          ADC_DSM_REF0_REG = value;
1733   1      
1734   1          /* Wait for 3 microseconds */
1735   1          CyDelayUs(ADC_PRES_DELAY_TIME);
1736   1          /* Enable the press circuit */
1737   1          ADC_RESET_CR4_REG &= (uint8)~(ADC_IGNORE_PRESA1 | ADC_IGNORE_PRESD1);
1738   1          ADC_RESET_CR5_REG &= (uint8)~(ADC_IGNORE_PRESA2 | ADC_IGNORE_PRESD2);
1739   1      
1740   1          CyExitCriticalSection(enableInterrupts);
1741   1      }
1742          
1743          
1744          /*******************************************************************************
1745          * Function Name: ADC_Read8
1746          ********************************************************************************
1747          *
1748          * Summary:
1749          *  This function simplifies getting results from the ADC when only a
1750          *  single reading is required. When called, it will start ADC
1751          *  conversions, wait for the conversion to be complete, stop ADC
1752          *  conversion and return the result. This is a blocking function and will
1753          *  not return until the result is ready.
1754          *
1755          * Parameters:
1756          *  None
1757          *
1758          * Return:
1759          *  int8:  ADC result.
1760          *
1761          *******************************************************************************/
1762          int8 ADC_Read8(void) 
1763          {
1764   1          int8 result;
1765   1      
1766   1          /* Clear pending conversion done status */
1767   1          ADC_DEC_SR_REG |= ADC_DEC_INTR_CLEAR;
1768   1          ADC_StartConvert();
1769   1          (void)ADC_IsEndConversion(ADC_WAIT_FOR_RESULT);
1770   1           result = ADC_GetResult8();
1771   1          ADC_StopConvert();
1772   1          
1773   1           return(result);
1774   1      }
1775          
1776          
1777          /*******************************************************************************
1778          * Function Name: ADC_Read16
1779          ********************************************************************************
1780          *
1781          * Summary:
1782          *  This function simplifies getting results from the ADC when only a
1783          *  single reading is required. When called, it will start ADC
1784          *  conversions, wait for the conversion to be complete, stop ADC
1785          *  conversion and return the result. This is a blocking function and will
1786          *  not return until the result is ready.
1787          *
1788          * Parameters:
1789          *   void
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 30  

1790          *
1791          * Return:
1792          *  int16:  ADC result.
1793          *
1794          *******************************************************************************/
1795          int16 ADC_Read16(void) 
1796          {
1797   1          int16 result;
1798   1      
1799   1          /* Clear pending conversion done status */
1800   1          ADC_DEC_SR_REG |= ADC_DEC_INTR_CLEAR;
1801   1          ADC_StartConvert();
1802   1          (void)ADC_IsEndConversion(ADC_WAIT_FOR_RESULT);
1803   1           result = ADC_GetResult16();
1804   1          ADC_StopConvert();
1805   1          
1806   1           return(result);
1807   1      }
1808          
1809          
1810          /*******************************************************************************
1811          * Function Name: ADC_Read32
1812          ********************************************************************************
1813          *
1814          * Summary:
1815          *  This function simplifies getting results from the ADC when only a
1816          *  single reading is required. When called, it will start ADC
1817          *  conversions, wait for the conversion to be complete, stop ADC
1818          *  conversion and return the result. This is a blocking function and will
1819          *  not return until the result is ready.
1820          *
1821          * Parameters:
1822          *  None
1823          *
1824          * Return:
1825          *  int32: ADC result.
1826          *
1827          *******************************************************************************/
1828          int32 ADC_Read32(void) 
1829          {
1830   1          int32 result;
1831   1          
1832   1          /* Clear pending conversion done status */
1833   1          ADC_DEC_SR_REG |= ADC_DEC_INTR_CLEAR;
1834   1          ADC_StartConvert();
1835   1          (void)ADC_IsEndConversion(ADC_WAIT_FOR_RESULT);
1836   1           result = ADC_GetResult32();
1837   1          ADC_StopConvert();
1838   1          
1839   1           return(result);
1840   1      }
1841          
1842          
1843          /* [] END OF FILE */
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 31  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION ADC_Init (BEGIN)
                                           ; SOURCE LINE # 91
                                           ; SOURCE LINE # 92
                                           ; SOURCE LINE # 94
0000 900000      R     MOV     DPTR,#ADC_Config
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 95
0006 900000      R     MOV     DPTR,#ADC_convDone
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 97
000B 7F10              MOV     R7,#010H
000D 120000      E     LCALL   _ADC_Ext_CP_Clk_SetModeRegister
                                           ; SOURCE LINE # 101
0010 7F10              MOV     R7,#010H
0012 120000      E     LCALL   _ADC_theACLK_SetModeRegister
                                           ; SOURCE LINE # 106
0015 7D07              MOV     R5,#07H
0017 7F1D              MOV     R7,#01DH
0019 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 110
001C 905896            MOV     DPTR,#05896H
001F 7404              MOV     A,#04H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 111
0022 905897            MOV     DPTR,#05897H
0025 E4                CLR     A
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 112
0027 90589E            MOV     DPTR,#0589EH
002A E4                CLR     A
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 113
002C 905B07            MOV     DPTR,#05B07H
002F E0                MOVX    A,@DPTR
0030 FF                MOV     R7,A
0031 EF                MOV     A,R7
0032 4418              ORL     A,#018H
0034 FF                MOV     R7,A
0035 EF                MOV     A,R7
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 114
0037 905893            MOV     DPTR,#05893H
003A E4                CLR     A
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 116
003C 905B88            MOV     DPTR,#05B88H
003F E4                CLR     A
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 117
0041 905B89            MOV     DPTR,#05B89H
0044 E4                CLR     A
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 119
0046 905880            MOV     DPTR,#05880H
0049 740A              MOV     A,#0AH
004B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 120
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 32  

004C 905881            MOV     DPTR,#05881H
004F E4                CLR     A
0050 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 124
0051 905883            MOV     DPTR,#05883H
0054 E4                CLR     A
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 126
0056 905888            MOV     DPTR,#05888H
0059 7412              MOV     A,#012H
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 127
005C 905889            MOV     DPTR,#05889H
005F 7413              MOV     A,#013H
0061 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 128
0062 90588D            MOV     DPTR,#0588DH
0065 E4                CLR     A
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 130
0067 904E01            MOV     DPTR,#04E01H
006A 7414              MOV     A,#014H
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 133
006D 900000      R     MOV     DPTR,#?_ADC_GainCompensation?BYTE+05H
0070 740C              MOV     A,#0CH
0072 F0                MOVX    @DPTR,A
0073 900000      R     MOV     DPTR,#?_ADC_GainCompensation?BYTE+06H
0076 7401              MOV     A,#01H
0078 F0                MOVX    @DPTR,A
0079 7B00              MOV     R3,#00H
007B 7A80              MOV     R2,#080H
007D 7D6B              MOV     R5,#06BH
007F 7C8D              MOV     R4,#08DH
0081 7F02              MOV     R7,#02H
0083 120000      R     LCALL   _ADC_GainCompensation
                                           ; SOURCE LINE # 161
0086 900000      R     MOV     DPTR,#ADC_Config
0089 E0                MOVX    A,@DPTR
008A FF                MOV     R7,A
008B EF                MOV     A,R7
008C 75F003            MOV     B,#03H
008F A4                MUL     AB
0090 2400        R     ADD     A,#LOW ADC_gcor+0FFFFH
0092 F582              MOV     DPL,A
0094 E4                CLR     A
0095 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFFH
0097 F583              MOV     DPH,A
0099 E0                MOVX    A,@DPTR
009A FF                MOV     R7,A
009B 904E0E            MOV     DPTR,#04E0EH
009E EF                MOV     A,R7
009F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 162
00A0 900000      R     MOV     DPTR,#ADC_Config
00A3 E0                MOVX    A,@DPTR
00A4 FF                MOV     R7,A
00A5 EF                MOV     A,R7
00A6 75F003            MOV     B,#03H
00A9 A4                MUL     AB
00AA 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
00AC F582              MOV     DPL,A
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 33  

00AE E4                CLR     A
00AF 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
00B1 F583              MOV     DPH,A
00B3 E0                MOVX    A,@DPTR
00B4 FC                MOV     R4,A
00B5 A3                INC     DPTR
00B6 E0                MOVX    A,@DPTR
00B7 FD                MOV     R5,A
00B8 7B02              MOV     R3,#02H
00BA 7A4E              MOV     R2,#04EH
00BC 790C              MOV     R1,#0CH
00BE 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 165
00C1 900000      R     MOV     DPTR,#ADC_Config
00C4 E0                MOVX    A,@DPTR
00C5 FF                MOV     R7,A
00C6 120000      R     LCALL   _ADC_InitConfig
                                           ; SOURCE LINE # 166
00C9 22                RET     
             ; FUNCTION ADC_Init (END)

             ; FUNCTION ADC_Enable (BEGIN)
                                           ; SOURCE LINE # 184
                                           ; SOURCE LINE # 185
                                           ; SOURCE LINE # 188
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 191
0008 900000      R     MOV     DPTR,#ADC_Config
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D 900000      R     MOV     DPTR,#config
0010 EF                MOV     A,R7
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 194
0012 9043AA            MOV     DPTR,#043AAH
0015 E0                MOVX    A,@DPTR
0016 FF                MOV     R7,A
0017 EF                MOV     A,R7
0018 4401              ORL     A,#01H
001A FF                MOV     R7,A
001B EF                MOV     A,R7
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 195
001D 9043AA            MOV     DPTR,#043AAH
0020 E0                MOVX    A,@DPTR
0021 FF                MOV     R7,A
0022 EF                MOV     A,R7
0023 4410              ORL     A,#010H
0025 FF                MOV     R7,A
0026 EF                MOV     A,R7
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 198
0028 9043BA            MOV     DPTR,#043BAH
002B E0                MOVX    A,@DPTR
002C FF                MOV     R7,A
002D EF                MOV     A,R7
002E 4401              ORL     A,#01H
0030 FF                MOV     R7,A
0031 EF                MOV     A,R7
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 34  

0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 199
0033 9043BA            MOV     DPTR,#043BAH
0036 E0                MOVX    A,@DPTR
0037 FF                MOV     R7,A
0038 EF                MOV     A,R7
0039 4410              ORL     A,#010H
003B FF                MOV     R7,A
003C EF                MOV     A,R7
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 202
003E 9046F8            MOV     DPTR,#046F8H
0041 E0                MOVX    A,@DPTR
0042 FF                MOV     R7,A
0043 EF                MOV     A,R7
0044 4402              ORL     A,#02H
0046 FF                MOV     R7,A
0047 EF                MOV     A,R7
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 203
0049 9046F9            MOV     DPTR,#046F9H
004C E0                MOVX    A,@DPTR
004D FF                MOV     R7,A
004E EF                MOV     A,R7
004F 4402              ORL     A,#02H
0051 FF                MOV     R7,A
0052 EF                MOV     A,R7
0053 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 205
0054 905891            MOV     DPTR,#05891H
0057 E0                MOVX    A,@DPTR
0058 FF                MOV     R7,A
0059 EF                MOV     A,R7
005A 4403              ORL     A,#03H
005C FF                MOV     R7,A
005D EF                MOV     A,R7
005E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 265
                                           ; SOURCE LINE # 266
                                           ; SOURCE LINE # 268
005F         ?C0002:
                                           ; SOURCE LINE # 271
005F 7F03              MOV     R7,#03H
0061 7E00              MOV     R6,#00H
0063 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 274
0066 9046F8            MOV     DPTR,#046F8H
0069 E0                MOVX    A,@DPTR
006A FF                MOV     R7,A
006B EF                MOV     A,R7
006C 54FD              ANL     A,#0FDH
006E FF                MOV     R7,A
006F EF                MOV     A,R7
0070 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 275
0071 9046F9            MOV     DPTR,#046F9H
0074 E0                MOVX    A,@DPTR
0075 FF                MOV     R7,A
0076 EF                MOV     A,R7
0077 54FD              ANL     A,#0FDH
0079 FF                MOV     R7,A
007A EF                MOV     A,R7
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 35  

007B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 278
007C 905877            MOV     DPTR,#05877H
007F E0                MOVX    A,@DPTR
0080 FF                MOV     R7,A
0081 EF                MOV     A,R7
0082 4406              ORL     A,#06H
0084 FF                MOV     R7,A
0085 EF                MOV     A,R7
0086 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 281
0087 905882            MOV     DPTR,#05882H
008A 747A              MOV     A,#07AH
008C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 285
008D 9043A1            MOV     DPTR,#043A1H
0090 E0                MOVX    A,@DPTR
0091 FF                MOV     R7,A
0092 EF                MOV     A,R7
0093 4401              ORL     A,#01H
0095 FF                MOV     R7,A
0096 EF                MOV     A,R7
0097 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 286
0098 9043B1            MOV     DPTR,#043B1H
009B E0                MOVX    A,@DPTR
009C FF                MOV     R7,A
009D EF                MOV     A,R7
009E 4401              ORL     A,#01H
00A0 FF                MOV     R7,A
00A1 EF                MOV     A,R7
00A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 290
00A3 9043A2            MOV     DPTR,#043A2H
00A6 E0                MOVX    A,@DPTR
00A7 FF                MOV     R7,A
00A8 EF                MOV     A,R7
00A9 4402              ORL     A,#02H
00AB FF                MOV     R7,A
00AC EF                MOV     A,R7
00AD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 291
00AE 9043B2            MOV     DPTR,#043B2H
00B1 E0                MOVX    A,@DPTR
00B2 FF                MOV     R7,A
00B3 EF                MOV     A,R7
00B4 4402              ORL     A,#02H
00B6 FF                MOV     R7,A
00B7 EF                MOV     A,R7
00B8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 295
00B9 9044DB            MOV     DPTR,#044DBH
00BC 7420              MOV     A,#020H
00BE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 297
00BF 9044C3            MOV     DPTR,#044C3H
00C2 7420              MOV     A,#020H
00C4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 300
00C5 900000      R     MOV     DPTR,#enableInterrupts
00C8 E0                MOVX    A,@DPTR
00C9 FF                MOV     R7,A
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 36  

00CA 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 302
00CD 22                RET     
             ; FUNCTION ADC_Enable (END)

             ; FUNCTION ADC_Start (BEGIN)
                                           ; SOURCE LINE # 329
                                           ; SOURCE LINE # 330
                                           ; SOURCE LINE # 331
0000 900000      R     MOV     DPTR,#ADC_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7011              JNZ     ?C0004
                                           ; SOURCE LINE # 332
                                           ; SOURCE LINE # 333
0008 900000      R     MOV     DPTR,#ADC_started
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 7003              JNZ     ?C0005
                                           ; SOURCE LINE # 334
                                           ; SOURCE LINE # 335
0010 120000      R     LCALL   ADC_Init
                                           ; SOURCE LINE # 336
0013         ?C0005:
                                           ; SOURCE LINE # 337
0013 900000      R     MOV     DPTR,#ADC_initVar
0016 7401              MOV     A,#01H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 338
0019         ?C0004:
                                           ; SOURCE LINE # 341
0019 120000      R     LCALL   ADC_Enable
                                           ; SOURCE LINE # 342
001C 22                RET     
             ; FUNCTION ADC_Start (END)

             ; FUNCTION ADC_Stop (BEGIN)
                                           ; SOURCE LINE # 362
                                           ; SOURCE LINE # 363
                                           ; SOURCE LINE # 365
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 368
0008 904E00            MOV     DPTR,#04E00H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 54FE              ANL     A,#0FEH
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 369
0013 904E01            MOV     DPTR,#04E01H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4404              ORL     A,#04H
001B FF                MOV     R7,A
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 37  

001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 373
001E 9046F8            MOV     DPTR,#046F8H
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 4402              ORL     A,#02H
0026 FF                MOV     R7,A
0027 EF                MOV     A,R7
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 374
0029 9046F9            MOV     DPTR,#046F9H
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E EF                MOV     A,R7
002F 4402              ORL     A,#02H
0031 FF                MOV     R7,A
0032 EF                MOV     A,R7
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 376
0034 905891            MOV     DPTR,#05891H
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 EF                MOV     A,R7
003A 54FC              ANL     A,#0FCH
003C FF                MOV     R7,A
003D EF                MOV     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 377
003F 905892            MOV     DPTR,#05892H
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 EF                MOV     A,R7
0045 54F7              ANL     A,#0F7H
0047 FF                MOV     R7,A
0048 EF                MOV     A,R7
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 380
004A 7F03              MOV     R7,#03H
004C 7E00              MOV     R6,#00H
004E 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 383
0051 9046F8            MOV     DPTR,#046F8H
0054 E0                MOVX    A,@DPTR
0055 FF                MOV     R7,A
0056 EF                MOV     A,R7
0057 54FD              ANL     A,#0FDH
0059 FF                MOV     R7,A
005A EF                MOV     A,R7
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 384
005C 9046F9            MOV     DPTR,#046F9H
005F E0                MOVX    A,@DPTR
0060 FF                MOV     R7,A
0061 EF                MOV     A,R7
0062 54FD              ANL     A,#0FDH
0064 FF                MOV     R7,A
0065 EF                MOV     A,R7
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 387
0067 9043AA            MOV     DPTR,#043AAH
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 38  

006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C EF                MOV     A,R7
006D 54EF              ANL     A,#0EFH
006F FF                MOV     R7,A
0070 EF                MOV     A,R7
0071 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 390
0072 9043AA            MOV     DPTR,#043AAH
0075 E0                MOVX    A,@DPTR
0076 FF                MOV     R7,A
0077 EF                MOV     A,R7
0078 54FE              ANL     A,#0FEH
007A FF                MOV     R7,A
007B EF                MOV     A,R7
007C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 393
007D 9043BA            MOV     DPTR,#043BAH
0080 E0                MOVX    A,@DPTR
0081 FF                MOV     R7,A
0082 EF                MOV     A,R7
0083 54FE              ANL     A,#0FEH
0085 FF                MOV     R7,A
0086 EF                MOV     A,R7
0087 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 394
0088 9043BA            MOV     DPTR,#043BAH
008B E0                MOVX    A,@DPTR
008C FF                MOV     R7,A
008D EF                MOV     A,R7
008E 54EF              ANL     A,#0EFH
0090 FF                MOV     R7,A
0091 EF                MOV     A,R7
0092 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 397
0093 905877            MOV     DPTR,#05877H
0096 E0                MOVX    A,@DPTR
0097 FF                MOV     R7,A
0098 EF                MOV     A,R7
0099 54F9              ANL     A,#0F9H
009B FF                MOV     R7,A
009C EF                MOV     A,R7
009D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 401
009E 9043A1            MOV     DPTR,#043A1H
00A1 E0                MOVX    A,@DPTR
00A2 FF                MOV     R7,A
00A3 EF                MOV     A,R7
00A4 54FE              ANL     A,#0FEH
00A6 FF                MOV     R7,A
00A7 EF                MOV     A,R7
00A8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 402
00A9 9043B1            MOV     DPTR,#043B1H
00AC E0                MOVX    A,@DPTR
00AD FF                MOV     R7,A
00AE EF                MOV     A,R7
00AF 54FE              ANL     A,#0FEH
00B1 FF                MOV     R7,A
00B2 EF                MOV     A,R7
00B3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 406
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 39  

00B4 905882            MOV     DPTR,#05882H
00B7 E0                MOVX    A,@DPTR
00B8 FF                MOV     R7,A
00B9 EF                MOV     A,R7
00BA 54F7              ANL     A,#0F7H
00BC FF                MOV     R7,A
00BD EF                MOV     A,R7
00BE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 408
00BF 9043A2            MOV     DPTR,#043A2H
00C2 E0                MOVX    A,@DPTR
00C3 FF                MOV     R7,A
00C4 EF                MOV     A,R7
00C5 54FD              ANL     A,#0FDH
00C7 FF                MOV     R7,A
00C8 EF                MOV     A,R7
00C9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 409
00CA 9043B2            MOV     DPTR,#043B2H
00CD E0                MOVX    A,@DPTR
00CE FF                MOV     R7,A
00CF EF                MOV     A,R7
00D0 54FD              ANL     A,#0FDH
00D2 FF                MOV     R7,A
00D3 EF                MOV     A,R7
00D4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 411
00D5 900000      R     MOV     DPTR,#enableInterrupts
00D8 E0                MOVX    A,@DPTR
00D9 FF                MOV     R7,A
00DA 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 412
00DD 22                RET     
             ; FUNCTION ADC_Stop (END)

             ; FUNCTION _ADC_SetBufferGain (BEGIN)
                                           ; SOURCE LINE # 429
0000 900000      R     MOV     DPTR,#gain
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 430
                                           ; SOURCE LINE # 432
0005 90589B            MOV     DPTR,#0589BH
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 54F3              ANL     A,#0F3H
000D FF                MOV     R7,A
000E 900000      R     MOV     DPTR,#tmpReg
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 433
0013 900000      R     MOV     DPTR,#tmpReg
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 900000      R     MOV     DPTR,#gain
001B E0                MOVX    A,@DPTR
001C FE                MOV     R6,A
001D EE                MOV     A,R6
001E 25E0              ADD     A,ACC
0020 25E0              ADD     A,ACC
0022 FE                MOV     R6,A
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 40  

0023 EE                MOV     A,R6
0024 540C              ANL     A,#0CH
0026 FE                MOV     R6,A
0027 EF                MOV     A,R7
0028 4E                ORL     A,R6
0029 FF                MOV     R7,A
002A 900000      R     MOV     DPTR,#tmpReg
002D EF                MOV     A,R7
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 434
002F 900000      R     MOV     DPTR,#tmpReg
0032 E0                MOVX    A,@DPTR
0033 FF                MOV     R7,A
0034 90589B            MOV     DPTR,#0589BH
0037 EF                MOV     A,R7
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 435
0039 22                RET     
             ; FUNCTION _ADC_SetBufferGain (END)

             ; FUNCTION _ADC_SetCoherency (BEGIN)
                                           ; SOURCE LINE # 465
0000 900000      R     MOV     DPTR,#coherency
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 466
                                           ; SOURCE LINE # 469
0005 904E14            MOV     DPTR,#04E14H
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 54FC              ANL     A,#0FCH
000D FF                MOV     R7,A
000E 900000      R     MOV     DPTR,#tmpReg
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 470
0013 900000      R     MOV     DPTR,#tmpReg
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 900000      R     MOV     DPTR,#coherency
001B E0                MOVX    A,@DPTR
001C FE                MOV     R6,A
001D EE                MOV     A,R6
001E 5403              ANL     A,#03H
0020 FE                MOV     R6,A
0021 EF                MOV     A,R7
0022 4E                ORL     A,R6
0023 FF                MOV     R7,A
0024 900000      R     MOV     DPTR,#tmpReg
0027 EF                MOV     A,R7
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 471
0029 900000      R     MOV     DPTR,#tmpReg
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E 904E14            MOV     DPTR,#04E14H
0031 EF                MOV     A,R7
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 472
0033 22                RET     
             ; FUNCTION _ADC_SetCoherency (END)
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 41  


             ; FUNCTION _ADC_SetGCOR (BEGIN)
                                           ; SOURCE LINE # 505
0000 900000      R     MOV     DPTR,#gainAdjust
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 506
                                           ; SOURCE LINE # 511
0006 900000      R     MOV     DPTR,#ADC_Config
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B EF                MOV     A,R7
000C 75F003            MOV     B,#03H
000F A4                MUL     AB
0010 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
0012 F582              MOV     DPL,A
0014 E4                CLR     A
0015 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
0017 F583              MOV     DPH,A
0019 E0                MOVX    A,@DPTR
001A FE                MOV     R6,A
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E 900000      R     MOV     DPTR,#tmpReg
0021 EE                MOV     A,R6
0022 F0                MOVX    @DPTR,A
0023 A3                INC     DPTR
0024 EF                MOV     A,R7
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 512
0026 900000      R     MOV     DPTR,#tmpReg
0029 E0                MOVX    A,@DPTR
002A FC                MOV     R4,A
002B A3                INC     DPTR
002C E0                MOVX    A,@DPTR
002D FD                MOV     R5,A
002E E4                CLR     A
002F 120000      E     LCALL   ?C?FCASTI
0032 7B00              MOV     R3,#00H
0034 7A00              MOV     R2,#00H
0036 7900              MOV     R1,#00H
0038 7847              MOV     R0,#047H
003A 120000      E     LCALL   ?C?FPDIV
003D 900000      R     MOV     DPTR,#tmpValue
0040 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 513
0043 900000      R     MOV     DPTR,#tmpValue
0046 120000      E     LCALL   ?C?LLDXDATA
0049 900000      R     MOV     DPTR,#gainAdjust
004C 120000      E     LCALL   ?C?LLDXDATA0
004F 120000      E     LCALL   ?C?FPMUL
0052 900000      R     MOV     DPTR,#tmpValue
0055 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 515
0058 7FB9              MOV     R7,#0B9H
005A 7EFC              MOV     R6,#0FCH
005C 7DFF              MOV     R5,#0FFH
005E 7C3F              MOV     R4,#03FH
0060 900000      R     MOV     DPTR,#tmpValue
0063 120000      E     LCALL   ?C?LLDXDATA0
0066 120000      E     LCALL   ?C?FPCMP3
0069 600A              JZ      ?C0010
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 42  

006B 4008              JC      ?C0010
                                           ; SOURCE LINE # 516
                                           ; SOURCE LINE # 517
006D 900000      R     MOV     DPTR,#status
0070 7401              MOV     A,#01H
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 518
0073 805E              SJMP    ?C0011
0075         ?C0010:
                                           ; SOURCE LINE # 520
                                           ; SOURCE LINE # 521
0075 900000      R     MOV     DPTR,#tmpValue
0078 120000      E     LCALL   ?C?LLDXDATA
007B 7B00              MOV     R3,#00H
007D 7A00              MOV     R2,#00H
007F 7900              MOV     R1,#00H
0081 7847              MOV     R0,#047H
0083 120000      E     LCALL   ?C?FPMUL
0086 900000      R     MOV     DPTR,#tmpValue
0089 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 522
008C 900000      R     MOV     DPTR,#tmpValue
008F 120000      E     LCALL   ?C?LLDXDATA
0092 120000      E     LCALL   ?C?CASTF
0095 900000      R     MOV     DPTR,#tmpReg
0098 EE                MOV     A,R6
0099 F0                MOVX    @DPTR,A
009A A3                INC     DPTR
009B EF                MOV     A,R7
009C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 523
009D 7B02              MOV     R3,#02H
009F 7A4E              MOV     R2,#04EH
00A1 790C              MOV     R1,#0CH
00A3 900000      R     MOV     DPTR,#tmpReg
00A6 E0                MOVX    A,@DPTR
00A7 FC                MOV     R4,A
00A8 A3                INC     DPTR
00A9 E0                MOVX    A,@DPTR
00AA FD                MOV     R5,A
00AB 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 525
00AE 900000      R     MOV     DPTR,#tmpReg
00B1 E0                MOVX    A,@DPTR
00B2 FE                MOV     R6,A
00B3 A3                INC     DPTR
00B4 E0                MOVX    A,@DPTR
00B5 FF                MOV     R7,A
00B6 900000      R     MOV     DPTR,#ADC_Config
00B9 E0                MOVX    A,@DPTR
00BA FD                MOV     R5,A
00BB ED                MOV     A,R5
00BC 75F003            MOV     B,#03H
00BF A4                MUL     AB
00C0 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
00C2 F582              MOV     DPL,A
00C4 E4                CLR     A
00C5 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
00C7 F583              MOV     DPH,A
00C9 EE                MOV     A,R6
00CA F0                MOVX    @DPTR,A
00CB A3                INC     DPTR
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 43  

00CC EF                MOV     A,R7
00CD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 527
00CE 900000      R     MOV     DPTR,#status
00D1 E4                CLR     A
00D2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 529
00D3         ?C0011:
                                           ; SOURCE LINE # 530
00D3 900000      R     MOV     DPTR,#status
00D6 E0                MOVX    A,@DPTR
00D7 FF                MOV     R7,A
                                           ; SOURCE LINE # 531
00D8         ?C0012:
00D8 22                RET     
             ; FUNCTION _ADC_SetGCOR (END)

             ; FUNCTION ADC_ReadGCOR (BEGIN)
                                           ; SOURCE LINE # 552
                                           ; SOURCE LINE # 553
                                           ; SOURCE LINE # 557
0000 904E0E            MOV     DPTR,#04E0EH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#gValue
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 558
000A 7B02              MOV     R3,#02H
000C 7A4E              MOV     R2,#04EH
000E 790C              MOV     R1,#0CH
0010 120000      E     LCALL   _cyread16_nodpx
0013 900000      R     MOV     DPTR,#gcorValue
0016 EE                MOV     A,R6
0017 F0                MOVX    @DPTR,A
0018 A3                INC     DPTR
0019 EF                MOV     A,R7
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 560
001B 900000      R     MOV     DPTR,#gValue
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
0020 EF                MOV     A,R7
0021 C3                CLR     C
0022 940F              SUBB    A,#0FH
0024 5028              JNC     ?C0013
                                           ; SOURCE LINE # 561
                                           ; SOURCE LINE # 562
0026 900000      R     MOV     DPTR,#gcorValue
0029 E0                MOVX    A,@DPTR
002A FE                MOV     R6,A
002B A3                INC     DPTR
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E 900000      R     MOV     DPTR,#gValue
0031 E0                MOVX    A,@DPTR
0032 FD                MOV     R5,A
0033 C3                CLR     C
0034 740F              MOV     A,#0FH
0036 9D                SUBB    A,R5
0037 FD                MOV     R5,A
0038 EF                MOV     A,R7
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 44  

0039 A805              MOV     R0,AR5
003B 08                INC     R0
003C 8005              SJMP    ?C0093
003E         ?C0092:
003E C3                CLR     C
003F 33                RLC     A
0040 CE                XCH     A,R6
0041 33                RLC     A
0042 CE                XCH     A,R6
0043         ?C0093:
0043 D8F9              DJNZ    R0,?C0092
0045 FF                MOV     R7,A
0046 900000      R     MOV     DPTR,#gcorValue
0049 EE                MOV     A,R6
004A F0                MOVX    @DPTR,A
004B A3                INC     DPTR
004C EF                MOV     A,R7
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 563
004E         ?C0013:
                                           ; SOURCE LINE # 565
004E 900000      R     MOV     DPTR,#gcorValue
0051 E0                MOVX    A,@DPTR
0052 FE                MOV     R6,A
0053 A3                INC     DPTR
0054 E0                MOVX    A,@DPTR
0055 FF                MOV     R7,A
                                           ; SOURCE LINE # 566
0056         ?C0014:
0056 22                RET     
             ; FUNCTION ADC_ReadGCOR (END)

             ; FUNCTION ADC_StartConvert (BEGIN)
                                           ; SOURCE LINE # 586
                                           ; SOURCE LINE # 587
                                           ; SOURCE LINE # 589
0000 904E00            MOV     DPTR,#04E00H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 4401              ORL     A,#01H
0008 FF                MOV     R7,A
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 590
000B 22                RET     
             ; FUNCTION ADC_StartConvert (END)

             ; FUNCTION ADC_StopConvert (BEGIN)
                                           ; SOURCE LINE # 609
                                           ; SOURCE LINE # 610
                                           ; SOURCE LINE # 612
0000 904E00            MOV     DPTR,#04E00H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 54FE              ANL     A,#0FEH
0008 FF                MOV     R7,A
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 613
000B 22                RET     
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 45  

             ; FUNCTION ADC_StopConvert (END)

             ; FUNCTION _ADC_IsEndConversion (BEGIN)
                                           ; SOURCE LINE # 644
0000 900000      R     MOV     DPTR,#retMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 645
0005         ?C0019:
                                           ; SOURCE LINE # 649
                                           ; SOURCE LINE # 653
0005 900000      R     MOV     DPTR,#ADC_stopConversion
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600C              JZ      ?C0020
                                           ; SOURCE LINE # 654
                                           ; SOURCE LINE # 655
000D 900000      R     MOV     DPTR,#ADC_convDone
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 900000      R     MOV     DPTR,#status
0015 EF                MOV     A,R7
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 656
0017 800E              SJMP    ?C0017
0019         ?C0020:
                                           ; SOURCE LINE # 658
                                           ; SOURCE LINE # 659
0019 904E01            MOV     DPTR,#04E01H
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E EF                MOV     A,R7
001F 5401              ANL     A,#01H
0021 FF                MOV     R7,A
0022 900000      R     MOV     DPTR,#status
0025 EF                MOV     A,R7
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 660
                                           ; SOURCE LINE # 661
0027         ?C0017:
0027 900000      R     MOV     DPTR,#status
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D 6401              XRL     A,#01H
002F 6008              JZ      ?C0018
0031 900000      R     MOV     DPTR,#retMode
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
0036 EF                MOV     A,R7
0037 60CC              JZ      ?C0019
0039         ?C0018:
                                           ; SOURCE LINE # 663
0039 900000      R     MOV     DPTR,#status
003C E0                MOVX    A,@DPTR
003D FF                MOV     R7,A
                                           ; SOURCE LINE # 664
003E         ?C0023:
003E 22                RET     
             ; FUNCTION _ADC_IsEndConversion (END)

C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 46  

             ; FUNCTION ADC_GetResult8 (BEGIN)
                                           ; SOURCE LINE # 691
                                           ; SOURCE LINE # 692
                                           ; SOURCE LINE # 697
0000 904E14            MOV     DPTR,#04E14H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 5403              ANL     A,#03H
0008 FF                MOV     R7,A
0009 900000      R     MOV     DPTR,#coherency
000C EF                MOV     A,R7
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 699
000E 904E10            MOV     DPTR,#04E10H
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 900000      R     MOV     DPTR,#result
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 701
0018 900000      R     MOV     DPTR,#coherency
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E B40207            CJNE    A,#02H,?C0024
                                           ; SOURCE LINE # 702
                                           ; SOURCE LINE # 703
0021 904E11            MOV     DPTR,#04E11H
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
                                           ; SOURCE LINE # 704
0026 800E              SJMP    ?C0025
0028         ?C0024:
                                           ; SOURCE LINE # 705
0028 900000      R     MOV     DPTR,#coherency
002B E0                MOVX    A,@DPTR
002C FF                MOV     R7,A
002D EF                MOV     A,R7
002E B40305            CJNE    A,#03H,?C0025
                                           ; SOURCE LINE # 706
                                           ; SOURCE LINE # 707
0031 904E12            MOV     DPTR,#04E12H
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
                                           ; SOURCE LINE # 708
                                           ; SOURCE LINE # 710
                                           ; SOURCE LINE # 711
0036         ?C0025:
                                           ; SOURCE LINE # 713
0036 900000      R     MOV     DPTR,#ADC_stopConversion
0039 E0                MOVX    A,@DPTR
003A FF                MOV     R7,A
003B EF                MOV     A,R7
003C 6005              JZ      ?C0028
                                           ; SOURCE LINE # 714
                                           ; SOURCE LINE # 715
003E 900000      R     MOV     DPTR,#ADC_convDone
0041 E4                CLR     A
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 716
0043         ?C0028:
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 47  

                                           ; SOURCE LINE # 717
0043 900000      R     MOV     DPTR,#result
0046 E0                MOVX    A,@DPTR
0047 FF                MOV     R7,A
                                           ; SOURCE LINE # 718
0048         ?C0029:
0048 22                RET     
             ; FUNCTION ADC_GetResult8 (END)

             ; FUNCTION ADC_GetResult16 (BEGIN)
                                           ; SOURCE LINE # 745
                                           ; SOURCE LINE # 746
                                           ; SOURCE LINE # 751
0000 904E14            MOV     DPTR,#04E14H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 5403              ANL     A,#03H
0008 FF                MOV     R7,A
0009 900000      R     MOV     DPTR,#coherency
000C EF                MOV     A,R7
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 753
000E 900000      R     MOV     DPTR,#coherency
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 EF                MOV     A,R7
0014 D3                SETB    C
0015 9401              SUBB    A,#01H
0017 5032              JNC     ?C0030
                                           ; SOURCE LINE # 754
                                           ; SOURCE LINE # 756
0019 904E11            MOV     DPTR,#04E11H
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E 7E00              MOV     R6,#00H
0020 900000      R     MOV     DPTR,#result
0023 EE                MOV     A,R6
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 EF                MOV     A,R7
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 757
0028 900000      R     MOV     DPTR,#result
002B E0                MOVX    A,@DPTR
002C FE                MOV     R6,A
002D A3                INC     DPTR
002E E0                MOVX    A,@DPTR
002F FF                MOV     R7,A
0030 EF                MOV     A,R7
0031 7F00              MOV     R7,#00H
0033 FE                MOV     R6,A
0034 904E10            MOV     DPTR,#04E10H
0037 E0                MOVX    A,@DPTR
0038 FD                MOV     R5,A
0039 7C00              MOV     R4,#00H
003B EE                MOV     A,R6
003C 4C                ORL     A,R4
003D FE                MOV     R6,A
003E EF                MOV     A,R7
003F 4D                ORL     A,R5
0040 FF                MOV     R7,A
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 48  

0041 900000      R     MOV     DPTR,#result
0044 EE                MOV     A,R6
0045 F0                MOVX    @DPTR,A
0046 A3                INC     DPTR
0047 EF                MOV     A,R7
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 761
0049 801F              SJMP    ?C0031
004B         ?C0030:
                                           ; SOURCE LINE # 763
                                           ; SOURCE LINE # 765
004B 7B02              MOV     R3,#02H
004D 7A4E              MOV     R2,#04EH
004F 7910              MOV     R1,#010H
0051 120000      E     LCALL   _cyread16_nodpx
0054 900000      R     MOV     DPTR,#result
0057 EE                MOV     A,R6
0058 F0                MOVX    @DPTR,A
0059 A3                INC     DPTR
005A EF                MOV     A,R7
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 770
005C 900000      R     MOV     DPTR,#coherency
005F E0                MOVX    A,@DPTR
0060 FF                MOV     R7,A
0061 EF                MOV     A,R7
0062 B40305            CJNE    A,#03H,?C0031
                                           ; SOURCE LINE # 771
                                           ; SOURCE LINE # 772
0065 904E12            MOV     DPTR,#04E12H
0068 E0                MOVX    A,@DPTR
0069 FF                MOV     R7,A
                                           ; SOURCE LINE # 773
                                           ; SOURCE LINE # 774
006A         ?C0031:
                                           ; SOURCE LINE # 776
006A 900000      R     MOV     DPTR,#ADC_stopConversion
006D E0                MOVX    A,@DPTR
006E FF                MOV     R7,A
006F EF                MOV     A,R7
0070 6005              JZ      ?C0033
                                           ; SOURCE LINE # 777
                                           ; SOURCE LINE # 778
0072 900000      R     MOV     DPTR,#ADC_convDone
0075 E4                CLR     A
0076 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 779
0077         ?C0033:
                                           ; SOURCE LINE # 781
0077 900000      R     MOV     DPTR,#result
007A E0                MOVX    A,@DPTR
007B FE                MOV     R6,A
007C A3                INC     DPTR
007D E0                MOVX    A,@DPTR
007E FF                MOV     R7,A
                                           ; SOURCE LINE # 782
007F         ?C0034:
007F 22                RET     
             ; FUNCTION ADC_GetResult16 (END)

             ; FUNCTION ADC_GetResult32 (BEGIN)
                                           ; SOURCE LINE # 805
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 49  

                                           ; SOURCE LINE # 806
                                           ; SOURCE LINE # 814
0000 904E14            MOV     DPTR,#04E14H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 5403              ANL     A,#03H
0008 FF                MOV     R7,A
0009 900000      R     MOV     DPTR,#coherency
000C EF                MOV     A,R7
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 816
000E 900000      R     MOV     DPTR,#coherency
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 EF                MOV     A,R7
0014 D3                SETB    C
0015 9401              SUBB    A,#01H
0017 4003              JC      $ + 5H
0019 020000      R     LJMP    ?C0035
                                           ; SOURCE LINE # 817
                                           ; SOURCE LINE # 819
001C 904E12            MOV     DPTR,#04E12H
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 E4                CLR     A
0022 FC                MOV     R4,A
0023 FD                MOV     R5,A
0024 FE                MOV     R6,A
0025 900000      R     MOV     DPTR,#result
0028 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 820
002B 900000      R     MOV     DPTR,#result
002E 120000      E     LCALL   ?C?LLDXDATA
0031 EF                MOV     A,R7
0032 5480              ANL     A,#080H
0034 FF                MOV     R7,A
0035 EE                MOV     A,R6
0036 5400              ANL     A,#00H
0038 FE                MOV     R6,A
0039 ED                MOV     A,R5
003A 5400              ANL     A,#00H
003C FD                MOV     R5,A
003D EC                MOV     A,R4
003E 5400              ANL     A,#00H
0040 FC                MOV     R4,A
0041 EF                MOV     A,R7
0042 4E                ORL     A,R6
0043 601C              JZ      ?C0036
                                           ; SOURCE LINE # 821
                                           ; SOURCE LINE # 822
0045 900000      R     MOV     DPTR,#result
0048 120000      E     LCALL   ?C?LLDXDATA
004B EF                MOV     A,R7
004C 4400              ORL     A,#00H
004E FF                MOV     R7,A
004F EE                MOV     A,R6
0050 44FF              ORL     A,#0FFH
0052 FE                MOV     R6,A
0053 ED                MOV     A,R5
0054 4400              ORL     A,#00H
0056 FD                MOV     R5,A
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 50  

0057 EC                MOV     A,R4
0058 4400              ORL     A,#00H
005A FC                MOV     R4,A
005B 900000      R     MOV     DPTR,#result
005E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 823
0061         ?C0036:
                                           ; SOURCE LINE # 824
0061 900000      R     MOV     DPTR,#result
0064 120000      E     LCALL   ?C?LLDXDATA
0067 7808              MOV     R0,#08H
0069 120000      E     LCALL   ?C?LSHL
006C A804              MOV     R0,AR4
006E A905              MOV     R1,AR5
0070 AA06              MOV     R2,AR6
0072 AB07              MOV     R3,AR7
0074 904E11            MOV     DPTR,#04E11H
0077 E0                MOVX    A,@DPTR
0078 FF                MOV     R7,A
0079 E4                CLR     A
007A FC                MOV     R4,A
007B FD                MOV     R5,A
007C FE                MOV     R6,A
007D 120000      E     LCALL   ?C?LOR
0080 900000      R     MOV     DPTR,#result
0083 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 825
0086 900000      R     MOV     DPTR,#result
0089 120000      E     LCALL   ?C?LLDXDATA
008C 7808              MOV     R0,#08H
008E 120000      E     LCALL   ?C?LSHL
0091 A804              MOV     R0,AR4
0093 A905              MOV     R1,AR5
0095 AA06              MOV     R2,AR6
0097 AB07              MOV     R3,AR7
0099 904E10            MOV     DPTR,#04E10H
009C E0                MOVX    A,@DPTR
009D FF                MOV     R7,A
009E E4                CLR     A
009F FC                MOV     R4,A
00A0 FD                MOV     R5,A
00A1 FE                MOV     R6,A
00A2 120000      E     LCALL   ?C?LOR
00A5 900000      R     MOV     DPTR,#result
00A8 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 830
00AB 020000      R     LJMP    ?C0037
00AE         ?C0035:
                                           ; SOURCE LINE # 831
00AE 900000      R     MOV     DPTR,#coherency
00B1 E0                MOVX    A,@DPTR
00B2 FF                MOV     R7,A
00B3 EF                MOV     A,R7
00B4 6402              XRL     A,#02H
00B6 6003              JZ      $ + 5H
00B8 020000      R     LJMP    ?C0038
                                           ; SOURCE LINE # 832
                                           ; SOURCE LINE # 834
00BB 904E12            MOV     DPTR,#04E12H
00BE E0                MOVX    A,@DPTR
00BF FF                MOV     R7,A
00C0 E4                CLR     A
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 51  

00C1 FC                MOV     R4,A
00C2 FD                MOV     R5,A
00C3 FE                MOV     R6,A
00C4 900000      R     MOV     DPTR,#result
00C7 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 835
00CA 900000      R     MOV     DPTR,#result
00CD 120000      E     LCALL   ?C?LLDXDATA
00D0 EF                MOV     A,R7
00D1 5480              ANL     A,#080H
00D3 FF                MOV     R7,A
00D4 EE                MOV     A,R6
00D5 5400              ANL     A,#00H
00D7 FE                MOV     R6,A
00D8 ED                MOV     A,R5
00D9 5400              ANL     A,#00H
00DB FD                MOV     R5,A
00DC EC                MOV     A,R4
00DD 5400              ANL     A,#00H
00DF FC                MOV     R4,A
00E0 EF                MOV     A,R7
00E1 4E                ORL     A,R6
00E2 601C              JZ      ?C0039
                                           ; SOURCE LINE # 836
                                           ; SOURCE LINE # 837
00E4 900000      R     MOV     DPTR,#result
00E7 120000      E     LCALL   ?C?LLDXDATA
00EA EF                MOV     A,R7
00EB 4400              ORL     A,#00H
00ED FF                MOV     R7,A
00EE EE                MOV     A,R6
00EF 44FF              ORL     A,#0FFH
00F1 FE                MOV     R6,A
00F2 ED                MOV     A,R5
00F3 4400              ORL     A,#00H
00F5 FD                MOV     R5,A
00F6 EC                MOV     A,R4
00F7 4400              ORL     A,#00H
00F9 FC                MOV     R4,A
00FA 900000      R     MOV     DPTR,#result
00FD 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 838
0100         ?C0039:
                                           ; SOURCE LINE # 839
0100 7B02              MOV     R3,#02H
0102 7A4E              MOV     R2,#04EH
0104 7910              MOV     R1,#010H
0106 120000      E     LCALL   _cyread16_nodpx
0109 E4                CLR     A
010A FC                MOV     R4,A
010B FD                MOV     R5,A
010C C004              PUSH    AR4
010E C005              PUSH    AR5
0110 C006              PUSH    AR6
0112 C007              PUSH    AR7
0114 900000      R     MOV     DPTR,#result
0117 120000      E     LCALL   ?C?LLDXDATA
011A 7810              MOV     R0,#010H
011C 120000      E     LCALL   ?C?LSHL
011F A804              MOV     R0,AR4
0121 A905              MOV     R1,AR5
0123 AA06              MOV     R2,AR6
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 52  

0125 AB07              MOV     R3,AR7
0127 D007              POP     AR7
0129 D006              POP     AR6
012B D005              POP     AR5
012D D004              POP     AR4
012F 120000      E     LCALL   ?C?LOR
0132 900000      R     MOV     DPTR,#result
0135 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 845
0138 8076              SJMP    ?C0037
013A         ?C0038:
                                           ; SOURCE LINE # 847
                                           ; SOURCE LINE # 850
013A 7B02              MOV     R3,#02H
013C 7A4E              MOV     R2,#04EH
013E 7910              MOV     R1,#010H
0140 120000      E     LCALL   _cyread16_nodpx
0143 E4                CLR     A
0144 FC                MOV     R4,A
0145 FD                MOV     R5,A
0146 900000      R     MOV     DPTR,#result
0149 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 851
014C 904E12            MOV     DPTR,#04E12H
014F E0                MOVX    A,@DPTR
0150 FF                MOV     R7,A
0151 7E00              MOV     R6,#00H
0153 900000      R     MOV     DPTR,#tmp
0156 EE                MOV     A,R6
0157 F0                MOVX    @DPTR,A
0158 A3                INC     DPTR
0159 EF                MOV     A,R7
015A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 852
015B 900000      R     MOV     DPTR,#tmp
015E E0                MOVX    A,@DPTR
015F FE                MOV     R6,A
0160 A3                INC     DPTR
0161 E0                MOVX    A,@DPTR
0162 FF                MOV     R7,A
0163 EF                MOV     A,R7
0164 30E712            JNB     ACC.7,?C0041
                                           ; SOURCE LINE # 853
                                           ; SOURCE LINE # 854
0167 900000      R     MOV     DPTR,#tmp
016A E0                MOVX    A,@DPTR
016B FE                MOV     R6,A
016C A3                INC     DPTR
016D E0                MOVX    A,@DPTR
016E FF                MOV     R7,A
016F 7EFF              MOV     R6,#0FFH
0171 900000      R     MOV     DPTR,#tmp
0174 EE                MOV     A,R6
0175 F0                MOVX    @DPTR,A
0176 A3                INC     DPTR
0177 EF                MOV     A,R7
0178 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 855
0179         ?C0041:
                                           ; SOURCE LINE # 856
0179 900000      R     MOV     DPTR,#result
017C 120000      E     LCALL   ?C?LLDXDATA
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 53  

017F C004              PUSH    AR4
0181 C005              PUSH    AR5
0183 C006              PUSH    AR6
0185 C007              PUSH    AR7
0187 900000      R     MOV     DPTR,#tmp
018A E0                MOVX    A,@DPTR
018B FE                MOV     R6,A
018C A3                INC     DPTR
018D E0                MOVX    A,@DPTR
018E FF                MOV     R7,A
018F E4                CLR     A
0190 FC                MOV     R4,A
0191 FD                MOV     R5,A
0192 7810              MOV     R0,#010H
0194 120000      E     LCALL   ?C?LSHL
0197 A804              MOV     R0,AR4
0199 A905              MOV     R1,AR5
019B AA06              MOV     R2,AR6
019D AB07              MOV     R3,AR7
019F D007              POP     AR7
01A1 D006              POP     AR6
01A3 D005              POP     AR5
01A5 D004              POP     AR4
01A7 120000      E     LCALL   ?C?LOR
01AA 900000      R     MOV     DPTR,#result
01AD 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 861
01B0         ?C0037:
                                           ; SOURCE LINE # 863
01B0 900000      R     MOV     DPTR,#ADC_stopConversion
01B3 E0                MOVX    A,@DPTR
01B4 FF                MOV     R7,A
01B5 EF                MOV     A,R7
01B6 6005              JZ      ?C0042
                                           ; SOURCE LINE # 864
                                           ; SOURCE LINE # 865
01B8 900000      R     MOV     DPTR,#ADC_convDone
01BB E4                CLR     A
01BC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 866
01BD         ?C0042:
                                           ; SOURCE LINE # 868
01BD 900000      R     MOV     DPTR,#result
01C0 120000      E     LCALL   ?C?LLDXDATA
                                           ; SOURCE LINE # 869
01C3         ?C0043:
01C3 22                RET     
             ; FUNCTION ADC_GetResult32 (END)

             ; FUNCTION _ADC_SetOffset (BEGIN)
                                           ; SOURCE LINE # 898
0000 900000      R     MOV     DPTR,#offset
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 899
                                           ; SOURCE LINE # 901
0006 900000      R     MOV     DPTR,#offset
0009 120000      E     LCALL   ?C?LLDXDATA
000C 900000      R     MOV     DPTR,#ADC_Offset
000F 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 902
0012 22                RET     
             ; FUNCTION _ADC_SetOffset (END)
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 54  


             ; FUNCTION _ADC_SetGain (BEGIN)
                                           ; SOURCE LINE # 933
0000 900000      R     MOV     DPTR,#adcGain
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 934
                                           ; SOURCE LINE # 935
0006 900000      R     MOV     DPTR,#adcGain
0009 120000      E     LCALL   ?C?LLDXDATA
000C 900000      R     MOV     DPTR,#ADC_CountsPerVolt
000F 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 936
0012 22                RET     
             ; FUNCTION _ADC_SetGain (END)

             ; FUNCTION _ADC_CountsTo_mVolts (BEGIN)
                                           ; SOURCE LINE # 960
0000 900000      R     MOV     DPTR,#adcCounts
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 961
                                           ; SOURCE LINE # 992
0006 900000      R     MOV     DPTR,#adcCounts
0009 120000      E     LCALL   ?C?LLDXDATA
000C 900000      R     MOV     DPTR,#ADC_Offset
000F 120000      E     LCALL   ?C?LLDXDATA0
0012 120000      E     LCALL   ?C?LSUB
0015 900000      R     MOV     DPTR,#adcCounts
0018 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 994
001B 7FE8              MOV     R7,#0E8H
001D 7E03              MOV     R6,#03H
001F 7D00              MOV     R5,#00H
0021 7C00              MOV     R4,#00H
0023 900000      R     MOV     DPTR,#adcCounts
0026 120000      E     LCALL   ?C?LLDXDATA0
0029 120000      E     LCALL   ?C?LMUL
002C 900000      R     MOV     DPTR,#ADC_CountsPerVolt
002F 120000      E     LCALL   ?C?LLDXDATA0
0032 120000      E     LCALL   ?C?SLDIV
0035 900000      R     MOV     DPTR,#mVolts
0038 EE                MOV     A,R6
0039 F0                MOVX    @DPTR,A
003A A3                INC     DPTR
003B EF                MOV     A,R7
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 996
003D 900000      R     MOV     DPTR,#mVolts
0040 E0                MOVX    A,@DPTR
0041 FE                MOV     R6,A
0042 A3                INC     DPTR
0043 E0                MOVX    A,@DPTR
0044 FF                MOV     R7,A
                                           ; SOURCE LINE # 997
0045         ?C0046:
0045 22                RET     
             ; FUNCTION _ADC_CountsTo_mVolts (END)

             ; FUNCTION _ADC_CountsTo_Volts (BEGIN)
                                           ; SOURCE LINE # 1021
0000 900000      R     MOV     DPTR,#adcCounts
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1022
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 55  

                                           ; SOURCE LINE # 1053
0006 900000      R     MOV     DPTR,#adcCounts
0009 120000      E     LCALL   ?C?LLDXDATA
000C 900000      R     MOV     DPTR,#ADC_Offset
000F 120000      E     LCALL   ?C?LLDXDATA0
0012 120000      E     LCALL   ?C?LSUB
0015 900000      R     MOV     DPTR,#adcCounts
0018 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1055
001B 900000      R     MOV     DPTR,#ADC_CountsPerVolt
001E 120000      E     LCALL   ?C?LLDXDATA
0021 EC                MOV     A,R4
0022 120000      E     LCALL   ?C?FCASTL
0025 C004              PUSH    AR4
0027 C005              PUSH    AR5
0029 C006              PUSH    AR6
002B C007              PUSH    AR7
002D 900000      R     MOV     DPTR,#adcCounts
0030 120000      E     LCALL   ?C?LLDXDATA
0033 EC                MOV     A,R4
0034 120000      E     LCALL   ?C?FCASTL
0037 D003              POP     AR3
0039 D002              POP     AR2
003B D001              POP     AR1
003D D000              POP     AR0
003F 120000      E     LCALL   ?C?FPDIV
0042 900000      R     MOV     DPTR,#Volts
0045 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1057
0048 900000      R     MOV     DPTR,#Volts
004B 120000      E     LCALL   ?C?LLDXDATA
                                           ; SOURCE LINE # 1058
004E         ?C0047:
004E 22                RET     
             ; FUNCTION _ADC_CountsTo_Volts (END)

             ; FUNCTION _ADC_CountsTo_uVolts (BEGIN)
                                           ; SOURCE LINE # 1087
0000 900000      R     MOV     DPTR,#adcCounts
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1088
                                           ; SOURCE LINE # 1097
0006 900000      R     MOV     DPTR,#ADC_Config
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B EF                MOV     A,R7
000C B40108            CJNE    A,#01H,?C0048
                                           ; SOURCE LINE # 1098
                                           ; SOURCE LINE # 1099
000F 900000      R     MOV     DPTR,#resolution
0012 740C              MOV     A,#0CH
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1103
0015 8028              SJMP    ?C0049
0017         ?C0048:
                                           ; SOURCE LINE # 1104
0017 900000      R     MOV     DPTR,#ADC_Config
001A E0                MOVX    A,@DPTR
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D B40208            CJNE    A,#02H,?C0050
                                           ; SOURCE LINE # 1105
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 56  

                                           ; SOURCE LINE # 1106
0020 900000      R     MOV     DPTR,#resolution
0023 7410              MOV     A,#010H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1110
0026 8017              SJMP    ?C0049
0028         ?C0050:
                                           ; SOURCE LINE # 1111
0028 900000      R     MOV     DPTR,#ADC_Config
002B E0                MOVX    A,@DPTR
002C FF                MOV     R7,A
002D EF                MOV     A,R7
002E B40308            CJNE    A,#03H,?C0052
                                           ; SOURCE LINE # 1112
                                           ; SOURCE LINE # 1113
0031 900000      R     MOV     DPTR,#resolution
0034 7410              MOV     A,#010H
0036 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1117
0037 8006              SJMP    ?C0049
0039         ?C0052:
                                           ; SOURCE LINE # 1119
                                           ; SOURCE LINE # 1120
0039 900000      R     MOV     DPTR,#resolution
003C 7410              MOV     A,#010H
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1124
003F         ?C0049:
                                           ; SOURCE LINE # 1126
003F 900000      R     MOV     DPTR,#resolution
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 EF                MOV     A,R7
0045 120000      E     LCALL   ?C?CCASE
0048 0000        R     DW      ?C0055
004A 0C                DB      0CH
004B 0000        R     DW      ?C0056
004D 10                DB      010H
004E 0000              DW      00H
0050 0000        R     DW      ?C0057
                                           ; SOURCE LINE # 1127
                                           ; SOURCE LINE # 1132
0052         ?C0055:
                                           ; SOURCE LINE # 1133
0052 7F20              MOV     R7,#020H
0054 7EA1              MOV     R6,#0A1H
0056 7D07              MOV     R5,#07H
0058 7C00              MOV     R4,#00H
005A 900000      R     MOV     DPTR,#coefA
005D 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1134
0060 7F02              MOV     R7,#02H
0062 7E00              MOV     R6,#00H
0064 7D00              MOV     R5,#00H
0066 7C00              MOV     R4,#00H
0068 900000      R     MOV     DPTR,#coefB
006B 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1135
006E 803A              SJMP    ?C0054
                                           ; SOURCE LINE # 1168
0070         ?C0056:
                                           ; SOURCE LINE # 1169
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 57  

0070 7F12              MOV     R7,#012H
0072 7E7A              MOV     R6,#07AH
0074 7D00              MOV     R5,#00H
0076 7C00              MOV     R4,#00H
0078 900000      R     MOV     DPTR,#coefA
007B 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1170
007E 7F20              MOV     R7,#020H
0080 7E00              MOV     R6,#00H
0082 7D00              MOV     R5,#00H
0084 7C00              MOV     R4,#00H
0086 900000      R     MOV     DPTR,#coefB
0089 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1171
008C 801C              SJMP    ?C0054
                                           ; SOURCE LINE # 1209
008E         ?C0057:
                                           ; SOURCE LINE # 1211
008E 7F40              MOV     R7,#040H
0090 7E42              MOV     R6,#042H
0092 7D0F              MOV     R5,#0FH
0094 7C00              MOV     R4,#00H
0096 900000      R     MOV     DPTR,#coefA
0099 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1212
009C 7F01              MOV     R7,#01H
009E 7E00              MOV     R6,#00H
00A0 7D00              MOV     R5,#00H
00A2 7C00              MOV     R4,#00H
00A4 900000      R     MOV     DPTR,#coefB
00A7 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1213
                                           ; SOURCE LINE # 1214
00AA         ?C0054:
                                           ; SOURCE LINE # 1215
00AA 900000      R     MOV     DPTR,#coefB
00AD 120000      E     LCALL   ?C?LLDXDATA0
00B0 900000      R     MOV     DPTR,#ADC_CountsPerVolt
00B3 120000      E     LCALL   ?C?LLDXDATA
00B6 120000      E     LCALL   ?C?SLDIV
00B9 900000      R     MOV     DPTR,#coefB
00BC 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1216
00BF 900000      R     MOV     DPTR,#ADC_Offset
00C2 120000      E     LCALL   ?C?LLDXDATA
00C5 900000      R     MOV     DPTR,#coefA
00C8 120000      E     LCALL   ?C?LLDXDATA0
00CB 120000      E     LCALL   ?C?LMUL
00CE 900000      R     MOV     DPTR,#coefB
00D1 120000      E     LCALL   ?C?LLDXDATA0
00D4 120000      E     LCALL   ?C?SLDIV
00D7 C004              PUSH    AR4
00D9 C005              PUSH    AR5
00DB C006              PUSH    AR6
00DD C007              PUSH    AR7
00DF 900000      R     MOV     DPTR,#adcCounts
00E2 120000      E     LCALL   ?C?LLDXDATA
00E5 900000      R     MOV     DPTR,#coefA
00E8 120000      E     LCALL   ?C?LLDXDATA0
00EB 120000      E     LCALL   ?C?LMUL
00EE 900000      R     MOV     DPTR,#coefB
00F1 120000      E     LCALL   ?C?LLDXDATA0
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 58  

00F4 120000      E     LCALL   ?C?SLDIV
00F7 D003              POP     AR3
00F9 D002              POP     AR2
00FB D001              POP     AR1
00FD D000              POP     AR0
00FF 120000      E     LCALL   ?C?LSUB
0102 900000      R     MOV     DPTR,#uVolts
0105 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1218
0108 900000      R     MOV     DPTR,#uVolts
010B 120000      E     LCALL   ?C?LLDXDATA
                                           ; SOURCE LINE # 1219
010E         ?C0058:
010E 22                RET     
             ; FUNCTION _ADC_CountsTo_uVolts (END)

             ; FUNCTION _ADC_InitConfig (BEGIN)
                                           ; SOURCE LINE # 1242
0000 900000      R     MOV     DPTR,#config
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1243
                                           ; SOURCE LINE # 1244
0005 900000      R     MOV     DPTR,#ADC_stopConversion
0008 E4                CLR     A
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1246
000A 900000      R     MOV     DPTR,#config
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 6401              XRL     A,#01H
0012 6003              JZ      $ + 5H
0014 020000      R     LJMP    ?C0060
                                           ; SOURCE LINE # 1247
                                           ; SOURCE LINE # 1249
0017 904E00            MOV     DPTR,#04E00H
001A 7432              MOV     A,#032H
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1250
001D 904E02            MOV     DPTR,#04E02H
0020 7406              MOV     A,#06H
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1251
0023 904E03            MOV     DPTR,#04E03H
0026 7408              MOV     A,#08H
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1252
0029 904E04            MOV     DPTR,#04E04H
002C E4                CLR     A
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1253
002E 904E05            MOV     DPTR,#04E05H
0031 E4                CLR     A
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1254
0033 904E06            MOV     DPTR,#04E06H
0036 741F              MOV     A,#01FH
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1255
0039 904E08            MOV     DPTR,#04E08H
003C E4                CLR     A
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 59  

003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1256
003E 904E09            MOV     DPTR,#04E09H
0041 E4                CLR     A
0042 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1257
0043 904E0A            MOV     DPTR,#04E0AH
0046 E4                CLR     A
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1258
0048 904E14            MOV     DPTR,#04E14H
004B 7401              MOV     A,#01H
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1260
004E 905884            MOV     DPTR,#05884H
0051 7414              MOV     A,#014H
0053 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1261
0054 905885            MOV     DPTR,#05885H
0057 7405              MOV     A,#05H
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1262
005A 905886            MOV     DPTR,#05886H
005D 7416              MOV     A,#016H
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1263
0060 905887            MOV     DPTR,#05887H
0063 E4                CLR     A
0064 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1264
0065 90588A            MOV     DPTR,#0588AH
0068 7444              MOV     A,#044H
006A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1265
006B 90588B            MOV     DPTR,#0588BH
006E 7448              MOV     A,#048H
0070 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1266
0071 90588C            MOV     DPTR,#0588CH
0074 7401              MOV     A,#01H
0076 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1267
0077 90588E            MOV     DPTR,#0588EH
007A 7402              MOV     A,#02H
007C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1268
007D 90588F            MOV     DPTR,#0588FH
0080 7422              MOV     A,#022H
0082 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1269
0083 905890            MOV     DPTR,#05890H
0086 7428              MOV     A,#028H
0088 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1270
0089 905891            MOV     DPTR,#05891H
008C 74EB              MOV     A,#0EBH
008E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1272
008F 7F52              MOV     R7,#052H
0091 120000      R     LCALL   _ADC_SetDSMRef0Reg
                                           ; SOURCE LINE # 1273
0094 905894            MOV     DPTR,#05894H
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 60  

0097 7458              MOV     A,#058H
0099 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1274
009A 905895            MOV     DPTR,#05895H
009D E4                CLR     A
009E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1276
009F 90589A            MOV     DPTR,#0589AH
00A2 7401              MOV     A,#01H
00A4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1277
00A5 90589B            MOV     DPTR,#0589BH
00A8 7401              MOV     A,#01H
00AA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1278
00AB 90589C            MOV     DPTR,#0589CH
00AE E4                CLR     A
00AF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1279
00B0 90589D            MOV     DPTR,#0589DH
00B3 740A              MOV     A,#0AH
00B5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1288
00B6 7F00              MOV     R7,#00H
00B8 120000      E     LCALL   _ADC_AMux_Select
                                           ; SOURCE LINE # 1300
00BB 7F33              MOV     R7,#033H
00BD 7E03              MOV     R6,#03H
00BF 7D00              MOV     R5,#00H
00C1 7C00              MOV     R4,#00H
00C3 900000      R     MOV     DPTR,#ADC_CountsPerVolt
00C6 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1302
00C9 7D01              MOV     R5,#01H
00CB 7F04              MOV     R7,#04H
00CD 7E00              MOV     R6,#00H
00CF 120000      E     LCALL   _ADC_Ext_CP_Clk_SetDividerRegister
                                           ; SOURCE LINE # 1306
00D2 7D01              MOV     R5,#01H
00D4 7F15              MOV     R7,#015H
00D6 7E00              MOV     R6,#00H
00D8 120000      E     LCALL   _ADC_theACLK_SetDividerRegister
                                           ; SOURCE LINE # 1311
00DB 7C00        E     MOV     R4,#HIGH ADC_ISR1
00DD 7D00        E     MOV     R5,#LOW ADC_ISR1
00DF 7F1D              MOV     R7,#01DH
00E1 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 1313
                                           ; SOURCE LINE # 1526
00E4         ?C0060:
00E4 22                RET     
             ; FUNCTION _ADC_InitConfig (END)

             ; FUNCTION _ADC_SelectConfiguration (BEGIN)
                                           ; SOURCE LINE # 1552
0000 900000      R     MOV     DPTR,#config
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#restart
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1554
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 61  

                                           ; SOURCE LINE # 1556
000A 900000      R     MOV     DPTR,#config
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 D3                SETB    C
0011 9400              SUBB    A,#00H
0013 4079              JC      ?C0061
0015 900000      R     MOV     DPTR,#config
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A EF                MOV     A,R7
001B D3                SETB    C
001C 9401              SUBB    A,#01H
001E 506E              JNC     ?C0061
                                           ; SOURCE LINE # 1557
                                           ; SOURCE LINE # 1561
0020 900000      R     MOV     DPTR,#ADC_initVar
0023 E0                MOVX    A,@DPTR
0024 FF                MOV     R7,A
0025 EF                MOV     A,R7
0026 7006              JNZ     ?C0062
                                           ; SOURCE LINE # 1562
                                           ; SOURCE LINE # 1563
0028 900000      R     MOV     DPTR,#ADC_started
002B 7401              MOV     A,#01H
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1564
002E         ?C0062:
                                           ; SOURCE LINE # 1567
002E 900000      R     MOV     DPTR,#config
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
0033 900000      R     MOV     DPTR,#ADC_Config
0036 EF                MOV     A,R7
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1570
0038 120000      R     LCALL   ADC_Stop
                                           ; SOURCE LINE # 1573
003B 900000      R     MOV     DPTR,#config
003E E0                MOVX    A,@DPTR
003F FF                MOV     R7,A
0040 120000      R     LCALL   _ADC_InitConfig
                                           ; SOURCE LINE # 1576
0043 900000      R     MOV     DPTR,#config
0046 E0                MOVX    A,@DPTR
0047 FF                MOV     R7,A
0048 EF                MOV     A,R7
0049 75F003            MOV     B,#03H
004C A4                MUL     AB
004D 2400        R     ADD     A,#LOW ADC_gcor+0FFFFH
004F F582              MOV     DPL,A
0051 E4                CLR     A
0052 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFFH
0054 F583              MOV     DPH,A
0056 E0                MOVX    A,@DPTR
0057 FF                MOV     R7,A
0058 904E0E            MOV     DPTR,#04E0EH
005B EF                MOV     A,R7
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1577
005D 900000      R     MOV     DPTR,#config
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 62  

0060 E0                MOVX    A,@DPTR
0061 FF                MOV     R7,A
0062 EF                MOV     A,R7
0063 75F003            MOV     B,#03H
0066 A4                MUL     AB
0067 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
0069 F582              MOV     DPL,A
006B E4                CLR     A
006C 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
006E F583              MOV     DPH,A
0070 E0                MOVX    A,@DPTR
0071 FC                MOV     R4,A
0072 A3                INC     DPTR
0073 E0                MOVX    A,@DPTR
0074 FD                MOV     R5,A
0075 7B02              MOV     R3,#02H
0077 7A4E              MOV     R2,#04EH
0079 790C              MOV     R1,#0CH
007B 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 1579
007E 900000      R     MOV     DPTR,#restart
0081 E0                MOVX    A,@DPTR
0082 FF                MOV     R7,A
0083 EF                MOV     A,R7
0084 B4010C            CJNE    A,#01H,?C0066
                                           ; SOURCE LINE # 1580
                                           ; SOURCE LINE # 1582
0087 120000      R     LCALL   ADC_Start
                                           ; SOURCE LINE # 1585
008A 120000      R     LCALL   ADC_StartConvert
                                           ; SOURCE LINE # 1586
                                           ; SOURCE LINE # 1587
008D 22                RET     
008E         ?C0061:
                                           ; SOURCE LINE # 1589
                                           ; SOURCE LINE # 1591
008E 7F00              MOV     R7,#00H
0090 120000      E     LCALL   _?CyHalt
                                           ; SOURCE LINE # 1592
                                           ; SOURCE LINE # 1593
0093         ?C0066:
0093 22                RET     
             ; FUNCTION _ADC_SelectConfiguration (END)

             ; FUNCTION _ADC_GainCompensation (BEGIN)
                                           ; SOURCE LINE # 1617
0000 900000      R     MOV     DPTR,#inputRange
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#idealDecGain
0008 EC                MOV     A,R4
0009 F0                MOVX    @DPTR,A
000A A3                INC     DPTR
000B ED                MOV     A,R5
000C F0                MOVX    @DPTR,A
000D 900000      R     MOV     DPTR,#idealOddDecGain
0010 EA                MOV     A,R2
0011 F0                MOVX    @DPTR,A
0012 A3                INC     DPTR
0013 EB                MOV     A,R3
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1619
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 63  

                                           ; SOURCE LINE # 1625
0015 900000      R     MOV     DPTR,#config
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A EF                MOV     A,R7
001B D3                SETB    C
001C 9400              SUBB    A,#00H
001E 5003              JNC     $ + 5H
0020 020000      R     LJMP    ?C0067
0023 900000      R     MOV     DPTR,#config
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 EF                MOV     A,R7
0029 D3                SETB    C
002A 9401              SUBB    A,#01H
002C 4003              JC      $ + 5H
002E 020000      R     LJMP    ?C0067
                                           ; SOURCE LINE # 1626
                                           ; SOURCE LINE # 1627
0031 900000      R     MOV     DPTR,#inputRange
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
0036 EF                MOV     A,R7
0037 120000      E     LCALL   ?C?CCASE
003A 0000        R     DW      ?C0070
003C 01                DB      01H
003D 0000        R     DW      ?C0070
003F 04                DB      04H
0040 0000        R     DW      ?C0073
0042 07                DB      07H
0043 0000        R     DW      ?C0076
0045 08                DB      08H
0046 0000        R     DW      ?C0079
0048 0A                DB      0AH
0049 0000              DW      00H
004B 0000        R     DW      ?C0082
                                           ; SOURCE LINE # 1628
                                           ; SOURCE LINE # 1629
                                           ; SOURCE LINE # 1630
004D         ?C0070:
                                           ; SOURCE LINE # 1632
004D 900000      R     MOV     DPTR,#resolution
0050 E0                MOVX    A,@DPTR
0051 FF                MOV     R7,A
0052 EF                MOV     A,R7
0053 D3                SETB    C
0054 940F              SUBB    A,#0FH
0056 4011              JC      ?C0071
                                           ; SOURCE LINE # 1633
                                           ; SOURCE LINE # 1634
0058 7B0C              MOV     R3,#0CH
005A 7A01              MOV     R2,#01H
005C 7918              MOV     R1,#018H
005E 120000      E     LCALL   _cyread8
0061 900000      R     MOV     DPTR,#flash
0064 EF                MOV     A,R7
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1635
0066 020000      R     LJMP    ?C0068
0069         ?C0071:
                                           ; SOURCE LINE # 1637
                                           ; SOURCE LINE # 1638
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 64  

0069 7B0C              MOV     R3,#0CH
006B 7A01              MOV     R2,#01H
006D 791C              MOV     R1,#01CH
006F 120000      E     LCALL   _cyread8
0072 900000      R     MOV     DPTR,#flash
0075 EF                MOV     A,R7
0076 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1639
                                           ; SOURCE LINE # 1640
0077 020000      R     LJMP    ?C0068
                                           ; SOURCE LINE # 1642
007A         ?C0073:
                                           ; SOURCE LINE # 1644
007A 900000      R     MOV     DPTR,#resolution
007D E0                MOVX    A,@DPTR
007E FF                MOV     R7,A
007F EF                MOV     A,R7
0080 D3                SETB    C
0081 940F              SUBB    A,#0FH
0083 4010              JC      ?C0074
                                           ; SOURCE LINE # 1645
                                           ; SOURCE LINE # 1646
0085 7B0C              MOV     R3,#0CH
0087 7A01              MOV     R2,#01H
0089 7919              MOV     R1,#019H
008B 120000      E     LCALL   _cyread8
008E 900000      R     MOV     DPTR,#flash
0091 EF                MOV     A,R7
0092 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1647
0093 806B              SJMP    ?C0068
0095         ?C0074:
                                           ; SOURCE LINE # 1649
                                           ; SOURCE LINE # 1650
0095 7B0C              MOV     R3,#0CH
0097 7A01              MOV     R2,#01H
0099 791D              MOV     R1,#01DH
009B 120000      E     LCALL   _cyread8
009E 900000      R     MOV     DPTR,#flash
00A1 EF                MOV     A,R7
00A2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1651
                                           ; SOURCE LINE # 1652
00A3 805B              SJMP    ?C0068
                                           ; SOURCE LINE # 1654
00A5         ?C0076:
                                           ; SOURCE LINE # 1656
00A5 900000      R     MOV     DPTR,#resolution
00A8 E0                MOVX    A,@DPTR
00A9 FF                MOV     R7,A
00AA EF                MOV     A,R7
00AB D3                SETB    C
00AC 940F              SUBB    A,#0FH
00AE 4010              JC      ?C0077
                                           ; SOURCE LINE # 1657
                                           ; SOURCE LINE # 1658
00B0 7B0C              MOV     R3,#0CH
00B2 7A01              MOV     R2,#01H
00B4 791A              MOV     R1,#01AH
00B6 120000      E     LCALL   _cyread8
00B9 900000      R     MOV     DPTR,#flash
00BC EF                MOV     A,R7
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 65  

00BD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1659
00BE 8040              SJMP    ?C0068
00C0         ?C0077:
                                           ; SOURCE LINE # 1661
                                           ; SOURCE LINE # 1662
00C0 7B0C              MOV     R3,#0CH
00C2 7A01              MOV     R2,#01H
00C4 791E              MOV     R1,#01EH
00C6 120000      E     LCALL   _cyread8
00C9 900000      R     MOV     DPTR,#flash
00CC EF                MOV     A,R7
00CD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1663
                                           ; SOURCE LINE # 1664
00CE 8030              SJMP    ?C0068
                                           ; SOURCE LINE # 1666
00D0         ?C0079:
                                           ; SOURCE LINE # 1668
00D0 900000      R     MOV     DPTR,#resolution
00D3 E0                MOVX    A,@DPTR
00D4 FF                MOV     R7,A
00D5 EF                MOV     A,R7
00D6 D3                SETB    C
00D7 940F              SUBB    A,#0FH
00D9 4010              JC      ?C0080
                                           ; SOURCE LINE # 1669
                                           ; SOURCE LINE # 1670
00DB 7B0C              MOV     R3,#0CH
00DD 7A01              MOV     R2,#01H
00DF 791B              MOV     R1,#01BH
00E1 120000      E     LCALL   _cyread8
00E4 900000      R     MOV     DPTR,#flash
00E7 EF                MOV     A,R7
00E8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1671
00E9 8015              SJMP    ?C0068
00EB         ?C0080:
                                           ; SOURCE LINE # 1673
                                           ; SOURCE LINE # 1674
00EB 7B0C              MOV     R3,#0CH
00ED 7A01              MOV     R2,#01H
00EF 791F              MOV     R1,#01FH
00F1 120000      E     LCALL   _cyread8
00F4 900000      R     MOV     DPTR,#flash
00F7 EF                MOV     A,R7
00F8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1675
                                           ; SOURCE LINE # 1676
00F9 8005              SJMP    ?C0068
                                           ; SOURCE LINE # 1678
00FB         ?C0082:
                                           ; SOURCE LINE # 1679
00FB 900000      R     MOV     DPTR,#flash
00FE E4                CLR     A
00FF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1680
                                           ; SOURCE LINE # 1681
0100         ?C0068:
                                           ; SOURCE LINE # 1684
0100 900000      R     MOV     DPTR,#flash
0103 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 66  

0104 FF                MOV     R7,A
0105 EF                MOV     A,R7
0106 33                RLC     A
0107 95E0              SUBB    A,ACC
0109 FE                MOV     R6,A
010A FD                MOV     R5,A
010B FC                MOV     R4,A
010C 7B20              MOV     R3,#020H
010E 7A00              MOV     R2,#00H
0110 7900              MOV     R1,#00H
0112 7800              MOV     R0,#00H
0114 120000      E     LCALL   ?C?LMUL
0117 A804              MOV     R0,AR4
0119 A905              MOV     R1,AR5
011B AA06              MOV     R2,AR6
011D AB07              MOV     R3,AR7
011F 900000      R     MOV     DPTR,#idealDecGain
0122 E0                MOVX    A,@DPTR
0123 FE                MOV     R6,A
0124 A3                INC     DPTR
0125 E0                MOVX    A,@DPTR
0126 FF                MOV     R7,A
0127 E4                CLR     A
0128 FC                MOV     R4,A
0129 FD                MOV     R5,A
012A 120000      E     LCALL   ?C?LADD
012D 900000      R     MOV     DPTR,#normalised
0130 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1685
0133 900000      R     MOV     DPTR,#normalised
0136 120000      E     LCALL   ?C?LLDXDATA
0139 AB07              MOV     R3,AR7
013B AA06              MOV     R2,AR6
013D A905              MOV     R1,AR5
013F A804              MOV     R0,AR4
0141 A804              MOV     R0,AR4
0143 A905              MOV     R1,AR5
0145 AA06              MOV     R2,AR6
0147 AB07              MOV     R3,AR7
0149 900000      R     MOV     DPTR,#idealOddDecGain
014C E0                MOVX    A,@DPTR
014D FE                MOV     R6,A
014E A3                INC     DPTR
014F E0                MOVX    A,@DPTR
0150 FF                MOV     R7,A
0151 E4                CLR     A
0152 FC                MOV     R4,A
0153 FD                MOV     R5,A
0154 120000      E     LCALL   ?C?LMUL
0157 900000      R     MOV     DPTR,#gcorTmp
015A 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1686
015D 7B00              MOV     R3,#00H
015F 7A80              MOV     R2,#080H
0161 7900              MOV     R1,#00H
0163 7800              MOV     R0,#00H
0165 900000      R     MOV     DPTR,#gcorTmp
0168 120000      E     LCALL   ?C?LLDXDATA
016B 120000      E     LCALL   ?C?ULDIV
016E 900000      R     MOV     DPTR,#gcorValue
0171 EE                MOV     A,R6
0172 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 67  

0173 A3                INC     DPTR
0174 EF                MOV     A,R7
0175 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1688
0176 900000      R     MOV     DPTR,#resolution
0179 E0                MOVX    A,@DPTR
017A FF                MOV     R7,A
017B EF                MOV     A,R7
017C C3                CLR     C
017D 940E              SUBB    A,#0EH
017F 5047              JNC     ?C0083
                                           ; SOURCE LINE # 1689
                                           ; SOURCE LINE # 1690
0181 900000      R     MOV     DPTR,#gcorValue
0184 E0                MOVX    A,@DPTR
0185 FE                MOV     R6,A
0186 A3                INC     DPTR
0187 E0                MOVX    A,@DPTR
0188 FF                MOV     R7,A
0189 900000      R     MOV     DPTR,#resolution
018C E0                MOVX    A,@DPTR
018D FD                MOV     R5,A
018E C3                CLR     C
018F 740E              MOV     A,#0EH
0191 9D                SUBB    A,R5
0192 FD                MOV     R5,A
0193 EF                MOV     A,R7
0194 A805              MOV     R0,AR5
0196 08                INC     R0
0197 8005              SJMP    ?C0095
0199         ?C0094:
0199 CE                XCH     A,R6
019A C3                CLR     C
019B 13                RRC     A
019C CE                XCH     A,R6
019D 13                RRC     A
019E         ?C0095:
019E D8F9              DJNZ    R0,?C0094
01A0 FF                MOV     R7,A
01A1 900000      R     MOV     DPTR,#gcorValue
01A4 EE                MOV     A,R6
01A5 F0                MOVX    @DPTR,A
01A6 A3                INC     DPTR
01A7 EF                MOV     A,R7
01A8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1691
01A9 900000      R     MOV     DPTR,#resolution
01AC E0                MOVX    A,@DPTR
01AD FF                MOV     R7,A
01AE EF                MOV     A,R7
01AF 04                INC     A
01B0 FF                MOV     R7,A
01B1 900000      R     MOV     DPTR,#config
01B4 E0                MOVX    A,@DPTR
01B5 FE                MOV     R6,A
01B6 EE                MOV     A,R6
01B7 75F003            MOV     B,#03H
01BA A4                MUL     AB
01BB 2400        R     ADD     A,#LOW ADC_gcor+0FFFFH
01BD F582              MOV     DPL,A
01BF E4                CLR     A
01C0 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFFH
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 68  

01C2 F583              MOV     DPH,A
01C4 EF                MOV     A,R7
01C5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1692
01C6 8016              SJMP    ?C0084
01C8         ?C0083:
                                           ; SOURCE LINE # 1694
                                           ; SOURCE LINE # 1696
01C8 900000      R     MOV     DPTR,#config
01CB E0                MOVX    A,@DPTR
01CC FF                MOV     R7,A
01CD EF                MOV     A,R7
01CE 75F003            MOV     B,#03H
01D1 A4                MUL     AB
01D2 2400        R     ADD     A,#LOW ADC_gcor+0FFFFH
01D4 F582              MOV     DPL,A
01D6 E4                CLR     A
01D7 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFFH
01D9 F583              MOV     DPH,A
01DB 740F              MOV     A,#0FH
01DD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1697
01DE         ?C0084:
                                           ; SOURCE LINE # 1700
01DE 900000      R     MOV     DPTR,#gcorValue
01E1 E0                MOVX    A,@DPTR
01E2 FE                MOV     R6,A
01E3 A3                INC     DPTR
01E4 E0                MOVX    A,@DPTR
01E5 FF                MOV     R7,A
01E6 900000      R     MOV     DPTR,#config
01E9 E0                MOVX    A,@DPTR
01EA FD                MOV     R5,A
01EB ED                MOV     A,R5
01EC 75F003            MOV     B,#03H
01EF A4                MUL     AB
01F0 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
01F2 F582              MOV     DPL,A
01F4 E4                CLR     A
01F5 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
01F7 F583              MOV     DPH,A
01F9 EE                MOV     A,R6
01FA F0                MOVX    @DPTR,A
01FB A3                INC     DPTR
01FC EF                MOV     A,R7
01FD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1701
01FE 22                RET     
01FF         ?C0067:
                                           ; SOURCE LINE # 1703
                                           ; SOURCE LINE # 1705
01FF 7F00              MOV     R7,#00H
0201 120000      E     LCALL   _?CyHalt
                                           ; SOURCE LINE # 1706
                                           ; SOURCE LINE # 1707
0204         ?C0087:
0204 22                RET     
             ; FUNCTION _ADC_GainCompensation (END)

             ; FUNCTION _ADC_SetDSMRef0Reg (BEGIN)
                                           ; SOURCE LINE # 1724
0000 900000      R     MOV     DPTR,#value
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 69  

0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1725
                                           ; SOURCE LINE # 1727
0005 120000      E     LCALL   CyEnterCriticalSection
0008 900000      R     MOV     DPTR,#enableInterrupts
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1730
000D 9046F8            MOV     DPTR,#046F8H
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 EF                MOV     A,R7
0013 4403              ORL     A,#03H
0015 FF                MOV     R7,A
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1731
0018 9046F9            MOV     DPTR,#046F9H
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 4403              ORL     A,#03H
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1732
0023 900000      R     MOV     DPTR,#value
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 905892            MOV     DPTR,#05892H
002B EF                MOV     A,R7
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1735
002D 7F03              MOV     R7,#03H
002F 7E00              MOV     R6,#00H
0031 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1737
0034 9046F8            MOV     DPTR,#046F8H
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 EF                MOV     A,R7
003A 54FC              ANL     A,#0FCH
003C FF                MOV     R7,A
003D EF                MOV     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1738
003F 9046F9            MOV     DPTR,#046F9H
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 EF                MOV     A,R7
0045 54FC              ANL     A,#0FCH
0047 FF                MOV     R7,A
0048 EF                MOV     A,R7
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1740
004A 900000      R     MOV     DPTR,#enableInterrupts
004D E0                MOVX    A,@DPTR
004E FF                MOV     R7,A
004F 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1741
0052 22                RET     
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 70  

             ; FUNCTION _ADC_SetDSMRef0Reg (END)

             ; FUNCTION ADC_Read8 (BEGIN)
                                           ; SOURCE LINE # 1762
                                           ; SOURCE LINE # 1763
                                           ; SOURCE LINE # 1767
0000 904E01            MOV     DPTR,#04E01H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 4404              ORL     A,#04H
0008 FF                MOV     R7,A
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1768
000B 120000      R     LCALL   ADC_StartConvert
                                           ; SOURCE LINE # 1769
000E 7F00              MOV     R7,#00H
0010 120000      R     LCALL   _ADC_IsEndConversion
                                           ; SOURCE LINE # 1770
0013 120000      R     LCALL   ADC_GetResult8
0016 900000      R     MOV     DPTR,#result
0019 EF                MOV     A,R7
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1771
001B 120000      R     LCALL   ADC_StopConvert
                                           ; SOURCE LINE # 1773
001E 900000      R     MOV     DPTR,#result
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
                                           ; SOURCE LINE # 1774
0023         ?C0089:
0023 22                RET     
             ; FUNCTION ADC_Read8 (END)

             ; FUNCTION ADC_Read16 (BEGIN)
                                           ; SOURCE LINE # 1795
                                           ; SOURCE LINE # 1796
                                           ; SOURCE LINE # 1800
0000 904E01            MOV     DPTR,#04E01H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 4404              ORL     A,#04H
0008 FF                MOV     R7,A
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1801
000B 120000      R     LCALL   ADC_StartConvert
                                           ; SOURCE LINE # 1802
000E 7F00              MOV     R7,#00H
0010 120000      R     LCALL   _ADC_IsEndConversion
                                           ; SOURCE LINE # 1803
0013 120000      R     LCALL   ADC_GetResult16
0016 900000      R     MOV     DPTR,#result
0019 EE                MOV     A,R6
001A F0                MOVX    @DPTR,A
001B A3                INC     DPTR
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1804
001E 120000      R     LCALL   ADC_StopConvert
C51 COMPILER V9.51   ADC                                                                   05/11/2016 14:38:08 PAGE 71  

                                           ; SOURCE LINE # 1806
0021 900000      R     MOV     DPTR,#result
0024 E0                MOVX    A,@DPTR
0025 FE                MOV     R6,A
0026 A3                INC     DPTR
0027 E0                MOVX    A,@DPTR
0028 FF                MOV     R7,A
                                           ; SOURCE LINE # 1807
0029         ?C0090:
0029 22                RET     
             ; FUNCTION ADC_Read16 (END)

             ; FUNCTION ADC_Read32 (BEGIN)
                                           ; SOURCE LINE # 1828
                                           ; SOURCE LINE # 1829
                                           ; SOURCE LINE # 1833
0000 904E01            MOV     DPTR,#04E01H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 4404              ORL     A,#04H
0008 FF                MOV     R7,A
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1834
000B 120000      R     LCALL   ADC_StartConvert
                                           ; SOURCE LINE # 1835
000E 7F00              MOV     R7,#00H
0010 120000      R     LCALL   _ADC_IsEndConversion
                                           ; SOURCE LINE # 1836
0013 120000      R     LCALL   ADC_GetResult32
0016 900000      R     MOV     DPTR,#result
0019 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1837
001C 120000      R     LCALL   ADC_StopConvert
                                           ; SOURCE LINE # 1839
001F 900000      R     MOV     DPTR,#result
0022 120000      E     LCALL   ?C?LLDXDATA
                                           ; SOURCE LINE # 1840
0025         ?C0091:
0025 22                RET     
             ; FUNCTION ADC_Read32 (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3364    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     16     104
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
