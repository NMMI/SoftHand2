C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE CYLIB
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Release\CyLib.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\4.0\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -Generated_Source\PSoC3\CyLib.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB DF(NDEBUG) WL
                    -(2) PR(.\DP8051_Keil_951\Release/CyLib.lst) CD OT(8,SPEED) OJ(.\DP8051_Keil_951\Release\CyLib.obj)

line level    source

*** MESSAGE C286 IN LINE 0 OF (null): license limits optimization to level 5
   1          /***************************************************************************//**
   2          * \file CyLib.c
   3          * \version 5.40
   4          *
   5          * \brief Provides a system API for the clocking, interrupts and watchdog timer.
   6          *
   7          * \note Documentation of the API's in this file is located in the System
   8          * Reference Guide provided with PSoC Creator.
   9          *
  10          ********************************************************************************
  11          * \copyright
  12          * Copyright 2008-2016, Cypress Semiconductor Corporation.  All rights reserved.
  13          * You may use this file only in accordance with the license, terms, conditions,
  14          * disclaimers, and limitations in the end user license agreement accompanying
  15          * the software package with which this file was provided.
  16          *******************************************************************************/
  17          
  18          #include "CyLib.h"
  19          
  20          
  21          /*******************************************************************************
  22          * The CyResetStatus variable is used to obtain value of RESET_SR0 register after
  23          * a device reset. It is set from initialize_psoc() at the early initialization
  24          * stage. In case of IAR EW IDE, initialize_psoc() is executed before the data
  25          * sections are initialized. To avoid zeroing, CyResetStatus should be placed
  26          * to the .noinit section.
  27          *******************************************************************************/
  28          CY_NOINIT uint8 CYXDATA CyResetStatus;
  29          
  30          
  31          /* Variable Vdda */
  32          #if(CYDEV_VARIABLE_VDDA == 1)
              
                  uint8 CyScPumpEnabled = (uint8)(CYDEV_VDDA_MV < 2700);
              
              #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
  37          
  38          
  39          /* Do not use these definitions directly in your application */
  40          uint32 cydelay_freq_hz  = BCLK__BUS_CLK__HZ;
  41          uint32 cydelay_freq_khz = (BCLK__BUS_CLK__HZ + 999u) / 1000u;
  42          uint8  cydelay_freq_mhz = (uint8)((BCLK__BUS_CLK__HZ + 999999u) / 1000000u);
  43          uint32 cydelay_32k_ms   = 32768u * ((BCLK__BUS_CLK__HZ + 999u) / 1000u);
  44          
  45          
  46          /* Function Prototypes */
  47          static uint8 CyUSB_PowerOnCheck(void)  ;
  48          static void CyIMO_SetTrimValue(uint8 freq) ;
  49          static void CyBusClk_Internal_SetDivider(uint16 divider);
  50          
  51          #if(CY_PSOC5)
                  static cySysTickCallback CySysTickCallbacks[CY_SYS_SYST_NUM_OF_CALLBACKS];
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 2   

                  static void CySysTickServiceCallbacks(void);
                  uint32 CySysTickInitVar = 0u;
              #endif  /* (CY_PSOC5) */
  56          
  57          
  58          #if(CY_PSOC3)
  59              CY_ISR_PROTO(IntDefaultHandler);
  60          #endif /* (CY_PSOC3) */
  61          
  62          
  63          /*******************************************************************************
  64          * Function Name: CyPLL_OUT_Start
  65          ****************************************************************************//**
  66          *
  67          *   Enables the PLL.  Optionally waits for it to become stable.
  68          *   Waits at least 250 us or until it is detected that the PLL is stable.
  69          *
  70          *   \param wait:
  71          *    \param 0: Return immediately after configuration
  72          *    \param 1: Wait for PLL lock or timeout.
  73          *
  74          * \return
  75          *   Status
  76          *    CYRET_SUCCESS - Completed successfully
  77          *    CYRET_TIMEOUT - Timeout occurred without detecting a stable clock.
  78          *     If the input source of the clock is jittery, then the lock indication
  79          *     may not occur.  However, after the timeout has expired the generated PLL
  80          *     clock can still be used.
  81          *
  82          * \sideeffect
  83          *  If wait is enabled: This function uses the Fast Time Wheel to time the wait.
  84          *  Any other use of the Fast Time Wheel will be stopped during the period of
  85          *  this function and then restored. This function also uses the 100 KHz ILO.
  86          *  If not enabled, this function will enable the 100 KHz ILO for the period of
  87          *  this function.
  88          *
  89          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
  90          *  Once Per Second interrupt may be made by interrupt routines during the period
  91          *  of this function execution. The current operation of the ILO, Central Time
  92          *  Wheel and Once Per Second interrupt are maintained during the operation of
  93          *  this function provided the reading of the Power Manager Interrupt Status
  94          *  Register is only done using the CyPmReadStatus() function.
  95          *
  96          *******************************************************************************/
  97          cystatus CyPLL_OUT_Start(uint8 wait) 
  98          {
  99   1          cystatus status = CYRET_SUCCESS;
 100   1      
 101   1          uint8 iloEnableState;
 102   1          uint8 pmTwCfg0State;
 103   1          uint8 pmTwCfg2State;
 104   1      
 105   1      
 106   1          /* Enables PLL circuit  */
 107   1          CY_CLK_PLL_CFG0_REG |= CY_CLK_PLL_ENABLE;
 108   1      
 109   1          if(wait != 0u)
 110   1          {
 111   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
 112   2              iloEnableState = CY_LIB_SLOWCLK_ILO_CR0_REG & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 113   2              pmTwCfg0State = CY_LIB_PM_TW_CFG0_REG;
 114   2              pmTwCfg2State = CY_LIB_PM_TW_CFG2_REG;
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 3   

 115   2      
 116   2              CyPmFtwSetInterval(CY_CLK_PLL_FTW_INTERVAL);
 117   2      
 118   2              status = CYRET_TIMEOUT;
 119   2      
 120   2              while(0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
 121   2              {
 122   3                  /* Wait for interrupt status */
 123   3                  if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 124   3                  {
 125   4                      if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 126   4                      {
 127   5                          status = CYRET_SUCCESS;
 128   5                          break;
 129   5                      }
 130   4                  }
 131   3              }
 132   2      
 133   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
 134   2              if(0u == iloEnableState)
 135   2              {
 136   3                  CyILO_Stop100K();
 137   3              }
 138   2      
 139   2              CY_LIB_PM_TW_CFG0_REG = pmTwCfg0State;
 140   2              CY_LIB_PM_TW_CFG2_REG = pmTwCfg2State;
 141   2          }
 142   1      
 143   1          return(status);
 144   1      }
 145          
 146          
 147          /*******************************************************************************
 148          * Function Name: CyPLL_OUT_Stop
 149          ****************************************************************************//**
 150          *
 151          *  Disables the PLL.
 152          *
 153          *******************************************************************************/
 154          void CyPLL_OUT_Stop(void) 
 155          {
 156   1          CY_CLK_PLL_CFG0_REG &= ((uint8)(~CY_CLK_PLL_ENABLE));
 157   1      }
 158          
 159          
 160          /*******************************************************************************
 161          * Function Name: CyPLL_OUT_SetPQ
 162          ****************************************************************************//**
 163          *
 164          *  Sets the P and Q dividers and the charge pump current.
 165          *  The Frequency Out will be P/Q * Frequency In.
 166          *  The PLL must be disabled before calling this function.
 167          *
 168          *  \param uint8 pDiv:
 169          *   Valid range [8 - 255].
 170          *
 171          *  \param uint8 qDiv:
 172          *   Valid range [1 - 16]. Input Frequency / Q must be in range of 1 to 3 MHz.
 173          
 174          *  \param uint8 current:
 175          *   Valid range [1 - 7]. Charge pump current in uA. Refer to the device TRM and
 176          *   datasheet for more information.
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 4   

 177          *
 178          * \sideeffect
 179          *  If this function execution results in the CPU clock frequency increasing,
 180          *  then the number of clock cycles the cache will wait before it samples data
 181          *  coming back from the Flash must be adjusted by calling
 182          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 183          *  called if the CPU clock frequency is lowered in order to improve the CPU
 184          *  performance. See CyFlash_SetWaitCycles() description for more information.
 185          *
 186          *******************************************************************************/
 187          void CyPLL_OUT_SetPQ(uint8 pDiv, uint8 qDiv, uint8 current) 
 188          {
 189   1          /* Halt CPU in debug mode if PLL is enabled */
 190   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 191   1      
 192   1          if((pDiv    >= CY_CLK_PLL_MIN_P_VALUE  ) &&
 193   1             (qDiv    <= CY_CLK_PLL_MAX_Q_VALUE  ) && (qDiv    >= CY_CLK_PLL_MIN_Q_VALUE  ) &&
 194   1             (current >= CY_CLK_PLL_MIN_CUR_VALUE) && (current <= CY_CLK_PLL_MAX_CUR_VALUE))
 195   1          {
 196   2              /* Set new values */
 197   2              CY_CLK_PLL_P_REG = pDiv;
 198   2              CY_CLK_PLL_Q_REG = ((uint8)(qDiv - 1u));
 199   2              CY_CLK_PLL_CFG1_REG = (CY_CLK_PLL_CFG1_REG & CY_CLK_PLL_CURRENT_MASK) |
 200   2                                      ((uint8)(((uint8)(current - 1u)) << CY_CLK_PLL_CURRENT_POSITION));
 201   2          }
 202   1          else
 203   1          {
 204   2              /***********************************************************************
 205   2              * Halt CPU in debug mode if:
 206   2              * - P divider is less than required
 207   2              * - Q divider is out of range
 208   2              * - pump current is out of range
 209   2              ***********************************************************************/
 210   2              CYASSERT(0u != 0u);
 211   2          }
 212   1      
 213   1      }
 214          
 215          
 216          /*******************************************************************************
 217          * Function Name: CyPLL_OUT_SetSource
 218          ****************************************************************************//**
 219          *
 220          *  Sets the input clock source to the PLL. The PLL must be disabled before
 221          *  calling this function.
 222          *
 223          *   \param source: One of the three available PLL clock sources
 224          *    \param CY_PLL_SOURCE_IMO  :   IMO
 225          *    \param CY_PLL_SOURCE_XTAL :   MHz Crystal
 226          *    \param CY_PLL_SOURCE_DSI  :   DSI
 227          *
 228          * \sideeffect
 229          *  If this function execution results in the CPU clock frequency increasing,
 230          *  then the number of clock cycles the cache will wait before it samples data
 231          *  coming back from the3 Flash must be adjusted by calling
 232          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 233          *  called if the CPU clock frequency is lowered in order to improve the CPU
 234          *  performance. See CyFlash_SetWaitCycles() description for more information.
 235          *
 236          *******************************************************************************/
 237          void CyPLL_OUT_SetSource(uint8 source) 
 238          {
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 5   

 239   1          /* Halt CPU in debug mode if PLL is enabled */
 240   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 241   1      
 242   1          switch(source)
 243   1          {
 244   2              case CY_PLL_SOURCE_IMO:
 245   2              case CY_PLL_SOURCE_XTAL:
 246   2              case CY_PLL_SOURCE_DSI:
 247   2                  CY_LIB_CLKDIST_CR_REG = ((CY_LIB_CLKDIST_CR_REG & CY_LIB_CLKDIST_CR_PLL_SCR_MASK) | source);
 248   2              break;
 249   2      
 250   2              default:
 251   2                  CYASSERT(0u != 0u);
 252   2              break;
 253   2          }
 254   1      }
 255          
 256          
 257          /*******************************************************************************
 258          * Function Name: CyIMO_Start
 259          ****************************************************************************//**
 260          *
 261          *  Enables the IMO. Optionally waits at least 6 us for it to settle.
 262          *
 263          *  \param uint8 wait:
 264          *   \param 0: Return immediately after configuration
 265          *   \param 1: Wait for at least 6 us for the IMO to settle.
 266          *
 267          * \sideeffect
 268          *  If wait is enabled: This function uses the Fast Time Wheel to time the wait.
 269          *  Any other use of the Fast Time Wheel will be stopped during the period of
 270          *  this function and then restored. This function also uses the 100 KHz ILO.
 271          *  If not enabled, this function will enable the 100 KHz ILO for the period of
 272          *  this function.
 273          *
 274          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
 275          *  Once Per Second interrupt may be made by interrupt routines during the period
 276          *  of this function execution. The current operation of the ILO, Central Time
 277          *  Wheel and Once Per Second interrupt are maintained during the operation of
 278          *  this function provided the reading of the Power Manager Interrupt Status
 279          *  Register is only done using the CyPmReadStatus() function.
 280          *
 281          *******************************************************************************/
 282          void CyIMO_Start(uint8 wait) 
 283          {
 284   1          uint8 pmFtwCfg2Reg;
 285   1          uint8 pmFtwCfg0Reg;
 286   1          uint8 ilo100KhzEnable;
 287   1      
 288   1      
 289   1          CY_LIB_PM_ACT_CFG0_REG  |= CY_LIB_PM_ACT_CFG0_IMO_EN;
 290   1          CY_LIB_PM_STBY_CFG0_REG |= CY_LIB_PM_STBY_CFG0_IMO_EN;
 291   1      
 292   1          if(0u != wait)
 293   1          {
 294   2              /* Need to turn on 100KHz ILO if it happens to not already be running.*/
 295   2              ilo100KhzEnable = CY_LIB_SLOWCLK_ILO_CR0_REG & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 296   2              pmFtwCfg0Reg = CY_LIB_PM_TW_CFG0_REG;
 297   2              pmFtwCfg2Reg = CY_LIB_PM_TW_CFG2_REG;
 298   2      
 299   2              CyPmFtwSetInterval(CY_LIB_CLK_IMO_FTW_TIMEOUT);
 300   2      
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 6   

 301   2              while (0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
 302   2              {
 303   3                  /* Wait for interrupt status */
 304   3              }
 305   2      
 306   2              if(0u == ilo100KhzEnable)
 307   2              {
 308   3                  CyILO_Stop100K();
 309   3              }
 310   2      
 311   2              CY_LIB_PM_TW_CFG0_REG = pmFtwCfg0Reg;
 312   2              CY_LIB_PM_TW_CFG2_REG = pmFtwCfg2Reg;
 313   2          }
 314   1      }
 315          
 316          
 317          /*******************************************************************************
 318          * Function Name: CyIMO_Stop
 319          ****************************************************************************//**
 320          *
 321          *   Disables the IMO.
 322          *
 323          *******************************************************************************/
 324          void CyIMO_Stop(void) 
 325          {
 326   1          CY_LIB_PM_ACT_CFG0_REG  &= ((uint8) (~CY_LIB_PM_ACT_CFG0_IMO_EN));
 327   1          CY_LIB_PM_STBY_CFG0_REG &= ((uint8) (~CY_LIB_PM_STBY_CFG0_IMO_EN));
 328   1      }
 329          
 330          
 331          /*******************************************************************************
 332          * Function Name: CyUSB_PowerOnCheck
 333          ****************************************************************************//**
 334          *
 335          *  Returns the USB power status value. A private function to cy_boot.
 336          *
 337          * \return
 338          *   uint8: one if the USB is enabled, 0 if not enabled.
 339          *
 340          *******************************************************************************/
 341          static uint8 CyUSB_PowerOnCheck(void)  
 342          {
 343   1          uint8 poweredOn = 0u;
 344   1      
 345   1          /* Check whether device is in Active or AltActive and if USB is powered on */
 346   1          if((((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ACTIVE ) &&
 347   1             (0u != (CY_LIB_PM_ACT_CFG5_REG & CY_ACT_USB_ENABLED     )))  ||
 348   1             (((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ALT_ACT) &&
 349   1             (0u != (CY_LIB_PM_STBY_CFG5_REG & CY_ALT_ACT_USB_ENABLED))))
 350   1          {
 351   2              poweredOn = 1u;
 352   2          }
 353   1      
 354   1          return (poweredOn);
 355   1      }
 356          
 357          
 358          /*******************************************************************************
 359          * Function Name: CyIMO_SetTrimValue
 360          ****************************************************************************//**
 361          *
 362          *  Sets the IMO factory trim values.
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 7   

 363          *
 364          *  uint8 freq - frequency for which trims must be set
 365          *
 366          *******************************************************************************/
 367          static void CyIMO_SetTrimValue(uint8 freq) 
 368          {
 369   1          uint8 usbPowerOn = CyUSB_PowerOnCheck();
 370   1      
 371   1          /* If USB is powered */
 372   1          if(usbPowerOn == 1u)
 373   1          {
 374   2              /* Unlock USB write */
 375   2              CY_LIB_USB_CR1_REG &= ((uint8)(~CY_LIB_USB_CLK_EN));
 376   2          }
 377   1          switch(freq)
 378   1          {
 379   2          case CY_IMO_FREQ_3MHZ:
 380   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_3MHZ_PTR);
 381   2              break;
 382   2      
 383   2          case CY_IMO_FREQ_6MHZ:
 384   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_6MHZ_PTR);
 385   2              break;
 386   2      
 387   2          case CY_IMO_FREQ_12MHZ:
 388   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_12MHZ_PTR);
 389   2              break;
 390   2      
 391   2          case CY_IMO_FREQ_24MHZ:
 392   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_24MHZ_PTR);
 393   2              break;
 394   2      
 395   2          case CY_IMO_FREQ_48MHZ:
 396   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_TR1_PTR);
 397   2              break;
 398   2      
 399   2          case CY_IMO_FREQ_62MHZ:
 400   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_67MHZ_PTR);
 401   2              break;
 402   2      
 403   2      #if(CY_PSOC5)
                  case CY_IMO_FREQ_74MHZ:
                      CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_80MHZ_PTR);
                      break;
              #endif  /* (CY_PSOC5) */
 408   2      
 409   2          case CY_IMO_FREQ_USB:
 410   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_USB_PTR);
 411   2      
 412   2              /* If USB is powered */
 413   2              if(usbPowerOn == 1u)
 414   2              {
 415   3                  /* Lock USB Oscillator */
 416   3                  CY_LIB_USB_CR1_REG |= CY_LIB_USB_CLK_EN;
 417   3              }
 418   2              break;
 419   2      
 420   2          default:
 421   2                  CYASSERT(0u != 0u);
 422   2              break;
 423   2          }
 424   1      
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 8   

 425   1      }
 426          
 427          
 428          /*******************************************************************************
 429          * Function Name: CyIMO_SetFreq
 430          ****************************************************************************//**
 431          *
 432          *  Sets the frequency of the IMO. Changes may be made while the IMO is running.
 433          *
 434          *  \param freq: Frequency of IMO operation
 435          *       CY_IMO_FREQ_3MHZ  to set  3   MHz
 436          *       CY_IMO_FREQ_6MHZ  to set  6   MHz
 437          *       CY_IMO_FREQ_12MHZ to set 12   MHz
 438          *       CY_IMO_FREQ_24MHZ to set 24   MHz
 439          *       CY_IMO_FREQ_48MHZ to set 48   MHz
 440          *       CY_IMO_FREQ_62MHZ to set 62.6 MHz
 441          *       CY_IMO_FREQ_74MHZ to set 74.7 MHz (not applicable for PSoC 3)
 442          *       CY_IMO_FREQ_USB   to set 24   MHz (Trimmed for USB operation)
 443          *
 444          * \sideeffect
 445          *  If this function execution results in the CPU clock frequency increasing,
 446          *  then the number of clock cycles the cache will wait before it samples data
 447          *  coming back from the Flash must be adjusted by calling
 448          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 449          *  called if the CPU clock frequency is lowered in order to improve the CPU
 450          *  performance. See CyFlash_SetWaitCycles() description for more information.
 451          *
 452          *  When the USB setting is chosen, the USB clock locking circuit is enabled.
 453          *  Otherwise this circuit is disabled. The USB block must be powered before
 454          *  selecting the USB setting.
 455          *
 456          *******************************************************************************/
 457          void CyIMO_SetFreq(uint8 freq) 
 458          {
 459   1          uint8 currentFreq;
 460   1          uint8 nextFreq;
 461   1      
 462   1          /***************************************************************************
 463   1          * If the IMO frequency is changed,the Trim values must also be set
 464   1          * accordingly.This requires reading the current frequency. If the new
 465   1          * frequency is faster, then set a new trim and then change the frequency,
 466   1          * otherwise change the frequency and then set new trim values.
 467   1          ***************************************************************************/
 468   1      
 469   1          currentFreq = CY_LIB_FASTCLK_IMO_CR_REG & ((uint8)(~CY_LIB_FASTCLK_IMO_CR_RANGE_MASK));
 470   1      
 471   1          /* Check if requested frequency is USB. */
 472   1          nextFreq = (freq == CY_IMO_FREQ_USB) ? CY_IMO_FREQ_24MHZ : freq;
 473   1      
 474   1          switch (currentFreq)
 475   1          {
 476   2          case 0u:
 477   2              currentFreq = CY_IMO_FREQ_12MHZ;
 478   2              break;
 479   2      
 480   2          case 1u:
 481   2              currentFreq = CY_IMO_FREQ_6MHZ;
 482   2              break;
 483   2      
 484   2          case 2u:
 485   2              currentFreq = CY_IMO_FREQ_24MHZ;
 486   2              break;
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 9   

 487   2      
 488   2          case 3u:
 489   2              currentFreq = CY_IMO_FREQ_3MHZ;
 490   2              break;
 491   2      
 492   2          case 4u:
 493   2              currentFreq = CY_IMO_FREQ_48MHZ;
 494   2              break;
 495   2      
 496   2          case 5u:
 497   2              currentFreq = CY_IMO_FREQ_62MHZ;
 498   2              break;
 499   2      
 500   2      #if(CY_PSOC5)
                  case 6u:
                      currentFreq = CY_IMO_FREQ_74MHZ;
                      break;
              #endif  /* (CY_PSOC5) */
 505   2      
 506   2          default:
 507   2              CYASSERT(0u != 0u);
 508   2              break;
 509   2          }
 510   1      
 511   1          if (nextFreq >= currentFreq)
 512   1          {
 513   2              /* Set new trim first */
 514   2              CyIMO_SetTrimValue(freq);
 515   2          }
 516   1      
 517   1          /* Set usbclk_on bit when using CY_IMO_FREQ_USB, if not clear it */
 518   1          switch(freq)
 519   1          {
 520   2          case CY_IMO_FREQ_3MHZ:
 521   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 522   2                  CY_LIB_IMO_3MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 523   2              break;
 524   2      
 525   2          case CY_IMO_FREQ_6MHZ:
 526   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 527   2                  CY_LIB_IMO_6MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 528   2              break;
 529   2      
 530   2          case CY_IMO_FREQ_12MHZ:
 531   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 532   2                  CY_LIB_IMO_12MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 533   2              break;
 534   2      
 535   2          case CY_IMO_FREQ_24MHZ:
 536   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 537   2                  CY_LIB_IMO_24MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 538   2              break;
 539   2      
 540   2          case CY_IMO_FREQ_48MHZ:
 541   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 542   2                  CY_LIB_IMO_48MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 543   2              break;
 544   2      
 545   2          case CY_IMO_FREQ_62MHZ:
 546   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 547   2                  CY_LIB_IMO_62MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 548   2              break;
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 10  

 549   2      
 550   2      #if(CY_PSOC5)
                  case CY_IMO_FREQ_74MHZ:
                      CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
                          CY_LIB_IMO_74MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
                      break;
              #endif  /* (CY_PSOC5) */
 556   2      
 557   2          case CY_IMO_FREQ_USB:
 558   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 559   2                  CY_LIB_IMO_24MHZ_VALUE) | CY_LIB_IMO_USBCLK_ON_SET;
 560   2              break;
 561   2      
 562   2          default:
 563   2              CYASSERT(0u != 0u);
 564   2              break;
 565   2          }
 566   1      
 567   1          /* Tu rn onIMO Doubler, if switching to CY_IMO_FREQ_USB */
 568   1          if (freq == CY_IMO_FREQ_USB)
 569   1          {
 570   2              CyIMO_EnableDoubler();
 571   2          }
 572   1          else
 573   1          {
 574   2              CyIMO_DisableDoubler();
 575   2          }
 576   1      
 577   1          if (nextFreq < currentFreq)
 578   1          {
 579   2              /* Set the trim after setting frequency */
 580   2              CyIMO_SetTrimValue(freq);
 581   2          }
 582   1      }
 583          
 584          
 585          /*******************************************************************************
 586          * Function Name: CyIMO_SetSource
 587          ****************************************************************************//**
 588          *
 589          *  Sets the source of the clock output from the IMO block.
 590          *
 591          *  The output from the IMO is by default the IMO itself. Optionally the MHz
 592          *  Crystal or DSI input can be the source of the IMO output instead.
 593          *
 594          *   \param source: CY_IMO_SOURCE_DSI to set the DSI as source.
 595          *           CY_IMO_SOURCE_XTAL to set the MHz as source.
 596          *           CY_IMO_SOURCE_IMO to set the IMO itself.
 597          *
 598          * \sideeffect
 599          *  If this function execution resulted in the CPU clock frequency increasing,
 600          *  then the number of clock cycles the cache will wait before it samples data
 601          *  coming back from the Flash must be adjusted by calling
 602          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 603          *  called if the CPU clock frequency is lowered in order to improve the CPU
 604          *  performance. See CyFlash_SetWaitCycles() description for more information.
 605          *
 606          *******************************************************************************/
 607          void CyIMO_SetSource(uint8 source) 
 608          {
 609   1          switch(source)
 610   1          {
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 11  

 611   2          case CY_IMO_SOURCE_DSI:
 612   2              CY_LIB_CLKDIST_CR_REG     &= ((uint8)(~CY_LIB_CLKDIST_CR_IMO2X));
 613   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 614   2              break;
 615   2      
 616   2          case CY_IMO_SOURCE_XTAL:
 617   2              CY_LIB_CLKDIST_CR_REG     |= CY_LIB_CLKDIST_CR_IMO2X;
 618   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 619   2              break;
 620   2      
 621   2          case CY_IMO_SOURCE_IMO:
 622   2              CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_IMO));
 623   2              break;
 624   2      
 625   2          default:
 626   2              /* Incorrect source value */
 627   2              CYASSERT(0u != 0u);
 628   2              break;
 629   2          }
 630   1      }
 631          
 632          
 633          /*******************************************************************************
 634          * Function Name: CyIMO_EnableDoubler
 635          ****************************************************************************//**
 636          *
 637          *  Enables the IMO doubler.  The 2x frequency clock is used to convert a 24 MHz
 638          *  input to a 48 MHz output for use by the USB block.
 639          *
 640          *******************************************************************************/
 641          void CyIMO_EnableDoubler(void) 
 642          {
 643   1          /* Set FASTCLK_IMO_CR_PTR regigster's 4th bit */
 644   1          CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_DOUBLER;
 645   1      }
 646          
 647          
 648          /*******************************************************************************
 649          * Function Name: CyIMO_DisableDoubler
 650          ****************************************************************************//**
 651          *
 652          *   Disables the IMO doubler.
 653          *
 654          *******************************************************************************/
 655          void CyIMO_DisableDoubler(void) 
 656          {
 657   1          CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_DOUBLER));
 658   1      }
 659          
 660          
 661          /*******************************************************************************
 662          * Function Name: CyMasterClk_SetSource
 663          ****************************************************************************//**
 664          *
 665          *  Sets the source of the master clock.
 666          *
 667          *   \param source: One of the four available Master clock sources.
 668          *     CY_MASTER_SOURCE_IMO
 669          *     CY_MASTER_SOURCE_PLL
 670          *     CY_MASTER_SOURCE_XTAL
 671          *     CY_MASTER_SOURCE_DSI
 672          *
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 12  

 673          * \sideeffect
 674          *  The current source and the new source must both be running and stable before
 675          *  calling this function.
 676          *
 677          *  If this function execution resulted in the CPU clock frequency increasing,
 678          *  then the number of clock cycles the cache will wait before it samples data
 679          *  coming back from the Flash must be adjusted by calling
 680          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 681          *  called if the CPU clock frequency is lowered in order to improve the CPU
 682          *  performance. See CyFlash_SetWaitCycles() description for more information.
 683          *
 684          *******************************************************************************/
 685          void CyMasterClk_SetSource(uint8 source) 
 686          {
 687   1          CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & MASTER_CLK_SRC_CLEAR) |
 688   1                                      (source & ((uint8)(~MASTER_CLK_SRC_CLEAR)));
 689   1      }
 690          
 691          
 692          /*******************************************************************************
 693          * Function Name: CyMasterClk_SetDivider
 694          ****************************************************************************//**
 695          *
 696          *  Sets the divider value used to generate Master Clock.
 697          *
 698          *  \param uint8 divider:
 699          *   The valid range is [0-255]. The clock will be divided by this value + 1.
 700          *   For example to divide this parameter by two should be set to 1.
 701          *
 702          * \sideeffect
 703          *  If this function execution resulted in the CPU clock frequency increasing,
 704          *  then the number of clock cycles the cache will wait before it samples data
 705          *  coming back from the Flash must be adjusted by calling
 706          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 707          *  called if the CPU clock frequency is lowered in order to improve the CPU
 708          *  performance. See CyFlash_SetWaitCycles() description for more information.
 709          *
 710          *  When changing the Master or Bus clock divider value from div-by-n to div-by-1
 711          *  the first clock cycle output after the div-by-1 can be up to 4 ns shorter
 712          *  than the final/expected div-by-1 period.
 713          *
 714          *******************************************************************************/
 715          void CyMasterClk_SetDivider(uint8 divider) 
 716          {
 717   1          CY_LIB_CLKDIST_MSTR0_REG = divider;
 718   1      }
 719          
 720          
 721          /*******************************************************************************
 722          * Function Name: CyBusClk_Internal_SetDivider
 723          ****************************************************************************//**
 724          *
 725          *  The function used by CyBusClk_SetDivider(). For internal use only.
 726          *
 727          *   \param divider: Valid range [0-65535].
 728          *   The clock will be divided by this value + 1.
 729          *   For example, to divide this parameter by two should be set to 1.
 730          *
 731          *******************************************************************************/
 732          static void CyBusClk_Internal_SetDivider(uint16 divider)
 733          {
 734   1          /* Mask bits to enable shadow loads  */
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 13  

 735   1          CY_LIB_CLKDIST_AMASK_REG &= CY_LIB_CLKDIST_AMASK_MASK;
 736   1          CY_LIB_CLKDIST_DMASK_REG  = CY_LIB_CLKDIST_DMASK_MASK;
 737   1      
 738   1          /* Enable mask bits to enable shadow loads */
 739   1          CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_MASK;
 740   1      
 741   1          /* Update Shadow Divider Value Register with new divider */
 742   1          CY_LIB_CLKDIST_WRK_LSB_REG = LO8(divider);
 743   1          CY_LIB_CLKDIST_WRK_MSB_REG = HI8(divider);
 744   1      
 745   1      
 746   1          /***************************************************************************
 747   1          * Copy shadow value defined in Shadow Divider Value Register
 748   1          * (CY_LIB_CLKDIST_WRK_LSB_REG and CY_LIB_CLKDIST_WRK_MSB_REG) to all
 749   1          * dividers selected in Analog and Digital Clock Mask Registers
 750   1          * (CY_LIB_CLKDIST_AMASK_REG and CY_LIB_CLKDIST_DMASK_REG).
 751   1          ***************************************************************************/
 752   1          CY_LIB_CLKDIST_LD_REG |= CY_LIB_CLKDIST_LD_LOAD;
 753   1      }
 754          
 755          
 756          /*******************************************************************************
 757          * Function Name: CyBusClk_SetDivider
 758          ****************************************************************************//**
 759          *
 760          *  Sets the divider value used to generate the Bus Clock.
 761          *
 762          *  \param divider: Valid range [0-65535]. The clock will be divided by this value + 1.
 763          *  For example, to divide this parameter by two should be set to 1.
 764          *
 765          * \sideeffect
 766          *  If this function execution resulted in the CPU clock frequency increasing,
 767          *  then the number of clock cycles the cache will wait before it samples data
 768          *  coming back from the Flash must be adjusted by calling
 769          *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 770          *  called if the CPU clock frequency is lowered in order to improve the CPU
 771          *  performance. See CyFlash_SetWaitCycles() description for more information.
 772          *
 773          *******************************************************************************/
 774          void CyBusClk_SetDivider(uint16 divider) 
 775          {
 776   1          uint8  masterClkDiv;
 777   1          uint16 busClkDiv;
 778   1          uint8 interruptState;
 779   1      
 780   1          interruptState = CyEnterCriticalSection();
 781   1      
 782   1          /* Work around to set bus clock divider value */
 783   1          busClkDiv = (uint16)((uint16)CY_LIB_CLKDIST_BCFG_MSB_REG << 8u);
 784   1          busClkDiv |= CY_LIB_CLKDIST_BCFG_LSB_REG;
 785   1      
 786   1          if ((divider == 0u) || (busClkDiv == 0u))
 787   1          {
 788   2              /* Save away master clock divider value */
 789   2              masterClkDiv = CY_LIB_CLKDIST_MSTR0_REG;
 790   2      
 791   2              if (masterClkDiv < CY_LIB_CLKDIST_MASTERCLK_DIV)
 792   2              {
 793   3                  /* Set master clock divider to 7 */
 794   3                  CyMasterClk_SetDivider(CY_LIB_CLKDIST_MASTERCLK_DIV);
 795   3              }
 796   2      
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 14  

 797   2              if (divider == 0u)
 798   2              {
 799   3                  /* Set SSS bit and divider register desired value */
 800   3                  CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_SSS;
 801   3                  CyBusClk_Internal_SetDivider(divider);
 802   3              }
 803   2              else
 804   2              {
 805   3                  CyBusClk_Internal_SetDivider(divider);
 806   3                  CY_LIB_CLKDIST_BCFG2_REG &= ((uint8)(~CY_LIB_CLKDIST_BCFG2_SSS));
 807   3              }
 808   2      
 809   2              /* Restore master clock */
 810   2              CyMasterClk_SetDivider(masterClkDiv);
 811   2          }
 812   1          else
 813   1          {
 814   2              CyBusClk_Internal_SetDivider(divider);
 815   2          }
 816   1      
 817   1          CyExitCriticalSection(interruptState);
 818   1      }
 819          
 820          
 821          #if(CY_PSOC3)
 822          
 823              /*******************************************************************************
 824              * Function Name: CyCpuClk_SetDivider
 825              ****************************************************************************//**
 826              *
 827              *  Sets the divider value used to generate the CPU Clock. Only applicable for
 828              *  PSoC 3 parts.
 829              *
 830              *  \param divider: Valid range [0-15]. The clock will be divided by this value + 1.
 831              *  For example, to divide this parameter by two should be set to 1.
 832              *
 833              * \sideeffect
 834              *  If this function execution resulted in the CPU clock frequency increasing,
 835              *  then the number of clock cycles the cache will wait before it samples data
 836              *  coming back from the Flash must be adjusted by calling
 837              *  CyFlash_SetWaitCycles() with an appropriate parameter. It can be optionally
 838              *  called if the CPU clock frequency is lowered in order to improve the CPU
 839              *  performance. See CyFlash_SetWaitCycles() description for more information.
 840              *
 841              *******************************************************************************/
 842              void CyCpuClk_SetDivider(uint8 divider) 
 843              {
 844   1                  CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & CY_LIB_CLKDIST_MSTR1_DIV_MASK) |
 845   1                                      ((uint8)(divider << CY_LIB_CLKDIST_DIV_POSITION));
 846   1          }
 847          
 848          #endif /* (CY_PSOC3) */
 849          
 850          
 851          /*******************************************************************************
 852          * Function Name: CyUsbClk_SetSource
 853          ****************************************************************************//**
 854          *
 855          *  Sets the source of the USB clock.
 856          *
 857          *  \param source: One of the four available USB clock sources
 858          *    CY_LIB_USB_CLK_IMO2X     - IMO 2x
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 15  

 859          *    CY_LIB_USB_CLK_IMO       - IMO
 860          *    CY_LIB_USB_CLK_PLL       - PLL
 861          *    CY_LIB_USB_CLK_DSI       - DSI
 862          *
 863          *******************************************************************************/
 864          void CyUsbClk_SetSource(uint8 source) 
 865          {
 866   1          CY_LIB_CLKDIST_UCFG_REG = (CY_LIB_CLKDIST_UCFG_REG & ((uint8)(~CY_LIB_CLKDIST_UCFG_SRC_SEL_MASK))) |
 867   1                              (CY_LIB_CLKDIST_UCFG_SRC_SEL_MASK & source);
 868   1      }
 869          
 870          
 871          /*******************************************************************************
 872          * Function Name: CyILO_Start1K
 873          ****************************************************************************//**
 874          *
 875          *  Enables the ILO 1 KHz oscillator.
 876          *
 877          *  Note The ILO 1 KHz oscillator is always enabled by default, regardless of the
 878          *  selection in the Clock Editor. Therefore, this API is only needed if the
 879          *  oscillator was turned off manually.
 880          *
 881          *******************************************************************************/
 882          void CyILO_Start1K(void) 
 883          {
 884   1          /* Set bit 1 of ILO RS */
 885   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_1KHZ;
 886   1      }
 887          
 888          
 889          /*******************************************************************************
 890          * Function Name: CyILO_Stop1K
 891          ****************************************************************************//**
 892          *
 893          *  Disables the ILO 1 KHz oscillator.
 894          *
 895          *  Note The ILO 1 KHz oscillator must be enabled if the Sleep or Hibernate low
 896          *  power mode APIs are expected to be used. For more information, refer to the
 897          *  Power Management section of this document.
 898          *
 899          * \sideeffect
 900          *  PSoC5: Stopping the ILO 1 kHz could break the active WDT functionality.
 901          *
 902          *******************************************************************************/
 903          void CyILO_Stop1K(void) 
 904          {
 905   1          /* Clear bit 1 of ILO RS */
 906   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_1KHZ));
 907   1      }
 908          
 909          
 910          /*******************************************************************************
 911          * Function Name: CyILO_Start100K
 912          ****************************************************************************//**
 913          *
 914          *  Enables the ILO 100 KHz oscillator.
 915          *
 916          *******************************************************************************/
 917          void CyILO_Start100K(void) 
 918          {
 919   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 920   1      }
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 16  

 921          
 922          
 923          /*******************************************************************************
 924          * Function Name: CyILO_Stop100K
 925          ****************************************************************************//**
 926          *
 927          *  Disables the ILO 100 KHz oscillator.
 928          *
 929          *******************************************************************************/
 930          void CyILO_Stop100K(void) 
 931          {
 932   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ));
 933   1      }
 934          
 935          
 936          /*******************************************************************************
 937          * Function Name: CyILO_Enable33K
 938          ****************************************************************************//**
 939          *
 940          *  Enables the ILO 33 KHz divider.
 941          *
 942          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator,
 943          *  so it must also be running in order to generate the 33 KHz output.
 944          *
 945          *******************************************************************************/
 946          void CyILO_Enable33K(void) 
 947          {
 948   1          /* Set bit 5 of ILO RS */
 949   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_33KHZ;
 950   1      }
 951          
 952          
 953          /*******************************************************************************
 954          * Function Name: CyILO_Disable33K
 955          ****************************************************************************//**
 956          *
 957          *  Disables the ILO 33 KHz divider.
 958          *
 959          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator, but this
 960          *  API does not disable the 100 KHz clock.
 961          *
 962          *******************************************************************************/
 963          void CyILO_Disable33K(void) 
 964          {
 965   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_33KHZ));
 966   1      }
 967          
 968          
 969          /*******************************************************************************
 970          * Function Name: CyILO_SetSource
 971          ****************************************************************************//**
 972          *
 973          *  Sets the source of the clock output from the ILO block.
 974          *
 975          *  \param source: One of the three available ILO output sources
 976          *       Value        Define                Source
 977          *       0            CY_ILO_SOURCE_100K    ILO 100 KHz
 978          *       1            CY_ILO_SOURCE_33K     ILO 33 KHz
 979          *       2            CY_ILO_SOURCE_1K      ILO 1 KHz
 980          *
 981          *******************************************************************************/
 982          void CyILO_SetSource(uint8 source) 
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 17  

 983          {
 984   1          CY_LIB_CLKDIST_CR_REG = (CY_LIB_CLKDIST_CR_REG & CY_ILO_SOURCE_BITS_CLEAR) |
 985   1                          (((uint8) (source << 2u)) & ((uint8)(~CY_ILO_SOURCE_BITS_CLEAR)));
 986   1      }
 987          
 988          
 989          /*******************************************************************************
 990          * Function Name: CyILO_SetPowerMode
 991          ****************************************************************************//**
 992          *
 993          * Sets the power mode used by the ILO during power down. Allows for lower power
 994          * down power usage resulting in a slower startup time.
 995          *
 996          * \param mode
 997          * CY_ILO_FAST_START - Faster start-up, internal bias left on when powered down
 998          * CY_ILO_SLOW_START - Slower start-up, internal bias off when powered down
 999          *
1000          * \return Prevous power mode state.
1001          *
1002          *******************************************************************************/
1003          uint8 CyILO_SetPowerMode(uint8 mode) 
1004          {
1005   1          uint8 state;
1006   1      
1007   1          /* Get current state. */
1008   1          state = CY_LIB_SLOWCLK_ILO_CR0_REG;
1009   1      
1010   1          /* Set the oscillator power mode. */
1011   1          if(mode != CY_ILO_FAST_START)
1012   1          {
1013   2              CY_LIB_SLOWCLK_ILO_CR0_REG = (state | CY_ILO_CONTROL_PD_MODE);
1014   2          }
1015   1          else
1016   1          {
1017   2              CY_LIB_SLOWCLK_ILO_CR0_REG = (state & ((uint8)(~CY_ILO_CONTROL_PD_MODE)));
1018   2          }
1019   1      
1020   1          /* Return old mode. */
1021   1          return ((state & CY_ILO_CONTROL_PD_MODE) >> CY_ILO_CONTROL_PD_POSITION);
1022   1      }
1023          
1024          
1025          /*******************************************************************************
1026          * Function Name: CyXTAL_32KHZ_Start
1027          ****************************************************************************//**
1028          *
1029          *  Enables the 32 KHz Crystal Oscillator.
1030          *
1031          *******************************************************************************/
1032          void CyXTAL_32KHZ_Start(void) 
1033          {
1034   1          volatile uint16 i;
1035   1      
1036   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1037   1          CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_STARTUP;
1038   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1039   1                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1040   1      
1041   1          #if(CY_PSOC3)
1042   1              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_PDBEN;
1043   1          #endif  /* (CY_PSOC3) */
1044   1      
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 18  

1045   1          /* Enable operation of 32K Crystal Oscillator */
1046   1          CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_EN;
1047   1      
1048   1          for (i = 1000u; i > 0u; i--)
1049   1          {
1050   2              if(0u != (CyXTAL_32KHZ_ReadStatus() & CY_XTAL32K_ANA_STAT))
1051   2              {
1052   3                  /* Ready - switch to high power mode */
1053   3                  (void) CyXTAL_32KHZ_SetPowerMode(0u);
1054   3      
1055   3                  break;
1056   3              }
1057   2              CyDelayUs(1u);
1058   2          }
1059   1      }
1060          
1061          
1062          /*******************************************************************************
1063          * Function Name: CyXTAL_32KHZ_Stop
1064          ****************************************************************************//**
1065          *
1066          *  Disables the 32KHz Crystal Oscillator.
1067          *
1068          *******************************************************************************/
1069          void CyXTAL_32KHZ_Stop(void) 
1070          {
1071   1          CY_CLK_XTAL32_TST_REG  = CY_CLK_XTAL32_TST_DEFAULT;
1072   1          CY_CLK_XTAL32_TR_REG   = CY_CLK_XTAL32_TR_POWERDOWN;
1073   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1074   1                                   CY_CLK_XTAL32_CFG_LP_DEFAULT;
1075   1          CY_CLK_XTAL32_CR_REG &= ((uint8)(~(CY_CLK_XTAL32_CR_EN | CY_CLK_XTAL32_CR_LPM)));
1076   1      
1077   1          #if(CY_PSOC3)
1078   1              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_PDBEN));
1079   1          #endif  /* (CY_PSOC3) */
1080   1      }
1081          
1082          
1083          /*******************************************************************************
1084          * Function Name: CyXTAL_32KHZ_ReadStatus
1085          ****************************************************************************//**
1086          *
1087          *  Returns status of the 32 KHz oscillator.
1088          *
1089          * \return
1090          *  Value     Define                    Source
1091          *  20        CY_XTAL32K_ANA_STAT       Analog measurement
1092          *                                       1: Stable
1093          *                                       0: Not stable
1094          *
1095          *******************************************************************************/
1096          uint8 CyXTAL_32KHZ_ReadStatus(void) 
1097          {
1098   1          return(CY_CLK_XTAL32_CR_REG & CY_XTAL32K_ANA_STAT);
1099   1      }
1100          
1101          
1102          /*******************************************************************************
1103          * Function Name: CyXTAL_32KHZ_SetPowerMode
1104          ****************************************************************************//**
1105          *
1106          *  Sets the power mode for the 32 KHz oscillator used during the sleep mode.
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 19  

1107          *  Allows for lower power during sleep when there are fewer sources of noise.
1108          *  During the active mode the oscillator is always run in the high power mode.
1109          *
1110          *  uint8 mode
1111          *       \param 0: High power mode
1112          *       \param 1: Low power mode during sleep
1113          *
1114          * \return
1115          *  Previous power mode.
1116          *
1117          *******************************************************************************/
1118          uint8 CyXTAL_32KHZ_SetPowerMode(uint8 mode) 
1119          {
1120   1          uint8 state = (0u != (CY_CLK_XTAL32_CR_REG & CY_CLK_XTAL32_CR_LPM)) ? 1u : 0u;
1121   1      
1122   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1123   1      
1124   1          if(1u == mode)
1125   1          {
1126   2              /* Low power mode during Sleep */
1127   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_LOW_POWER;
1128   2              CyDelayUs(10u);
1129   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1130   2                                      CY_CLK_XTAL32_CFG_LP_LOWPOWER;
1131   2              CyDelayUs(20u);
1132   2              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_LPM;
1133   2          }
1134   1          else
1135   1          {
1136   2              /* High power mode */
1137   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_HIGH_POWER;
1138   2              CyDelayUs(10u);
1139   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1140   2                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1141   2              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_LPM));
1142   2          }
1143   1      
1144   1          return(state);
1145   1      }
1146          
1147          
1148          /*******************************************************************************
1149          * Function Name: CyXTAL_Start
1150          ****************************************************************************//**
1151          *
1152          *  Enables the megahertz crystal.
1153          *
1154          *  PSoC 3:
1155          *  Waits until the XERR bit is low (no error) for a millisecond or until the
1156          *  number of milliseconds specified by the wait parameter has expired.
1157          *
1158          *   \param wait: Valid range [0-255].
1159          *   This is the timeout value in milliseconds.
1160          *   The appropriate value is crystal specific.
1161          *
1162          * \return
1163          *   CYRET_SUCCESS - Completed successfully
1164          *   CYRET_TIMEOUT - Timeout occurred without detecting a low value on XERR.
1165          *
1166          * Side Effects and Restrictions:
1167          *  If wait is enabled (non-zero wait). Uses the Fast Timewheel to time the wait.
1168          *  Any other use of the Fast Timewheel (FTW) will be stopped during the period
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 20  

1169          *  of this function and then restored.
1170          *
1171          *  Uses the 100KHz ILO.  If not enabled, this function will enable the 100KHz
1172          *  ILO for the period of this function. No changes to the setup of the ILO,
1173          *  Fast Timewheel, Central Timewheel or Once Per Second interrupt may be made
1174          *  by interrupt routines during the period of this function.
1175          *
1176          *  The current operation of the ILO, Central Timewheel and Once Per Second
1177          *  interrupt are maintained during the operation of this function provided the
1178          *  reading of the Power Manager Interrupt Status Register is only done using the
1179          *  CyPmReadStatus() function.
1180          *
1181          *******************************************************************************/
1182          cystatus CyXTAL_Start(uint8 wait) 
1183          {
1184   1          cystatus status = CYRET_SUCCESS;
1185   1          volatile uint8  timeout = wait;
1186   1          volatile uint8 count;
1187   1          uint8 iloEnableState;
1188   1          uint8 pmTwCfg0Tmp;
1189   1          uint8 pmTwCfg2Tmp;
1190   1      
1191   1      
1192   1          /* Enables MHz crystal oscillator circuit  */
1193   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_ENABLE;
1194   1      
1195   1      
1196   1          if(wait > 0u)
1197   1          {
1198   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
1199   2              iloEnableState = CY_LIB_SLOWCLK_ILO_CR0_REG;
1200   2              pmTwCfg0Tmp = CY_LIB_PM_TW_CFG0_REG;
1201   2              pmTwCfg2Tmp = CY_LIB_PM_TW_CFG2_REG;
1202   2      
1203   2              /* Set 250 us interval */
1204   2              CyPmFtwSetInterval(CY_CLK_XMHZ_FTW_INTERVAL);
1205   2              status = CYRET_TIMEOUT;
1206   2      
1207   2      
1208   2              for( ; timeout > 0u; timeout--)
1209   2              {
1210   3                  /* Read XERR bit to clear it */
1211   3                  (void) CY_CLK_XMHZ_CSR_REG;
1212   3      
1213   3                  /* Wait for 1 millisecond - 4 x 250 us */
1214   3                  for(count = 4u; count > 0u; count--)
1215   3                  {
1216   4                      while(0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
1217   4                      {
1218   5                          /* Wait for FTW interrupt event */
1219   5                      }
1220   4                  }
1221   3      
1222   3      
1223   3                  /*******************************************************************
1224   3                  * High output indicates an oscillator failure.
1225   3                  * Only can be used after a start-up interval (1 ms) is completed.
1226   3                  *******************************************************************/
1227   3                  if(0u == (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR))
1228   3                  {
1229   4                      status = CYRET_SUCCESS;
1230   4                      break;
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 21  

1231   4                  }
1232   3              }
1233   2      
1234   2      
1235   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
1236   2              if(0u == (iloEnableState & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ))
1237   2              {
1238   3                  CyILO_Stop100K();
1239   3              }
1240   2              CY_LIB_PM_TW_CFG0_REG = pmTwCfg0Tmp;
1241   2              CY_LIB_PM_TW_CFG2_REG = pmTwCfg2Tmp;
1242   2          }
1243   1      
1244   1          return(status);
1245   1      }
1246          
1247          
1248          /*******************************************************************************
1249          * Function Name: CyXTAL_Stop
1250          ****************************************************************************//**
1251          *
1252          *  Disables the megahertz crystal oscillator.
1253          *
1254          *******************************************************************************/
1255          void CyXTAL_Stop(void) 
1256          {
1257   1          /* Disable oscillator. */
1258   1          FASTCLK_XMHZ_CSR &= ((uint8)(~XMHZ_CONTROL_ENABLE));
1259   1      }
1260          
1261          
1262          /*******************************************************************************
1263          * Function Name: CyXTAL_EnableErrStatus
1264          ****************************************************************************//**
1265          *
1266          *  Enables the generation of the XERR status bit for the megahertz crystal.
1267          *  This function is not available for PSoC5.
1268          *
1269          *******************************************************************************/
1270          void CyXTAL_EnableErrStatus(void) 
1271          {
1272   1          /* If oscillator has insufficient amplitude, XERR bit will be high. */
1273   1          CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XFB));
1274   1      }
1275          
1276          
1277          /*******************************************************************************
1278          * Function Name: CyXTAL_DisableErrStatus
1279          ****************************************************************************//**
1280          *
1281          *  Disables the generation of the XERR status bit for the megahertz crystal.
1282          *  This function is not available for PSoC5.
1283          *
1284          *******************************************************************************/
1285          void CyXTAL_DisableErrStatus(void) 
1286          {
1287   1          /* If oscillator has insufficient amplitude, XERR bit will be high. */
1288   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XFB;
1289   1      }
1290          
1291          
1292          /*******************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 22  

1293          * Function Name: CyXTAL_ReadStatus
1294          ****************************************************************************//**
1295          *
1296          *  Reads the XERR status bit for the megahertz crystal. This status bit is a
1297          *  sticky, clear on read. This function is not available for PSoC5.
1298          *
1299          * \return
1300          *   Status
1301          *    0: No error
1302          *    1: Error
1303          *
1304          *******************************************************************************/
1305          uint8 CyXTAL_ReadStatus(void) 
1306          {
1307   1          /***************************************************************************
1308   1          * High output indicates an oscillator failure. Only use this after a start-up
1309   1          * interval is completed. This can be used for the status and failure recovery.
1310   1          ***************************************************************************/
1311   1          return((0u != (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR)) ? 1u : 0u);
1312   1      }
1313          
1314          
1315          /*******************************************************************************
1316          * Function Name: CyXTAL_EnableFaultRecovery
1317          ****************************************************************************//**
1318          *
1319          *  Enables the fault recovery circuit which will switch to the IMO in the case
1320          *  of a fault in the megahertz crystal circuit. The crystal must be up and
1321          *  running with the XERR bit at 0, before calling this function to prevent
1322          *  an immediate fault switchover. This function is not available for PSoC5.
1323          *
1324          *******************************************************************************/
1325          void CyXTAL_EnableFaultRecovery(void) 
1326          {
1327   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XPROT;
1328   1      }
1329          
1330          
1331          /*******************************************************************************
1332          * Function Name: CyXTAL_DisableFaultRecovery
1333          ****************************************************************************//**
1334          *
1335          *  Disables the fault recovery circuit which will switch to the IMO in the case
1336          *  of a fault in the megahertz crystal circuit. This function is not available
1337          *  for PSoC5.
1338          *
1339          *******************************************************************************/
1340          void CyXTAL_DisableFaultRecovery(void) 
1341          {
1342   1          CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XPROT));
1343   1      }
1344          
1345          
1346          /*******************************************************************************
1347          * Function Name: CyXTAL_SetStartup
1348          ****************************************************************************//**
1349          *
1350          *  Sets the startup settings for the crystal. The logic model outputs a
1351          *  frequency (setting + 4) MHz when enabled.
1352          *
1353          *  This is artificial as the actual frequency is determined by an attached
1354          *  external crystal.
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 23  

1355          *
1356          *  \param setting: Valid range [0-31].
1357          *   The value is dependent on the frequency and quality of the crystal being
1358          *   used. Refer to the device TRM and datasheet for more information.
1359          *
1360          *******************************************************************************/
1361          void CyXTAL_SetStartup(uint8 setting) 
1362          {
1363   1          CY_CLK_XMHZ_CFG0_REG = (CY_CLK_XMHZ_CFG0_REG & ((uint8)(~CY_CLK_XMHZ_CFG0_XCFG_MASK))) |
1364   1                                 (setting & CY_CLK_XMHZ_CFG0_XCFG_MASK);
1365   1      }
1366          
1367          
1368          
1369          /*******************************************************************************
1370          * Function Name: CyXTAL_SetFbVoltage
1371          ****************************************************************************//**
1372          *
1373          *  Sets the feedback reference voltage to use for the crystal circuit.
1374          *  This function is only available for PSoC3 and PSoC 5LP.
1375          *
1376          *  \param setting: Valid range [0-15].
1377          *  Refer to the device TRM and datasheet for more information.
1378          *
1379          *******************************************************************************/
1380          void CyXTAL_SetFbVoltage(uint8 setting) 
1381          {
1382   1          CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_FB_MASK))) |
1383   1                                  (setting & CY_CLK_XMHZ_CFG1_VREF_FB_MASK));
1384   1      }
1385          
1386          
1387          /*******************************************************************************
1388          * Function Name: CyXTAL_SetWdVoltage
1389          ****************************************************************************//**
1390          *
1391          *  Sets the reference voltage used by the watchdog to detect a failure in the
1392          *  crystal circuit. This function is only available for PSoC3 and PSoC 5LP.
1393          *
1394          *  \param setting: Valid range [0-7].
1395          *  Refer to the device TRM and datasheet for more information.
1396          *
1397          *******************************************************************************/
1398          void CyXTAL_SetWdVoltage(uint8 setting) 
1399          {
1400   1          CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_WD_MASK))) |
1401   1                                  (((uint8)(setting << 4u)) & CY_CLK_XMHZ_CFG1_VREF_WD_MASK));
1402   1      }
1403          
1404          
1405          /*******************************************************************************
1406          * Function Name: CyHalt
1407          ****************************************************************************//**
1408          *
1409          *  Halts the CPU.
1410          *
1411          *  \param uint8 reason: Value to be used during debugging.
1412          *
1413          *******************************************************************************/
1414          void CyHalt(uint8 reason) CYREENTRANT
1415          {
1416   1          if(0u != reason)
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 24  

1417   1          {
1418   2              /* To remove unreferenced local variable warning */
1419   2          }
1420   1      
1421   1          #if defined (__ARMCC_VERSION)
                      __breakpoint(0x0);
                  #elif defined(__GNUC__) || defined (__ICCARM__)
                      __asm("    bkpt    1");
                  #elif defined(__C51__)
1426   1              CYDEV_HALT_CPU;
1427   1          #endif  /* (__ARMCC_VERSION) */
1428   1      }
1429          
1430          
1431          /*******************************************************************************
1432          * Function Name: CySoftwareReset
1433          ****************************************************************************//**
1434          *
1435          *  Forces a device software reset.
1436          *
1437          *******************************************************************************/
1438          void CySoftwareReset(void) 
1439          {
1440   1          CY_LIB_RESET_CR2_REG |= CY_LIB_RESET_CR2_RESET;
1441   1      }
1442          
1443          
1444          /*******************************************************************************
1445          * Function Name: CyDelay
1446          ****************************************************************************//**
1447          *
1448          *  Blocks for milliseconds.
1449          *
1450          *  Note:
1451          *  CyDelay has been implemented with the instruction cache assumed enabled. When
1452          *  the instruction cache is disabled on PSoC5, CyDelay will be two times larger.
1453          *  For example, with instruction cache disabled CyDelay(100) would result in
1454          *  about 200 ms delay instead of 100 ms.
1455          *
1456          *  \param milliseconds: number of milliseconds to delay.
1457          *
1458          *******************************************************************************/
1459          void CyDelay(uint32 milliseconds) CYREENTRANT
1460          {
1461   1          while (milliseconds > 32768u)
1462   1          {
1463   2              /***********************************************************************
1464   2              * This loop prevents overflow.At 100MHz, milliseconds * delay_freq_khz
1465   2              * overflows at about 42 seconds.
1466   2              ***********************************************************************/
1467   2              CyDelayCycles(cydelay_32k_ms);
1468   2              milliseconds = ((uint32)(milliseconds - 32768u));
1469   2          }
1470   1      
1471   1          CyDelayCycles(milliseconds * cydelay_freq_khz);
1472   1      }
1473          
1474          
1475          #if(!CY_PSOC3)
              
                  /* For PSoC3 devices function is defined in CyBootAsmKeil.a51 file */
              
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 25  

                  /*******************************************************************************
                  * Function Name: CyDelayUs
                  ****************************************************************************//**
                  *
                  *  Blocks for microseconds.
                  *
                  *  Note:
                  *   CyDelay has been implemented with the instruction cache assumed enabled.
                  *   When instruction cache is disabled on PSoC5, CyDelayUs will be two times
                  *   larger. Ex: With instruction cache disabled CyDelayUs(100) would result
                  *   in about 200us delay instead of 100us.
                  *
                  *  \param uint16 microseconds: number of microseconds to delay.
                  *
                  * \sideeffect
                  *  CyDelayUS has been implemented with the instruction cache assumed enabled.
                  *  When the instruction cache is disabled on PSoC 5, CyDelayUs will be two times
                  *  larger. For example, with the instruction cache disabled CyDelayUs(100) would
                  *  result in about 200 us delay instead of 100 us.
                  *
                  *  If the bus clock frequency is a small non-integer number, the actual delay
                  *  can be up to twice as long as the nominal value. The actual delay cannot be
                  *  shorter than the nominal one.
                  *******************************************************************************/
                  void CyDelayUs(uint16 microseconds) CYREENTRANT
                  {
                      CyDelayCycles((uint32)microseconds * cydelay_freq_mhz);
                  }
              
              #endif  /* (!CY_PSOC3) */
1509          
1510          
1511          /*******************************************************************************
1512          * Function Name: CyDelayFreq
1513          ****************************************************************************//**
1514          *
1515          *  Sets the clock frequency for CyDelay.
1516          *
1517          *  \param freq: The frequency of the bus clock in Hertz.
1518          *
1519          *******************************************************************************/
1520          void CyDelayFreq(uint32 freq) CYREENTRANT
1521          {
1522   1          if (freq != 0u)
1523   1          {
1524   2              cydelay_freq_hz = freq;
1525   2          }
1526   1          else
1527   1          {
1528   2              cydelay_freq_hz = BCLK__BUS_CLK__HZ;
1529   2          }
1530   1      
1531   1          cydelay_freq_mhz = (uint8)((cydelay_freq_hz + 999999u) / 1000000u);
1532   1          cydelay_freq_khz = (cydelay_freq_hz + 999u) / 1000u;
1533   1          cydelay_32k_ms   = 32768u * cydelay_freq_khz;
1534   1      }
1535          
1536          
1537          /*******************************************************************************
1538          * Function Name: CyWdtStart
1539          ****************************************************************************//**
1540          *
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 26  

1541          *  Enables the watchdog timer.
1542          *
1543          *  The timer is configured for the specified count interval, the central
1544          *  timewheel is cleared, the setting for the low power mode is configured and
1545          *  the watchdog timer is enabled.
1546          *
1547          *  Once enabled the watchdog cannot be disabled. The watchdog counts each time
1548          *  the Central Time Wheel (CTW) reaches the period specified. The watchdog must
1549          *  be cleared using the CyWdtClear() function before three ticks of the watchdog
1550          *  timer occur. The CTW is free running, so this will occur after between 2 and
1551          *  3 timer periods elapse.
1552          *
1553          *  PSoC5: The watchdog timer should not be used during sleep modes. Since the
1554          *  WDT cannot be disabled after it is enabled, the WDT timeout period can be
1555          *  set to be greater than the sleep wakeup period, then feed the dog on each
1556          *  wakeup from Sleep.
1557          *
1558          *  \param ticks: One of the four available timer periods. Once WDT enabled, the
1559             interval cannot be changed.
1560          *         CYWDT_2_TICKS     -     4 - 6     ms
1561          *         CYWDT_16_TICKS    -    32 - 48    ms
1562          *         CYWDT_128_TICKS   -   256 - 384   ms
1563          *         CYWDT_1024_TICKS  - 2.048 - 3.072 s
1564          *
1565          *  \param lpMode: Low power mode configuration. This parameter is ignored for PSoC 5.
1566          *          The WDT always acts as if CYWDT_LPMODE_NOCHANGE is passed.
1567          *
1568          *          CYWDT_LPMODE_NOCHANGE - No Change
1569          *          CYWDT_LPMODE_MAXINTER - Switch to longest timer mode during low power
1570          *                                 mode
1571          *          CYWDT_LPMODE_DISABLED - Disable WDT during low power mode
1572          *
1573          * \sideeffect
1574          *  PSoC5: The ILO 1 KHz must be enabled for proper WDT operation. Stopping the
1575          *  ILO 1 kHz could break the active WDT functionality.
1576          *
1577          *******************************************************************************/
1578          void CyWdtStart(uint8 ticks, uint8 lpMode) 
1579          {
1580   1          /* Set WDT interval */
1581   1          CY_WDT_CFG_REG = (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_INTERVAL_MASK))) | (ticks & CY_WDT_CFG_INTERVA
             -L_MASK);
1582   1      
1583   1          /* Reset CTW to ensure that first watchdog period is full */
1584   1          CY_WDT_CFG_REG |= CY_WDT_CFG_CTW_RESET;
1585   1          CY_WDT_CFG_REG &= ((uint8)(~CY_WDT_CFG_CTW_RESET));
1586   1      
1587   1          /* Setting low power mode */
1588   1          CY_WDT_CFG_REG = (((uint8)(lpMode << CY_WDT_CFG_LPMODE_SHIFT)) & CY_WDT_CFG_LPMODE_MASK) |
1589   1                             (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_LPMODE_MASK)));
1590   1      
1591   1          /* Enables watchdog reset */
1592   1          CY_WDT_CFG_REG |= CY_WDT_CFG_WDR_EN;
1593   1      }
1594          
1595          
1596          /*******************************************************************************
1597          * Function Name: CyWdtClear
1598          ****************************************************************************//**
1599          *
1600          *  Clears (feeds) the watchdog timer.
1601          *
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 27  

1602          *******************************************************************************/
1603          void CyWdtClear(void) 
1604          {
1605   1          CY_WDT_CR_REG = CY_WDT_CR_FEED;
1606   1      }
1607          
1608          
1609          
1610          /*******************************************************************************
1611          * Function Name: CyVdLvDigitEnable
1612          ****************************************************************************//**
1613          *
1614          *  Sets the voltage trip level, enables the output of the digital low-voltage
1615          *  monitor, and optionally configures voltage monitor to reset device upon the
1616          *  low-voltage event instead of generating an interrupt.
1617          *
1618          *  Note The associated interrupt enable/disable state is not changed by the
1619          *  function. The Interrupt component API should be used to register the
1620          *  interrupt service routine and to enable/disable associated interrupt.
1621          *
1622          *  \param reset: Enables device reset on digital low-voltage event:
1623          *   Zero - Interrupt on digital low-voltage event
1624          *   Non-zero - Reset on digital low-voltage event
1625          *
1626          *  \param threshold: Sets the trip point of the digital low-voltage monitoring circuit
1627          *   in steps of approximately 250 mV in range from 1.70 V (0x00) to 5.45 V
1628          *   (0x0F). For example, the trip point is set to 1.80 V when the threshold
1629          *   parameter value is 0x04. Refer to the device TRM for the exact trip voltage
1630          *   values.
1631          *
1632          * Side Effects and Restrictions:
1633          *  The voltage resets are momentary. When a voltage reset (analog/digital
1634          *  low-voltage and analog high-voltage) occurs, the RESET_CR1 and RESET_CR3
1635          *  registers are restored to their default values. This means that the voltage
1636          *  monitor circuit is no longer enabled and the device exits reset. If the
1637          *  supply is below the trip level and firmware enables the voltage reset
1638          *  functionality, the device will reset again. This will continue as long as the
1639          *  supply is below the trip level or as long as the user enables the reset
1640          *  functionality of the voltage monitor functionality.
1641          *
1642          *  When any voltage reset occurs, the RESET_SR0 and RESET_SR2 status registers
1643          *  are cleared. This means that analog low-voltage, digital low-voltage and
1644          *  analog high-voltage status bits are not persistent across any voltage reset.
1645          *
1646          *******************************************************************************/
1647          void CyVdLvDigitEnable(uint8 reset, uint8 threshold) 
1648          {
1649   1          uint32 intRegTmp;
1650   1          uint8 interruptState;
1651   1      
1652   1          interruptState = CyEnterCriticalSection();
1653   1      
1654   1          /* Store interrupt enable state */
1655   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
1656   1      
1657   1          /* Disable VD interrupt (write 1) to protect against glitches */
1658   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
1659   1      
1660   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1661   1      
1662   1          CY_VD_LVI_TRIP_REG = (threshold & CY_VD_LVI_TRIP_LVID_MASK) |
1663   1                                  (CY_VD_LVI_TRIP_REG & ((uint8)(~CY_VD_LVI_TRIP_LVID_MASK)));
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 28  

1664   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVID_EN;
1665   1      
1666   1          /* Timeout to eliminate glitches on LVI/HVI when enabling (ID # 127412) */
1667   1          CyDelayUs(1u);
1668   1      
1669   1          (void) CyVdStickyStatus(CY_VD_LVID);
1670   1      
1671   1          if(0u != reset)
1672   1          {
1673   2              CY_VD_PRES_CONTROL_REG |= CY_VD_PRESD_EN;
1674   2          }
1675   1          else
1676   1          {
1677   2              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1678   2          }
1679   1      
1680   1          /* Clear pending interrupt */
1681   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
1682   1      
1683   1          /* Restore interrupt enable state */
1684   1          CY_INT_ENABLE_REG = intRegTmp;
1685   1      
1686   1          CyExitCriticalSection(interruptState);
1687   1      }
1688          
1689          
1690          /*******************************************************************************
1691          * Function Name: CyVdLvAnalogEnable
1692          ****************************************************************************//**
1693          *
1694          *  Sets the voltage trip level, enables the output of the analog low-voltage
1695          *  monitor, and optionally configures voltage monitor to reset device upon the
1696          *  low-voltage event instead of generating an interrupt.
1697          *
1698          *  Note The associated interrupt enable/disable state is not changed by the
1699          *  function. The Interrupt component API should be used to register the
1700          *  interrupt service routine and to enable/disable associated interrupt.
1701          *
1702          *  \param reset: Enables device reset on analog low-voltage event:
1703          *  Zero - Interrupt on analog low-voltage event
1704          *  Non-zero - Reset on analog low-voltage event
1705          *
1706          *  \param threshold: Sets the trip point of the analog low-voltage monitoring circuit
1707          *  in steps of approximately 250 mV in range from 1.70 V (0x00) to 5.45 V
1708          *  (0x0F). For example, the trip point is set to 1.80 V when value of the
1709          *  threshold parameter is 0x04. Please refer to the device TRM for the exact
1710          *  trip voltage values.
1711          *
1712          * Side Effects and Restrictions:
1713          *  The voltage resets are momentary. When a voltage reset (analog/digital
1714          *  low-voltage and analog high-voltage) occurs, the RESET_CR1 and RESET_CR3
1715          *  registers are restored to their default values. This means that the voltage
1716          *  monitor circuit is no longer enabled and the device exits reset. If the
1717          *  supply is below the trip level and firmware enables the voltage reset
1718          *  functionality, the device will reset again. This will continue as long as
1719          *  the supply is below the trip level or as long as the user enables the reset
1720          *  functionality of the voltage monitor functionality.
1721          *
1722          *  When any voltage reset occurs, the RESET_SR0 and RESET_SR2 status registers
1723          *  are cleared. This means that analog low-voltage, digital low-voltage and
1724          *  analog high-voltage status bits are not persistent across any voltage reset.
1725          *
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 29  

1726          *******************************************************************************/
1727          void CyVdLvAnalogEnable(uint8 reset, uint8 threshold) 
1728          {
1729   1          uint32 intRegTmp;
1730   1          uint8 interruptState;
1731   1      
1732   1          interruptState = CyEnterCriticalSection();
1733   1      
1734   1          /* Store interrupt enable state */
1735   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
1736   1      
1737   1          /* Disable VD interrupt (write 1) to protect against glitches */
1738   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
1739   1      
1740   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
1741   1      
1742   1          CY_VD_LVI_TRIP_REG = ((uint8)(threshold << 4u)) | (CY_VD_LVI_TRIP_REG & 0x0Fu);
1743   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVIA_EN;
1744   1      
1745   1          /* Timeout to eliminate glitches on LVI/HVI when enabling (ID # 127412) */
1746   1          CyDelayUs(1u);
1747   1      
1748   1          (void) CyVdStickyStatus(CY_VD_LVIA);
1749   1      
1750   1          if(0u != reset)
1751   1          {
1752   2              CY_VD_PRES_CONTROL_REG |= CY_VD_PRESA_EN;
1753   2          }
1754   1          else
1755   1          {
1756   2              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
1757   2          }
1758   1      
1759   1          /* Clear pending interrupt */
1760   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
1761   1      
1762   1          /* Restore interrupt enable state */
1763   1          CY_INT_ENABLE_REG = intRegTmp;
1764   1      
1765   1          CyExitCriticalSection(interruptState);
1766   1      }
1767          
1768          
1769          /*******************************************************************************
1770          * Function Name: CyVdLvDigitDisable
1771          ****************************************************************************//**
1772          *
1773          *  Disables the digital low-voltage monitor, turns off device reset upon the
1774          *  digital low-voltage event, and clears the associated persistent status bit.
1775          *
1776          *  Note The associated interrupt enable/disable state is not changed by the
1777          *  function. The pending interrupt status is not cleared. The Interrupt
1778          *  component API should be used to manipulate with the associated interrupts.
1779          *
1780          *******************************************************************************/
1781          void CyVdLvDigitDisable(void) 
1782          {
1783   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVID_EN));
1784   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1785   1          (void) CyVdStickyStatus(CY_VD_LVID);
1786   1      
1787   1          while(0u != (CyVdStickyStatus(CY_VD_LVID) & CY_VD_LVID))
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 30  

1788   1          {
1789   2      
1790   2          }
1791   1      }
1792          
1793          
1794          /*******************************************************************************
1795          * Function Name: CyVdLvAnalogDisable
1796          ****************************************************************************//**
1797          *
1798          *  Disables the analog low-voltage monitor, turns off device reset upon the
1799          *  analog low-voltage event, and clears the associated persistent status bit.
1800          *
1801          *  Note The associated interrupt enable/disable state is not changed by the
1802          *  function. The pending interrupt status is not cleared. The Interrupt
1803          *  component API should be used to manipulate with the associated interrupts.
1804          *
1805          *******************************************************************************/
1806          void CyVdLvAnalogDisable(void) 
1807          {
1808   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVIA_EN));
1809   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
1810   1          while(0u != (CyVdStickyStatus(CY_VD_LVIA) & CY_VD_LVIA))
1811   1          {
1812   2      
1813   2          }
1814   1      }
1815          
1816          
1817          /*******************************************************************************
1818          * Function Name: CyVdHvAnalogEnable
1819          ****************************************************************************//**
1820          *
1821          *  Enables the output of the analog high-voltage monitor and sets 5.75 V
1822          *  threshold detection for Vdda.
1823          *
1824          *  Note The associated interrupt enable/disable state is not changed by the
1825          *  function. The Interrupt component API should be used to register the
1826          *  interrupt service routine and to enable/disable associated interrupt.
1827          *
1828          *******************************************************************************/
1829          void CyVdHvAnalogEnable(void) 
1830          {
1831   1          uint32 intRegTmp;
1832   1          uint8 interruptState;
1833   1      
1834   1          interruptState = CyEnterCriticalSection();
1835   1      
1836   1          /* Store interrupt enable state */
1837   1          intRegTmp = CY_INT_ENABLE_REG & CY_VD_INT_MASK;
1838   1      
1839   1          /* Disable VD interrupt (write 1) to protect against glitches */
1840   1          CY_INT_CLEAR_REG = CY_VD_INT_MASK;
1841   1      
1842   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
1843   1      
1844   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_HVIA_EN;
1845   1      
1846   1          /* Timeout to eliminate glitches on the LVI/HVI when enabling (ID # 127412)  */
1847   1          CyDelayUs(1u);
1848   1      
1849   1          (void) CyVdStickyStatus(CY_VD_HVIA);
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 31  

1850   1      
1851   1          /* Clear pending interrupt */
1852   1          CY_INT_CLR_PEND_REG = CY_VD_INT_MASK;
1853   1      
1854   1          /* Restore interrupt enable state */
1855   1          CY_INT_ENABLE_REG = intRegTmp;
1856   1      
1857   1          CyExitCriticalSection(interruptState);
1858   1      }
1859          
1860          
1861          /*******************************************************************************
1862          * Function Name: CyVdHvAnalogDisable
1863          ****************************************************************************//**
1864          *
1865          *  Disables the analog high-voltage monitor and clears the associated persistent
1866          *  status bit.
1867          *
1868          *  Note The associated interrupt enable/disable state is not changed by the
1869          *  function. The pending interrupt status is not cleared. The Interrupt
1870          *  component API should be used to manipulate with the associated interrupts.
1871          *
1872          *******************************************************************************/
1873          void CyVdHvAnalogDisable(void) 
1874          {
1875   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_HVIA_EN));
1876   1          while(0u != (CyVdStickyStatus(CY_VD_HVIA) & CY_VD_HVIA))
1877   1          {
1878   2      
1879   2          }
1880   1      }
1881          
1882          
1883          /*******************************************************************************
1884          * Function Name: CyVdStickyStatus
1885          ****************************************************************************//**
1886          *
1887          *  Reads and clears the voltage detection status bits in the RESET_SR0 register.
1888          *  The bits are set to 1 by the voltage monitor circuit when the supply is
1889          *  outside the detector trip point. They stay set to 1 until they are read or
1890          *  a POR / LVI / PRES reset occurs. This function uses a shadow register, so
1891          *  only the bits passed in the parameter will be cleared in the shadow register.
1892          *
1893          *  \param mask: Bits in the RESET_SR0 shadow register to clear and return.
1894          *   Define                  Definition
1895          *   CY_VD_LVID            Persistent status of digital LVI.
1896          *   CY_VD_LVIA            Persistent status of analog LVI.
1897          *   CY_VD_HVIA            Persistent status of analog HVI.
1898          *
1899          * \return
1900          *  Status. Same enumerated bit values as used for the mask parameter. A zero is
1901          *  returned for bits not used in the mask parameter.
1902          *
1903          * Side Effects and Restrictions:
1904          *  When an LVI reset occurs, the RESET_SR0 status registers are cleared. This
1905          *  means that the voltage detection status bits are not persistent across an LVI
1906          *  reset and cannot be used to determine a reset source.
1907          *
1908          *******************************************************************************/
1909          uint8 CyVdStickyStatus(uint8 mask) 
1910          {
1911   1          static uint8 interruptStatus;
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 32  

1912   1          uint8 interruptState;
1913   1          uint8 tmpStatus;
1914   1      
1915   1          interruptState = CyEnterCriticalSection();
1916   1      
1917   1          interruptStatus |= CY_VD_PERSISTENT_STATUS_REG;
1918   1          tmpStatus = interruptStatus & (uint8)(CY_VD_LVID | CY_VD_LVIA | CY_VD_HVIA);
1919   1          interruptStatus &= ((uint8)(~mask));
1920   1      
1921   1          CyExitCriticalSection(interruptState);
1922   1      
1923   1          return(tmpStatus);
1924   1      }
1925          
1926          
1927          /*******************************************************************************
1928          * Function Name: CyVdRealTimeStatus
1929          ****************************************************************************//**
1930          *
1931          *  Reads the real-time voltage detection status bits in the RESET_SR2 register.
1932          *  The bits are set to 1 by the voltage monitor circuit when the supply is
1933          *  outside the detectors trip point, and set to 0 when the supply is inside the
1934          *  trip point.
1935          *
1936          * \return
1937          *  Status of the LVID, LVIA, and HVIA bits in the RESET_SR2 register.
1938          *   Define                  Definition
1939          *   CY_VD_LVID            Real-time status of digital LVI.
1940          *   CY_VD_LVIA            Real-time status of analog LVI.
1941          *   CY_VD_HVIA            Real-time status of analog HVI.
1942          *
1943          * Side Effects and Restrictions:
1944          *  When an LVI reset occurs, the RESET_SR2 status registers are cleared. This
1945          *  means that the voltage detection status bits are not persistent across an LVI
1946          *  reset and cannot be used to determine a reset source.
1947          *
1948          *******************************************************************************/
1949          uint8 CyVdRealTimeStatus(void) 
1950          {
1951   1          uint8 interruptState;
1952   1          uint8 vdFlagsState;
1953   1      
1954   1          interruptState = CyEnterCriticalSection();
1955   1          vdFlagsState = CY_VD_RT_STATUS_REG & (CY_VD_LVID | CY_VD_LVIA | CY_VD_HVIA);
1956   1          CyExitCriticalSection(interruptState);
1957   1      
1958   1          return(vdFlagsState);
1959   1      }
1960          
1961          
1962          /*******************************************************************************
1963          * Function Name: CyDisableInts
1964          ****************************************************************************//**
1965          *
1966          *  Disables the interrupt enable for each interrupt.
1967          *
1968          * \return
1969          *  32 bit mask of previously enabled interrupts.
1970          *
1971          *******************************************************************************/
1972          uint32 CyDisableInts(void) 
1973          {
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 33  

1974   1          uint32 intState;
1975   1          uint8 interruptState;
1976   1      
1977   1          interruptState = CyEnterCriticalSection();
1978   1      
1979   1          #if(CY_PSOC3)
1980   1      
1981   1              /* Get the current interrupt state. */
1982   1              intState  = ((uint32) CY_GET_REG8(CY_INT_CLR_EN0_PTR));
1983   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN1_PTR)) << 8u));
1984   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN2_PTR)) << 16u));
1985   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN3_PTR)) << 24u));
1986   1      
1987   1      
1988   1              /* Disable all of the interrupts. */
1989   1              CY_SET_REG8(CY_INT_CLR_EN0_PTR, 0xFFu);
1990   1              CY_SET_REG8(CY_INT_CLR_EN1_PTR, 0xFFu);
1991   1              CY_SET_REG8(CY_INT_CLR_EN2_PTR, 0xFFu);
1992   1              CY_SET_REG8(CY_INT_CLR_EN3_PTR, 0xFFu);
1993   1      
1994   1          #else
              
                      /* Get the current interrupt state. */
                      intState = CY_GET_REG32(CY_INT_CLEAR_PTR);
              
                      /* Disable all of the interrupts. */
                      CY_SET_REG32(CY_INT_CLEAR_PTR, 0xFFFFFFFFu);
              
                  #endif /* (CY_PSOC3) */
2003   1      
2004   1          CyExitCriticalSection(interruptState);
2005   1      
2006   1          return (intState);
2007   1      }
2008          
2009          
2010          /*******************************************************************************
2011          * Function Name: CyEnableInts
2012          ****************************************************************************//**
2013          *
2014          *  Enables interrupts to a given state.
2015          *
2016          *  \param uint32 mask: 32 bit mask of interrupts to enable.
2017          *
2018          *******************************************************************************/
2019          void CyEnableInts(uint32 mask) 
2020          {
2021   1      
2022   1          uint8 interruptState;
2023   1      
2024   1          interruptState = CyEnterCriticalSection();
2025   1      
2026   1          #if(CY_PSOC3)
2027   1      
2028   1              /* Set interrupts as enabled. */
2029   1              CY_SET_REG8(CY_INT_SET_EN3_PTR, ((uint8) (mask >> 24u)));
2030   1              CY_SET_REG8(CY_INT_SET_EN2_PTR, ((uint8) (mask >> 16u)));
2031   1              CY_SET_REG8(CY_INT_SET_EN1_PTR, ((uint8) (mask >> 8u )));
2032   1              CY_SET_REG8(CY_INT_SET_EN0_PTR, ((uint8) (mask )));
2033   1      
2034   1          #else
              
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 34  

                      CY_SET_REG32(CY_INT_ENABLE_PTR, mask);
              
                  #endif /* (CY_PSOC3) */
2039   1      
2040   1          CyExitCriticalSection(interruptState);
2041   1      
2042   1      }
2043          
2044          #if(CY_PSOC5)
              
                  /*******************************************************************************
                  * Function Name: CyFlushCache
                  ****************************************************************************//**
                  *  Call this API after a flash row erase/write operation to invalidate or flush
                  *  any of that particular flash region content already present in the cache.
                  *  After a cache flush operation, any access to that flash region after the
                  *  erase/write operation would reload the cache with the modified data from the
                  *  flash region. If the flash region update involves multiple flash row write
                  *  operations, then the flushing of the cache can be done once at the end of
                  *  the operation as long as the flash data would not be accessed in the middle
                  *  of the multiple row update process. Else, flush the cache after every flash
                  *  row write.
                  *
                  *******************************************************************************/
                  void CyFlushCache(void)
                  {
                      uint8 interruptState;
              
                      /* Save current global interrupt enable and disable it */
                      interruptState = CyEnterCriticalSection();
              
                      /* Fill instruction prefectch unit to insure data integrity */
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
              
                      /* All entries in cache are invalidated on next clock cycle. */
                      CY_CACHE_CONTROL_REG |= CY_CACHE_CONTROL_FLUSH;
              
                      /* Once this is executed it's guaranteed the cache has been flushed */
                      (void) CY_CACHE_CONTROL_REG;
              
                      /* Flush the pipeline */
                      CY_SYS_ISB;
              
                      /* Restore global interrupt enable state */
                      CyExitCriticalSection(interruptState);
                  }
              
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 35  

              
                  /*******************************************************************************
                  * Function Name: CyIntSetSysVector
                  ****************************************************************************//**
                  *  Sets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  *  \param number: System interrupt number:
                  *    CY_INT_NMI_IRQN                - Non Maskable Interrupt
                  *    CY_INT_HARD_FAULT_IRQN         - Hard Fault Interrupt
                  *    CY_INT_MEM_MANAGE_IRQN         - Memory Management Interrupt
                  *    CY_INT_BUS_FAULT_IRQN          - Bus Fault Interrupt
                  *    CY_INT_USAGE_FAULT_IRQN        - Usage Fault Interrupt
                  *    CY_INT_SVCALL_IRQN             - SV Call Interrupt
                  *    CY_INT_DEBUG_MONITOR_IRQN      - Debug Monitor Interrupt
                  *    CY_INT_PEND_SV_IRQN            - Pend SV Interrupt
                  *    CY_INT_SYSTICK_IRQN            - System Tick Interrupt
                  *
                  *  \param address: Pointer to an interrupt service routine.
                  *
                  * \return
                  *   The old ISR vector at this location.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetSysVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[number & CY_INT_SYS_NUMBER_MASK] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetSysVector
                  ****************************************************************************//**
                  *
                  *  Gets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  *  \param number: System interrupt number:
                  *    CY_INT_NMI_IRQN                - Non Maskable Interrupt
                  *    CY_INT_HARD_FAULT_IRQN         - Hard Fault Interrupt
                  *    CY_INT_MEMORY_MANAGEMENT_IRQN  - Memory Management Interrupt
                  *    CY_INT_BUS_FAULT_IRQN          - Bus Fault Interrupt
                  *    CY_INT_USAGE_FAULT_IRQN        - Usage Fault Interrupt
                  *    CY_INT_SVCALL_IRQN             - SV Call Interrupt
                  *    CY_INT_DEBUG_MONITOR_IRQN      - Debug Monitor Interrupt
                  *    CY_INT_PEND_SV_IRQN            - Pend SV Interrupt
                  *    CY_INT_SYSTICK_IRQN            - System Tick Interrupt
                  *
                  * \return
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 36  

                  *   Address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetSysVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      return ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetVector
                  ****************************************************************************//**
                  *
                  *  Sets the interrupt vector of the specified interrupt number.
                  *
                  *  \param number: Valid range [0-31].  Interrupt number
                  *  \param address: Pointer to an interrupt service routine
                  *
                  * \return
                  *   Previous interrupt vector value.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetVector
                  ****************************************************************************//**
                  *
                  *  Gets the interrupt vector of the specified interrupt number.
                  *
                  *  \param number: Valid range [0-31].  Interrupt number
                  *
                  * \return
                  *  The address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      return (ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)]);
                  }
              
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 37  

              
                  /*******************************************************************************
                  * Function Name: CyIntSetPriority
                  ****************************************************************************//**
                  *
                  *  Sets the Priority of the Interrupt.
                  *
                  *  \param priority: Priority of the interrupt. 0 - 7, 0 being the highest.
                  *  \param number: The number of the interrupt, 0 - 31.
                  *
                  *******************************************************************************/
                  void CyIntSetPriority(uint8 number, uint8 priority)
                  {
                      CYASSERT(priority <= CY_INT_PRIORITY_MAX);
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
                      CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] = (priority & CY_INT_PRIORITY_MASK)<< 5;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetPriority
                  ****************************************************************************//**
                  *
                  *  Gets the Priority of the Interrupt.
                  *
                  *  \param number: The number of the interrupt, 0 - 31.
                  *
                  * \return
                  *  Priority of the interrupt. 0 - 7, 0 being the highest.
                  *
                  *******************************************************************************/
                  uint8 CyIntGetPriority(uint8 number)
                  {
                      uint8 priority;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
              
                      return (priority);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetState
                  ****************************************************************************//**
                  *
                  *   Gets the enable state of the specified interrupt number.
                  *
                  *   \param number: Valid range [0-31].  Interrupt number.
                  *
                  * \return
                  *   Enable status: 1 if enabled, 0 if disabled
                  *
                  *******************************************************************************/
                  uint8 CyIntGetState(uint8 number)
                  {
                      reg32 * stateReg;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Get pointer to Interrupt enable register. */
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 38  

                      stateReg = CY_INT_ENABLE_PTR;
              
                      /* Get state of interrupt. */
                      return (0u != (*stateReg & (((uint32) 1u) << (0x1Fu & number)))) ? ((uint8)(1u)) : ((uint8)(0u));
                  }
              
              
              #else   /* PSoC3 */
2292          
2293              /*******************************************************************************
2294              * Function Name: IntDefaultHandler
2295              ****************************************************************************//**
2296              *
2297              *  This function is called for all interrupts, other than a reset that gets
2298              *  called before the system is setup.
2299              *
2300              * Theory:
2301              *  Any value other than zero is acceptable.
2302              *
2303              *******************************************************************************/
2304              CY_ISR(IntDefaultHandler)
2305              {
2306   1              #ifdef CY_BOOT_INT_DEFAULT_HANDLER_EXCEPTION_ENTRY_CALLBACK
                          CyBoot_IntDefaultHandler_Exception_EntryCallback();
                      #endif /* CY_BOOT_INT_DEFAULT_HANDLER_EXCEPTION_ENTRY_CALLBACK */
2309   1      
2310   1              while(1)
2311   1              {
2312   2                  /***********************************************************************
2313   2                  * We must not get here. If we do, a serious problem occurs, so go
2314   2                  * into an infinite loop.
2315   2                  ***********************************************************************/
2316   2              }
2317   1          }
2318          
2319          
2320              /*******************************************************************************
2321              * Function Name: IntDefaultHandler
2322              ****************************************************************************//**
2323              *
2324              *  This function is called during startup to initialize interrupt address vector
2325              *  registers with the address of the IntDefaultHandler().
2326              *
2327              *******************************************************************************/
2328              void CyIntInitVectors(void) 
2329              {
2330   1              uint8 i;
2331   1      
2332   1              for (i = 0; i <= CY_INT_NUMBER_MAX; i++)
2333   1              {
2334   2                  CY_SET_REG16(&CY_INT_VECT_TABLE[i], (uint16) &IntDefaultHandler);
2335   2              }
2336   1          }
2337          
2338          
2339              /*******************************************************************************
2340              * Function Name: CyIntSetVector
2341              ****************************************************************************//**
2342              *
2343              *  Sets the interrupt vector of the specified interrupt number.
2344              *
2345              *  \param number:  Valid range [0-31].  Interrupt number
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 39  

2346              *  \param address: Pointer to an interrupt service routine
2347              *
2348              * \return
2349              *  Previous interrupt vector value.
2350              *
2351              *******************************************************************************/
2352              cyisraddress CyIntSetVector(uint8 number, cyisraddress address) 
2353              {
2354   1              cyisraddress oldIsr;
2355   1      
2356   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2357   1      
2358   1              /* Save old Interrupt service routine. */
2359   1              oldIsr = (cyisraddress) \
2360   1                          CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]);
2361   1      
2362   1              /* Set new Interrupt service routine. */
2363   1              CY_SET_REG16(&CY_INT_VECT_TABLE[number], (uint16) address);
2364   1      
2365   1              return (oldIsr);
2366   1          }
2367          
2368          
2369              /*******************************************************************************
2370              * Function Name: CyIntGetVector
2371              ****************************************************************************//**
2372              *
2373              *  Gets the interrupt vector of the specified interrupt number.
2374              *
2375              *  \param number: Valid range [0-31].  Interrupt number
2376              *
2377              * \return
2378              *  Address of the ISR in the interrupt vector table.
2379              *
2380              *******************************************************************************/
2381              cyisraddress CyIntGetVector(uint8 number) 
2382              {
2383   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2384   1      
2385   1              return ((cyisraddress) \
2386   1                      CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]));
2387   1          }
2388          
2389          
2390              /*******************************************************************************
2391              * Function Name: CyIntSetPriority
2392              ****************************************************************************//**
2393              *
2394              *  Sets the Priority of the Interrupt.
2395              *
2396              *  \param priority: Priority of the interrupt. 0 - 7, 0 being the highest.
2397              *  \param number:   The number of the interrupt, 0 - 31.
2398              *
2399              *******************************************************************************/
2400              void CyIntSetPriority(uint8 number, uint8 priority) 
2401              {
2402   1              CYASSERT(priority <= CY_INT_PRIORITY_MAX);
2403   1      
2404   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2405   1      
2406   1              CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] =
2407   1                          (priority & CY_INT_PRIORITY_MASK) << 5;
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 40  

2408   1          }
2409          
2410          
2411              /*******************************************************************************
2412              * Function Name: CyIntGetPriority
2413              ****************************************************************************//**
2414              *
2415              *  Gets the Priority of the Interrupt.
2416              *
2417              *  \param number: The number of the interrupt, 0 - 31.
2418              *
2419              * \return
2420              *  Priority of the interrupt. 0 - 7, 0 being the highest.
2421              *
2422              *******************************************************************************/
2423              uint8 CyIntGetPriority(uint8 number) 
2424              {
2425   1              uint8 priority;
2426   1      
2427   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2428   1      
2429   1              priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
2430   1      
2431   1              return (priority);
2432   1          }
2433          
2434          
2435              /*******************************************************************************
2436              * Function Name: CyIntGetState
2437              ****************************************************************************//**
2438              *
2439              *   Gets the enable state of the specified interrupt number.
2440              *
2441              *   \param number: Valid range [0-31].  Interrupt number.
2442              *
2443              * \return
2444              *   Enable status: 1 if enabled, 0 if disabled
2445              *
2446              *******************************************************************************/
2447              uint8 CyIntGetState(uint8 number) 
2448              {
2449   1              reg8 * stateReg;
2450   1      
2451   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2452   1      
2453   1              /* Get pointer to Interrupt enable register. */
2454   1              stateReg = CY_INT_ENABLE_PTR + ((number & CY_INT_NUMBER_MASK) >> 3u);
2455   1      
2456   1              /* Get state of interrupt. */
2457   1              return ((0u != (*stateReg & ((uint8)(1u << (0x07u & number))))) ? ((uint8)(1u)) : ((uint8)(0u)));
2458   1          }
2459          
2460          #endif  /* (CY_PSOC5) */
2461          
2462          
2463          #if(CYDEV_VARIABLE_VDDA == 1)
              
                  /*******************************************************************************
                  * Function Name: CySetScPumps
                  ****************************************************************************//**
                  *
                  *  If 1 is passed as a parameter:
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 41  

                  *   - if any of the SC blocks are used - enable pumps for the SC blocks and
                  *     start boost clock.
                  *   - For each enabled SC block set a boost clock index and enable the boost
                  *     clock.
                  *
                  *  If non-1 value is passed as a parameter:
                  *   - If all SC blocks are not used - disable pumps for the SC blocks and
                  *     stop the boost clock.
                  *   - For each enabled SC block clear the boost clock index and disable the
                  *     boost clock.
                  *
                  *  The global variable CyScPumpEnabled is updated to be equal to passed the
                  *  parameter.
                  *
                  *   \param uint8 enable: Enable/disable SC pumps and the boost clock for the enabled
                  *                 \param SC block:
                  *                 1 - Enable
                  *                 0 - Disable
                  *
                  *******************************************************************************/
                  void CySetScPumps(uint8 enable) 
                  {
                      if(1u == enable)
                      {
                          /* The SC pumps should be enabled */
                          CyScPumpEnabled = 1u;
                          /* Enable pumps if any of SC blocks are used */
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAPS_MASK))
                          {
                              CY_LIB_SC_MISC_REG |= CY_LIB_SC_MISC_PUMP_FORCE;
                              CyScBoostClk_Start();
                          }
                          /* Set positive pump for each enabled SC block: set clock index and enable it */
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP0_EN))
                          {
                              CY_LIB_SC0_BST_REG = (CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC0_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP1_EN))
                          {
                              CY_LIB_SC1_BST_REG = (CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC1_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP2_EN))
                          {
                              CY_LIB_SC2_BST_REG = (CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC2_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP3_EN))
                          {
                              CY_LIB_SC3_BST_REG = (CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC3_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                      }
                      else
                      {
                          /* The SC pumps should be disabled */
                          CyScPumpEnabled = 0u;
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 42  

                          /* Disable pumps for all SC blocks and stop boost clock */
                          CY_LIB_SC_MISC_REG &= ((uint8)(~CY_LIB_SC_MISC_PUMP_FORCE));
                          CyScBoostClk_Stop();
                          /* Disable boost clock and clear clock index for each SC block */
                          CY_LIB_SC0_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC0_BST_REG = CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC1_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC1_BST_REG = CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC2_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC2_BST_REG = CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC3_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC3_BST_REG = CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                      }
                  }
              
              #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
2544          
2545          
2546          #if(CY_PSOC5)
                  /*******************************************************************************
                  * Function Name: CySysTickStart
                  ****************************************************************************//**
                  *
                  *  Configures the SysTick timer to generate interrupt every 1 ms by call to the
                  *  CySysTickInit() function and starts it by calling CySysTickEnable() function.
                  *  Refer to the corresponding function description for the details.
              
                  * \sideeffect
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickStart(void)
                  {
                      if (0u == CySysTickInitVar)
                      {
                          CySysTickInit();
                          CySysTickInitVar = 1u;
                      }
              
                      CySysTickEnable();
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickInit
                  ****************************************************************************//**
                  *
                  *  Initializes the callback addresses with pointers to NULL, associates the
                  *  SysTick system vector with the function that is responsible for calling
                  *  registered callback functions, configures SysTick timer to generate interrupt
                  * every 1 ms.
                  *
                  * \sideeffect
                  *  Clears SysTick count flag if it was set.
                  *
                  *  The 1 ms interrupt interval is configured based on the frequency determined
                  *  by PSoC Creator at build time. If System clock frequency is changed in
                  *  runtime, the CyDelayFreq() with the appropriate parameter should be called.
                  *
                  *******************************************************************************/
                  void CySysTickInit(void)
                  {
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 43  

                      uint32 i;
              
                      for (i = 0u; i<CY_SYS_SYST_NUM_OF_CALLBACKS; i++)
                      {
                          CySysTickCallbacks[i] = (void *) 0;
                      }
              
                      (void) CyIntSetSysVector(CY_INT_SYSTICK_IRQN, &CySysTickServiceCallbacks);
                      CySysTickSetClockSource(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK);
                      CySysTickSetReload(cydelay_freq_hz/1000u);
                      CySysTickClear();
                      CyIntEnable(CY_INT_SYSTICK_IRQN);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickEnable
                  ****************************************************************************//**
                  *
                  *  Enables the SysTick timer and its interrupt.
                  *
                  * \sideeffect
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickEnable(void)
                  {
                      CySysTickEnableInterrupt();
                      CY_SYS_SYST_CSR_REG |= CY_SYS_SYST_CSR_ENABLE;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickStop
                  ****************************************************************************//**
                  *
                  *  Stops the system timer (SysTick).
                  *
                  * \sideeffect
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickStop(void)
                  {
                      CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_ENABLE));
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickEnableInterrupt
                  ****************************************************************************//**
                  *
                  *  Enables the SysTick interrupt.
                  *
                  * \sideeffect
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickEnableInterrupt(void)
                  {
                      CY_SYS_SYST_CSR_REG |= CY_SYS_SYST_CSR_ENABLE_INT;
                  }
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 44  

              
              
                  /*******************************************************************************
                  * Function Name: CySysTickDisableInterrupt
                  ****************************************************************************//**
                  *
                  *  Disables the SysTick interrupt.
                  *
                  * \sideeffect
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickDisableInterrupt(void)
                  {
                      CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_ENABLE_INT));
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetReload
                  ****************************************************************************//**
                  *
                  *  Sets value the counter is set to on startup and after it reaches zero. This
                  *  function do not change or reset current sysTick counter value, so it should
                  *  be cleared using CySysTickClear() API.
                  *
                  *  \param value: Valid range [0x0-0x00FFFFFF]. Counter reset value.
                  *
                  *******************************************************************************/
                  void CySysTickSetReload(uint32 value)
                  {
                      CY_SYS_SYST_RVR_REG = (value & CY_SYS_SYST_RVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetReload
                  ****************************************************************************//**
                  *
                  *  Sets value the counter is set to on startup and after it reaches zero.
                  *
                  * \return
                  *  Counter reset value
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetReload(void)
                  {
                      return(CY_SYS_SYST_RVR_REG & CY_SYS_SYST_RVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetValue
                  ****************************************************************************//**
                  *
                  *  Gets current SysTick counter value.
                  *
                  * \return
                  *  Current SysTick counter value
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetValue(void)
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 45  

                  {
                      return(CY_SYS_SYST_CVR_REG & CY_SYS_SYST_CVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetClockSource
                  ****************************************************************************//**
                  *
                  *  Sets the clock source for the SysTick counter.
                  *
                  *  \param clockSource: Clock source for SysTick counter
                  *         Define                     Clock Source
                  *   CY_SYS_SYST_CSR_CLK_SRC_SYSCLK     SysTick is clocked by CPU clock.
                  *   CY_SYS_SYST_CSR_CLK_SRC_LFCLK      SysTick is clocked by the low frequency
                  *                                      clock (ILO 100 KHz for PSoC 5LP, and
                  *                                      LFCLK for PSoC 4).
                  *
                  * \sideeffect
                  *  Clears SysTick count flag if it was set. If clock source is not ready this
                  *  function call will have no effect. After changing clock source to the low
                  *  frequency clock the counter and reload register values will remain unchanged
                  *  so time to the interrupt will be significantly bigger and vice versa.
                  *
                  *******************************************************************************/
                  void CySysTickSetClockSource(uint32 clockSource)
                  {
                      if (clockSource == CY_SYS_SYST_CSR_CLK_SRC_SYSCLK)
                      {
                          CY_SYS_SYST_CSR_REG |= (uint32)(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK << CY_SYS_SYST_CSR_CLK_SOURCE_S
             -HIFT);
                      }
                      else
                      {
                          CY_SYS_SYST_CSR_REG &= ((uint32) ~((uint32)(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK << CY_SYS_SYST_CSR_
             -CLK_SOURCE_SHIFT)));
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetCountFlag
                  ****************************************************************************//**
                  *
                  *  The count flag is set once SysTick counter reaches zero.
                  *   The flag cleared on read.
                  *
                  * \return
                  *  Returns non-zero value if flag is set, otherwise zero is returned.
                  *
                  *
                  * \sideeffect
                  *  Clears SysTick count flag if it was set.
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetCountFlag(void)
                  {
                      return ((CY_SYS_SYST_CSR_REG >> CY_SYS_SYST_CSR_COUNTFLAG_SHIFT) & 0x01u);
                  }
              
              
                  /*******************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 46  

                  * Function Name: CySysTickClear
                  ****************************************************************************//**
                  *
                  *  Clears the SysTick counter for well-defined startup.
                  *
                  *******************************************************************************/
                  void CySysTickClear(void)
                  {
                      CY_SYS_SYST_CVR_REG = 0u;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetCallback
                  ****************************************************************************//**
                  *
                  *  This function allows up to five user-defined interrupt service routine
                  *  functions to be associated with the SysTick interrupt. These are specified
                  *  through the use of pointers to the function.
                  *
                  *  To set a custom callback function without the overhead of the system provided
                  *  one, use CyIntSetSysVector(CY_INT_SYSTICK_IRQN, cyisraddress <address>),
                  *  where <address> is address of the custom defined interrupt service routine.
                  *  Note: a custom callback function overrides the system defined callback
                  *  functions.
                  *
                  *  \param number: The number of the callback function addresses to be set. The valid
                  *          range is from 0 to 4.
                  *
                  *  void(*CallbackFunction(void): A pointer to the function that will be
                  *                                associated with the SysTick ISR for the
                  *                                specified number.
                  *
                  * \return
                  *  Returns the address of the previous callback function.
                  *  The NULL is returned if the specified address in not set.
                  *
                  * \sideeffect
                  *  The registered callback functions will be executed in the interrupt.
                  *
                  *******************************************************************************/
                  cySysTickCallback CySysTickSetCallback(uint32 number, cySysTickCallback function)
                  {
                      cySysTickCallback retVal;
              
                      retVal = CySysTickCallbacks[number];
                      CySysTickCallbacks[number] = function;
                      return (retVal);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetCallback
                  ****************************************************************************//**
                  *
                  *  The function get the specified callback pointer.
                  *
                  *  \param number: The number of callback function address to get. The valid
                  *          range is from 0 to 4.
                  *
                  * \return
                  *  Returns the address of the specified callback function.
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 47  

                  *  The NULL is returned if the specified address in not initialized.
                  *
                  *******************************************************************************/
                  cySysTickCallback CySysTickGetCallback(uint32 number)
                  {
                      return ((cySysTickCallback) CySysTickCallbacks[number]);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickServiceCallbacks
                  ****************************************************************************//**
                  *
                  *  System Tick timer interrupt routine
                  *
                  *******************************************************************************/
                  static void CySysTickServiceCallbacks(void)
                  {
                      uint32 i;
              
                      /* Verify that tick timer flag was set */
                      if (1u == CySysTickGetCountFlag())
                      {
                          for (i=0u; i < CY_SYS_SYST_NUM_OF_CALLBACKS; i++)
                          {
                              if (CySysTickCallbacks[i] != (void *) 0)
                              {
                                  (void)(CySysTickCallbacks[i])();
                              }
                          }
                      }
                  }
              #endif /* (CY_PSOC5) */
2869          
2870          
2871          /*******************************************************************************
2872          * Function Name: CyGetUniqueId
2873          ****************************************************************************//**
2874          *
2875          *  Returns the 64-bit unique ID of the device. The uniqueness of the number is
2876          *  guaranteed for 10 years due to the die lot number having a cycle life of 10
2877          *  years and even after 10 years, the probability of getting two identical
2878          *  numbers is very small.
2879          *
2880          *  \param uniqueId: The pointer to a two element 32-bit unsigned integer array. Returns
2881          *  the 64-bit unique ID of the device by loading them into the integer array
2882          *  pointed to by uniqueId.
2883          *
2884          *******************************************************************************/
2885          void CyGetUniqueId(uint32* uniqueId)
2886          {
2887   1      #if(CY_PSOC4)
                  uniqueId[0u]  =  (uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT0  );
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT1  ) <<  8u);
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_LOT2  ) << 16u);
                  uniqueId[0u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_WAFER ) << 24u);
              
                  uniqueId[1u]  =  (uint32)(* (reg8 *) CYREG_SFLASH_DIE_X     );
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_Y     ) <<  8u);
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_SORT  ) << 16u);
                  uniqueId[1u] |= ((uint32)(* (reg8 *) CYREG_SFLASH_DIE_MINOR ) << 24u);
              #else
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 48  

2898   1          uniqueId[0u]  =  (uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_LOT_LSB   ));
2899   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_LOT_MSB   )) <<  8
             -u);
2900   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_MLOGIC_REV_ID                )) << 16
             -u);
2901   1          uniqueId[0u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_WAFER_NUM )) << 24
             -u);
2902   1      
2903   1          uniqueId[1u]  =  (uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_X_LOC     ));
2904   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_Y_LOC     )) <<  8
             -u);
2905   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_WRK_WK    )) << 16
             -u);
2906   1          uniqueId[1u] |= ((uint32) CY_GET_XTND_REG8((void CYFAR *) (CYREG_FLSHID_CUST_TABLES_FAB_YR    )) << 24
             -u);
2907   1      #endif  /* (CY_PSOC4) */
2908   1      }
2909          
2910          /* [] END OF FILE */
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 49  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _CyPLL_OUT_Start (BEGIN)
                                           ; SOURCE LINE # 97
;---- Variable 'wait' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 98
                                           ; SOURCE LINE # 99
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#status
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 107
0005 904220            MOV     DPTR,#04220H
0008 E0                MOVX    A,@DPTR
0009 4401              ORL     A,#01H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 109
000C EF                MOV     A,R7
000D 6059              JZ      ?C0001
                                           ; SOURCE LINE # 110
                                           ; SOURCE LINE # 112
000F 904300            MOV     DPTR,#04300H
0012 E0                MOVX    A,@DPTR
0013 5404              ANL     A,#04H
0015 900000      R     MOV     DPTR,#iloEnableState
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 113
0019 904380            MOV     DPTR,#04380H
001C E0                MOVX    A,@DPTR
001D 900000      R     MOV     DPTR,#pmTwCfg0State
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 114
0021 904382            MOV     DPTR,#04382H
0024 E0                MOVX    A,@DPTR
0025 900000      R     MOV     DPTR,#pmTwCfg2State
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 116
0029 7F18              MOV     R7,#018H
002B 120000      E     LCALL   _CyPmFtwSetInterval
                                           ; SOURCE LINE # 118
002E 900000      R     MOV     DPTR,#status
0031 7410              MOV     A,#010H
0033 F0                MOVX    @DPTR,A
0034         ?C0002:
                                           ; SOURCE LINE # 120
0034 7F01              MOV     R7,#01H
0036 120000      E     LCALL   _CyPmReadStatus
0039 EF                MOV     A,R7
003A 20E012            JB      ACC.0,?C0003
                                           ; SOURCE LINE # 121
                                           ; SOURCE LINE # 123
003D 904225            MOV     DPTR,#04225H
0040 E0                MOVX    A,@DPTR
0041 5401              ANL     A,#01H
0043 60EF              JZ      ?C0002
                                           ; SOURCE LINE # 124
                                           ; SOURCE LINE # 125
0045 E0                MOVX    A,@DPTR
0046 5401              ANL     A,#01H
0048 60EA              JZ      ?C0002
                                           ; SOURCE LINE # 126
                                           ; SOURCE LINE # 127
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 50  

004A E4                CLR     A
004B 900000      R     MOV     DPTR,#status
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 128
                                           ; SOURCE LINE # 129
                                           ; SOURCE LINE # 130
                                           ; SOURCE LINE # 131
004F         ?C0003:
                                           ; SOURCE LINE # 134
004F 900000      R     MOV     DPTR,#iloEnableState
0052 E0                MOVX    A,@DPTR
0053 7003              JNZ     ?C0006
                                           ; SOURCE LINE # 135
                                           ; SOURCE LINE # 136
0055 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 137
0058         ?C0006:
                                           ; SOURCE LINE # 139
0058 900000      R     MOV     DPTR,#pmTwCfg0State
005B E0                MOVX    A,@DPTR
005C 904380            MOV     DPTR,#04380H
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 140
0060 900000      R     MOV     DPTR,#pmTwCfg2State
0063 E0                MOVX    A,@DPTR
0064 904382            MOV     DPTR,#04382H
0067 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 141
0068         ?C0001:
                                           ; SOURCE LINE # 143
0068 900000      R     MOV     DPTR,#status
006B E0                MOVX    A,@DPTR
006C FF                MOV     R7,A
                                           ; SOURCE LINE # 144
006D         ?C0007:
006D 22                RET     
             ; FUNCTION _CyPLL_OUT_Start (END)

             ; FUNCTION CyPLL_OUT_Stop (BEGIN)
                                           ; SOURCE LINE # 154
                                           ; SOURCE LINE # 155
                                           ; SOURCE LINE # 156
0000 904220            MOV     DPTR,#04220H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 157
0007 22                RET     
             ; FUNCTION CyPLL_OUT_Stop (END)

             ; FUNCTION _CyPLL_OUT_SetPQ (BEGIN)
                                           ; SOURCE LINE # 187
;---- Variable 'pDiv' assigned to Register 'R7' ----
;---- Variable 'current' assigned to Register 'R3' ----
;---- Variable 'qDiv' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 188
                                           ; SOURCE LINE # 192
0000 EF                MOV     A,R7
0001 C3                CLR     C
0002 9408              SUBB    A,#08H
0004 402F              JC      ?C0011
0006 ED                MOV     A,R5
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 51  

0007 D3                SETB    C
0008 9410              SUBB    A,#010H
000A 5029              JNC     ?C0011
000C ED                MOV     A,R5
000D C3                CLR     C
000E 9401              SUBB    A,#01H
0010 4023              JC      ?C0011
0012 EB                MOV     A,R3
0013 9401              SUBB    A,#01H
0015 401E              JC      ?C0011
0017 EB                MOV     A,R3
0018 D3                SETB    C
0019 9407              SUBB    A,#07H
001B 5018              JNC     ?C0011
                                           ; SOURCE LINE # 195
                                           ; SOURCE LINE # 197
001D 904222            MOV     DPTR,#04222H
0020 EF                MOV     A,R7
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 198
0022 ED                MOV     A,R5
0023 14                DEC     A
0024 A3                INC     DPTR
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 200
0026 EB                MOV     A,R3
0027 14                DEC     A
0028 FF                MOV     R7,A
0029 C4                SWAP    A
002A 54F0              ANL     A,#0F0H
002C FF                MOV     R7,A
002D 904221            MOV     DPTR,#04221H
0030 E0                MOVX    A,@DPTR
0031 548F              ANL     A,#08FH
0033 4F                ORL     A,R7
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 201
                                           ; SOURCE LINE # 203
                                           ; SOURCE LINE # 211
                                           ; SOURCE LINE # 213
0035         ?C0011:
0035 22                RET     
             ; FUNCTION _CyPLL_OUT_SetPQ (END)

             ; FUNCTION _CyPLL_OUT_SetSource (BEGIN)
                                           ; SOURCE LINE # 237
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 238
                                           ; SOURCE LINE # 242
0000 EF                MOV     A,R7
0001 24FD              ADD     A,#0FDH
0003 5002              JNC     ?C0015
0005 8008              SJMP    ?C0017
                                           ; SOURCE LINE # 243
                                           ; SOURCE LINE # 244
                                           ; SOURCE LINE # 245
                                           ; SOURCE LINE # 246
0007         ?C0015:
                                           ; SOURCE LINE # 247
0007 904000            MOV     DPTR,#04000H
000A E0                MOVX    A,@DPTR
000B 54FC              ANL     A,#0FCH
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 52  

000D 4F                ORL     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 248
                                           ; SOURCE LINE # 250
                                           ; SOURCE LINE # 252
                                           ; SOURCE LINE # 253
                                           ; SOURCE LINE # 254
000F         ?C0017:
000F 22                RET     
             ; FUNCTION _CyPLL_OUT_SetSource (END)

             ; FUNCTION _CyIMO_Start (BEGIN)
                                           ; SOURCE LINE # 282
;---- Variable 'wait' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 283
                                           ; SOURCE LINE # 289
0000 9043A0            MOV     DPTR,#043A0H
0003 E0                MOVX    A,@DPTR
0004 4410              ORL     A,#010H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 290
0007 9043B0            MOV     DPTR,#043B0H
000A E0                MOVX    A,@DPTR
000B 4410              ORL     A,#010H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 292
000E EF                MOV     A,R7
000F 6041              JZ      ?C0022
                                           ; SOURCE LINE # 293
                                           ; SOURCE LINE # 295
0011 904300            MOV     DPTR,#04300H
0014 E0                MOVX    A,@DPTR
0015 5404              ANL     A,#04H
0017 900000      R     MOV     DPTR,#ilo100KhzEnable
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 296
001B 904380            MOV     DPTR,#04380H
001E E0                MOVX    A,@DPTR
001F 900000      R     MOV     DPTR,#pmFtwCfg0Reg
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 297
0023 904382            MOV     DPTR,#04382H
0026 E0                MOVX    A,@DPTR
0027 900000      R     MOV     DPTR,#pmFtwCfg2Reg
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 299
002B E4                CLR     A
002C FF                MOV     R7,A
002D 120000      E     LCALL   _CyPmFtwSetInterval
0030         ?C0019:
                                           ; SOURCE LINE # 301
0030 7F01              MOV     R7,#01H
0032 120000      E     LCALL   _CyPmReadStatus
0035 EF                MOV     A,R7
0036 30E0F7            JNB     ACC.0,?C0019
                                           ; SOURCE LINE # 302
                                           ; SOURCE LINE # 304
0039         ?C0020:
                                           ; SOURCE LINE # 306
0039 900000      R     MOV     DPTR,#ilo100KhzEnable
003C E0                MOVX    A,@DPTR
003D 7003              JNZ     ?C0021
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 53  

                                           ; SOURCE LINE # 307
                                           ; SOURCE LINE # 308
003F 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 309
0042         ?C0021:
                                           ; SOURCE LINE # 311
0042 900000      R     MOV     DPTR,#pmFtwCfg0Reg
0045 E0                MOVX    A,@DPTR
0046 904380            MOV     DPTR,#04380H
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 312
004A 900000      R     MOV     DPTR,#pmFtwCfg2Reg
004D E0                MOVX    A,@DPTR
004E 904382            MOV     DPTR,#04382H
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 313
                                           ; SOURCE LINE # 314
0052         ?C0022:
0052 22                RET     
             ; FUNCTION _CyIMO_Start (END)

             ; FUNCTION CyIMO_Stop (BEGIN)
                                           ; SOURCE LINE # 324
                                           ; SOURCE LINE # 325
                                           ; SOURCE LINE # 326
0000 9043A0            MOV     DPTR,#043A0H
0003 E0                MOVX    A,@DPTR
0004 54EF              ANL     A,#0EFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 327
0007 9043B0            MOV     DPTR,#043B0H
000A E0                MOVX    A,@DPTR
000B 54EF              ANL     A,#0EFH
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 328
000E 22                RET     
             ; FUNCTION CyIMO_Stop (END)

             ; FUNCTION CyUSB_PowerOnCheck (BEGIN)
                                           ; SOURCE LINE # 341
                                           ; SOURCE LINE # 342
                                           ; SOURCE LINE # 343
;---- Variable 'poweredOn' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 349
0002 904393            MOV     DPTR,#04393H
0005 E0                MOVX    A,@DPTR
0006 5407              ANL     A,#07H
0008 7008              JNZ     ?C0026
000A 9043A5            MOV     DPTR,#043A5H
000D E0                MOVX    A,@DPTR
000E 5401              ANL     A,#01H
0010 7012              JNZ     ?C0025
0012         ?C0026:
0012 904393            MOV     DPTR,#04393H
0015 E0                MOVX    A,@DPTR
0016 5407              ANL     A,#07H
0018 6401              XRL     A,#01H
001A 700A              JNZ     ?C0024
001C 9043B5            MOV     DPTR,#043B5H
001F E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 54  

0020 5401              ANL     A,#01H
0022 6002              JZ      ?C0024
0024         ?C0025:
                                           ; SOURCE LINE # 350
                                           ; SOURCE LINE # 351
0024 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 352
0026         ?C0024:
                                           ; SOURCE LINE # 354
                                           ; SOURCE LINE # 355
0026         ?C0027:
0026 22                RET     
             ; FUNCTION CyUSB_PowerOnCheck (END)

             ; FUNCTION _CyIMO_SetTrimValue (BEGIN)
                                           ; SOURCE LINE # 367
;---- Variable 'freq' assigned to Register 'R6' ----
0000 AE07              MOV     R6,AR7
                                           ; SOURCE LINE # 368
                                           ; SOURCE LINE # 369
0002 120000      R     LCALL   CyUSB_PowerOnCheck
0005 900000      R     MOV     DPTR,#usbPowerOn
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 372
000A B40107            CJNE    A,#01H,?C0028
                                           ; SOURCE LINE # 373
                                           ; SOURCE LINE # 375
000D 906009            MOV     DPTR,#06009H
0010 E0                MOVX    A,@DPTR
0011 54FD              ANL     A,#0FDH
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 376
0014         ?C0028:
                                           ; SOURCE LINE # 377
0014 EE                MOV     A,R6
0015 B40900            CJNE    A,#09H,?C0175
0018         ?C0175:
0018 4003              JC      $ + 5H
001A 020000      R     LJMP    ?C0039
001D 900000      R     MOV     DPTR,#?C0176
0020 F8                MOV     R0,A
0021 28                ADD     A,R0
0022 28                ADD     A,R0
0023 73                JMP     @A+DPTR
0024         ?C0176:
0024 020000      R     LJMP    ?C0030
0027 020000      R     LJMP    ?C0031
002A 020000      R     LJMP    ?C0032
002D 020000      R     LJMP    ?C0033
0030 020000      R     LJMP    ?C0034
0033 020000      R     LJMP    ?C0035
0036 020000      R     LJMP    ?C0039
0039 020000      R     LJMP    ?C0039
003C 020000      R     LJMP    ?C0036
                                           ; SOURCE LINE # 378
                                           ; SOURCE LINE # 379
003F         ?C0030:
                                           ; SOURCE LINE # 380
003F 7B0C              MOV     R3,#0CH
0041 7A01              MOV     R2,#01H
0043 7908              MOV     R1,#08H
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 55  

0045 120000      E     LCALL   _cyread8
0048 9046A1            MOV     DPTR,#046A1H
004B EF                MOV     A,R7
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 381
004D 22                RET     
                                           ; SOURCE LINE # 383
004E         ?C0031:
                                           ; SOURCE LINE # 384
004E 7B0C              MOV     R3,#0CH
0050 7A01              MOV     R2,#01H
0052 7909              MOV     R1,#09H
0054 120000      E     LCALL   _cyread8
0057 9046A1            MOV     DPTR,#046A1H
005A EF                MOV     A,R7
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 385
005C 22                RET     
                                           ; SOURCE LINE # 387
005D         ?C0032:
                                           ; SOURCE LINE # 388
005D 7B0C              MOV     R3,#0CH
005F 7A01              MOV     R2,#01H
0061 790A              MOV     R1,#0AH
0063 120000      E     LCALL   _cyread8
0066 9046A1            MOV     DPTR,#046A1H
0069 EF                MOV     A,R7
006A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 389
006B 22                RET     
                                           ; SOURCE LINE # 391
006C         ?C0033:
                                           ; SOURCE LINE # 392
006C 7B0C              MOV     R3,#0CH
006E 7A01              MOV     R2,#01H
0070 790B              MOV     R1,#0BH
0072 120000      E     LCALL   _cyread8
0075 9046A1            MOV     DPTR,#046A1H
0078 EF                MOV     A,R7
0079 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 393
007A 22                RET     
                                           ; SOURCE LINE # 395
007B         ?C0034:
                                           ; SOURCE LINE # 396
007B 7B0C              MOV     R3,#0CH
007D 7A01              MOV     R2,#01H
007F 7989              MOV     R1,#089H
0081 120000      E     LCALL   _cyread8
0084 9046A1            MOV     DPTR,#046A1H
0087 EF                MOV     A,R7
0088 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 397
0089 22                RET     
                                           ; SOURCE LINE # 399
008A         ?C0035:
                                           ; SOURCE LINE # 400
008A 7B0C              MOV     R3,#0CH
008C 7A01              MOV     R2,#01H
008E 790C              MOV     R1,#0CH
0090 120000      E     LCALL   _cyread8
0093 9046A1            MOV     DPTR,#046A1H
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 56  

0096 EF                MOV     A,R7
0097 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 401
0098 22                RET     
                                           ; SOURCE LINE # 409
0099         ?C0036:
                                           ; SOURCE LINE # 410
0099 7B0C              MOV     R3,#0CH
009B 7A01              MOV     R2,#01H
009D 790F              MOV     R1,#0FH
009F 120000      E     LCALL   _cyread8
00A2 9046A1            MOV     DPTR,#046A1H
00A5 EF                MOV     A,R7
00A6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 413
00A7 900000      R     MOV     DPTR,#usbPowerOn
00AA E0                MOVX    A,@DPTR
00AB B40107            CJNE    A,#01H,?C0039
                                           ; SOURCE LINE # 414
                                           ; SOURCE LINE # 416
00AE 906009            MOV     DPTR,#06009H
00B1 E0                MOVX    A,@DPTR
00B2 4402              ORL     A,#02H
00B4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 417
                                           ; SOURCE LINE # 418
                                           ; SOURCE LINE # 420
                                           ; SOURCE LINE # 422
                                           ; SOURCE LINE # 423
                                           ; SOURCE LINE # 425
00B5         ?C0039:
00B5 22                RET     
             ; FUNCTION _CyIMO_SetTrimValue (END)

             ; FUNCTION _CyIMO_SetFreq (BEGIN)
                                           ; SOURCE LINE # 457
0000 900000      R     MOV     DPTR,#freq
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 458
                                           ; SOURCE LINE # 469
0005 904200            MOV     DPTR,#04200H
0008 E0                MOVX    A,@DPTR
0009 5407              ANL     A,#07H
000B 900000      R     MOV     DPTR,#currentFreq
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 472
000F 900000      R     MOV     DPTR,#freq
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 B40806            CJNE    A,#08H,?C0040
0017 7E03              MOV     R6,#03H
0019 7F03              MOV     R7,#03H
001B 8000              SJMP    ?C0041
001D         ?C0040:
001D         ?C0041:
001D 900000      R     MOV     DPTR,#nextFreq
0020 EF                MOV     A,R7
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 474
0022 900000      R     MOV     DPTR,#currentFreq
0025 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 57  

0026 14                DEC     A
0027 6018              JZ      ?C0044
0029 14                DEC     A
002A 601D              JZ      ?C0045
002C 14                DEC     A
002D 6022              JZ      ?C0046
002F 14                DEC     A
0030 6026              JZ      ?C0047
0032 14                DEC     A
0033 602B              JZ      ?C0048
0035 2405              ADD     A,#05H
0037 702D              JNZ     ?C0042
                                           ; SOURCE LINE # 475
                                           ; SOURCE LINE # 476
0039         ?C0043:
                                           ; SOURCE LINE # 477
0039 900000      R     MOV     DPTR,#currentFreq
003C 7402              MOV     A,#02H
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 478
003F 8025              SJMP    ?C0042
                                           ; SOURCE LINE # 480
0041         ?C0044:
                                           ; SOURCE LINE # 481
0041 900000      R     MOV     DPTR,#currentFreq
0044 7401              MOV     A,#01H
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 482
0047 801D              SJMP    ?C0042
                                           ; SOURCE LINE # 484
0049         ?C0045:
                                           ; SOURCE LINE # 485
0049 900000      R     MOV     DPTR,#currentFreq
004C 7403              MOV     A,#03H
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 486
004F 8015              SJMP    ?C0042
                                           ; SOURCE LINE # 488
0051         ?C0046:
                                           ; SOURCE LINE # 489
0051 E4                CLR     A
0052 900000      R     MOV     DPTR,#currentFreq
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 490
0056 800E              SJMP    ?C0042
                                           ; SOURCE LINE # 492
0058         ?C0047:
                                           ; SOURCE LINE # 493
0058 900000      R     MOV     DPTR,#currentFreq
005B 7404              MOV     A,#04H
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 494
005E 8006              SJMP    ?C0042
                                           ; SOURCE LINE # 496
0060         ?C0048:
                                           ; SOURCE LINE # 497
0060 900000      R     MOV     DPTR,#currentFreq
0063 7405              MOV     A,#05H
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 498
                                           ; SOURCE LINE # 506
                                           ; SOURCE LINE # 508
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 58  

                                           ; SOURCE LINE # 509
0066         ?C0042:
                                           ; SOURCE LINE # 511
0066 900000      R     MOV     DPTR,#currentFreq
0069 E0                MOVX    A,@DPTR
006A FF                MOV     R7,A
006B A3                INC     DPTR
006C E0                MOVX    A,@DPTR
006D C3                CLR     C
006E 9F                SUBB    A,R7
006F 4008              JC      ?C0050
                                           ; SOURCE LINE # 512
                                           ; SOURCE LINE # 514
0071 900000      R     MOV     DPTR,#freq
0074 E0                MOVX    A,@DPTR
0075 FF                MOV     R7,A
0076 120000      R     LCALL   _CyIMO_SetTrimValue
                                           ; SOURCE LINE # 515
0079         ?C0050:
                                           ; SOURCE LINE # 518
0079 900000      R     MOV     DPTR,#freq
007C E0                MOVX    A,@DPTR
007D FF                MOV     R7,A
007E B40900            CJNE    A,#09H,?C0177
0081         ?C0177:
0081 5075              JNC     ?C0051
0083 900000      R     MOV     DPTR,#?C0178
0086 F8                MOV     R0,A
0087 28                ADD     A,R0
0088 28                ADD     A,R0
0089 73                JMP     @A+DPTR
008A         ?C0178:
008A 020000      R     LJMP    ?C0052
008D 020000      R     LJMP    ?C0053
0090 020000      R     LJMP    ?C0054
0093 020000      R     LJMP    ?C0055
0096 020000      R     LJMP    ?C0056
0099 020000      R     LJMP    ?C0057
009C 020000      R     LJMP    ?C0051
009F 020000      R     LJMP    ?C0051
00A2 020000      R     LJMP    ?C0058
                                           ; SOURCE LINE # 519
                                           ; SOURCE LINE # 520
00A5         ?C0052:
                                           ; SOURCE LINE # 522
00A5 904200            MOV     DPTR,#04200H
00A8 E0                MOVX    A,@DPTR
00A9 54F8              ANL     A,#0F8H
00AB 4403              ORL     A,#03H
00AD 54BF              ANL     A,#0BFH
00AF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 523
00B0 8046              SJMP    ?C0051
                                           ; SOURCE LINE # 525
00B2         ?C0053:
                                           ; SOURCE LINE # 527
00B2 904200            MOV     DPTR,#04200H
00B5 E0                MOVX    A,@DPTR
00B6 54F8              ANL     A,#0F8H
00B8 4401              ORL     A,#01H
00BA 54BF              ANL     A,#0BFH
00BC F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 59  

                                           ; SOURCE LINE # 528
00BD 8039              SJMP    ?C0051
                                           ; SOURCE LINE # 530
00BF         ?C0054:
                                           ; SOURCE LINE # 532
00BF 904200            MOV     DPTR,#04200H
00C2 E0                MOVX    A,@DPTR
00C3 54B8              ANL     A,#0B8H
00C5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 533
00C6 8030              SJMP    ?C0051
                                           ; SOURCE LINE # 535
00C8         ?C0055:
                                           ; SOURCE LINE # 537
00C8 904200            MOV     DPTR,#04200H
00CB E0                MOVX    A,@DPTR
00CC 54F8              ANL     A,#0F8H
00CE 4402              ORL     A,#02H
00D0 54BF              ANL     A,#0BFH
00D2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 538
00D3 8023              SJMP    ?C0051
                                           ; SOURCE LINE # 540
00D5         ?C0056:
                                           ; SOURCE LINE # 542
00D5 904200            MOV     DPTR,#04200H
00D8 E0                MOVX    A,@DPTR
00D9 54F8              ANL     A,#0F8H
00DB 4404              ORL     A,#04H
00DD 54BF              ANL     A,#0BFH
00DF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 543
00E0 8016              SJMP    ?C0051
                                           ; SOURCE LINE # 545
00E2         ?C0057:
                                           ; SOURCE LINE # 547
00E2 904200            MOV     DPTR,#04200H
00E5 E0                MOVX    A,@DPTR
00E6 54F8              ANL     A,#0F8H
00E8 4405              ORL     A,#05H
00EA 54BF              ANL     A,#0BFH
00EC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 548
00ED 8009              SJMP    ?C0051
                                           ; SOURCE LINE # 557
00EF         ?C0058:
                                           ; SOURCE LINE # 558
00EF 904200            MOV     DPTR,#04200H
00F2 E0                MOVX    A,@DPTR
00F3 54F8              ANL     A,#0F8H
00F5 4442              ORL     A,#042H
00F7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 560
                                           ; SOURCE LINE # 562
                                           ; SOURCE LINE # 564
                                           ; SOURCE LINE # 565
00F8         ?C0051:
                                           ; SOURCE LINE # 568
00F8 EF                MOV     A,R7
00F9 B40805            CJNE    A,#08H,?C0060
                                           ; SOURCE LINE # 569
                                           ; SOURCE LINE # 570
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 60  

00FC 120000      R     LCALL   CyIMO_EnableDoubler
                                           ; SOURCE LINE # 571
00FF 8003              SJMP    ?C0061
0101         ?C0060:
                                           ; SOURCE LINE # 573
                                           ; SOURCE LINE # 574
0101 120000      R     LCALL   CyIMO_DisableDoubler
                                           ; SOURCE LINE # 575
0104         ?C0061:
                                           ; SOURCE LINE # 577
0104 900000      R     MOV     DPTR,#currentFreq
0107 E0                MOVX    A,@DPTR
0108 FF                MOV     R7,A
0109 A3                INC     DPTR
010A E0                MOVX    A,@DPTR
010B C3                CLR     C
010C 9F                SUBB    A,R7
010D 5008              JNC     ?C0063
                                           ; SOURCE LINE # 578
                                           ; SOURCE LINE # 580
010F 900000      R     MOV     DPTR,#freq
0112 E0                MOVX    A,@DPTR
0113 FF                MOV     R7,A
0114 120000      R     LCALL   _CyIMO_SetTrimValue
                                           ; SOURCE LINE # 581
                                           ; SOURCE LINE # 582
0117         ?C0063:
0117 22                RET     
             ; FUNCTION _CyIMO_SetFreq (END)

             ; FUNCTION _CyIMO_SetSource (BEGIN)
                                           ; SOURCE LINE # 607
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 608
                                           ; SOURCE LINE # 609
0000 EF                MOV     A,R7
0001 6024              JZ      ?C0067
0003 14                DEC     A
0004 6012              JZ      ?C0066
0006 14                DEC     A
0007 7025              JNZ     ?C0069
                                           ; SOURCE LINE # 610
                                           ; SOURCE LINE # 611
0009         ?C0065:
                                           ; SOURCE LINE # 612
0009 904000            MOV     DPTR,#04000H
000C E0                MOVX    A,@DPTR
000D 54BF              ANL     A,#0BFH
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 613
0010 904200            MOV     DPTR,#04200H
0013 E0                MOVX    A,@DPTR
0014 4420              ORL     A,#020H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 614
0017 22                RET     
                                           ; SOURCE LINE # 616
0018         ?C0066:
                                           ; SOURCE LINE # 617
0018 904000            MOV     DPTR,#04000H
001B E0                MOVX    A,@DPTR
001C 4440              ORL     A,#040H
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 61  

001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 618
001F 904200            MOV     DPTR,#04200H
0022 E0                MOVX    A,@DPTR
0023 4420              ORL     A,#020H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 619
0026 22                RET     
                                           ; SOURCE LINE # 621
0027         ?C0067:
                                           ; SOURCE LINE # 622
0027 904200            MOV     DPTR,#04200H
002A E0                MOVX    A,@DPTR
002B 54DF              ANL     A,#0DFH
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 623
                                           ; SOURCE LINE # 625
                                           ; SOURCE LINE # 628
                                           ; SOURCE LINE # 629
                                           ; SOURCE LINE # 630
002E         ?C0069:
002E 22                RET     
             ; FUNCTION _CyIMO_SetSource (END)

             ; FUNCTION CyIMO_EnableDoubler (BEGIN)
                                           ; SOURCE LINE # 641
                                           ; SOURCE LINE # 642
                                           ; SOURCE LINE # 644
0000 904200            MOV     DPTR,#04200H
0003 E0                MOVX    A,@DPTR
0004 4410              ORL     A,#010H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 645
0007 22                RET     
             ; FUNCTION CyIMO_EnableDoubler (END)

             ; FUNCTION CyIMO_DisableDoubler (BEGIN)
                                           ; SOURCE LINE # 655
                                           ; SOURCE LINE # 656
                                           ; SOURCE LINE # 657
0000 904200            MOV     DPTR,#04200H
0003 E0                MOVX    A,@DPTR
0004 54EF              ANL     A,#0EFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 658
0007 22                RET     
             ; FUNCTION CyIMO_DisableDoubler (END)

             ; FUNCTION _CyMasterClk_SetSource (BEGIN)
                                           ; SOURCE LINE # 685
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 686
                                           ; SOURCE LINE # 688
0000 EF                MOV     A,R7
0001 5403              ANL     A,#03H
0003 FF                MOV     R7,A
0004 904005            MOV     DPTR,#04005H
0007 E0                MOVX    A,@DPTR
0008 54FC              ANL     A,#0FCH
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 689
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 62  

000C 22                RET     
             ; FUNCTION _CyMasterClk_SetSource (END)

             ; FUNCTION _CyMasterClk_SetDivider (BEGIN)
                                           ; SOURCE LINE # 715
;---- Variable 'divider' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 716
                                           ; SOURCE LINE # 717
0000 904004            MOV     DPTR,#04004H
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 718
0005 22                RET     
             ; FUNCTION _CyMasterClk_SetDivider (END)

             ; FUNCTION _CyBusClk_Internal_SetDivider (BEGIN)
                                           ; SOURCE LINE # 732
;---- Variable 'divider' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 733
                                           ; SOURCE LINE # 735
0000 904014            MOV     DPTR,#04014H
0003 E0                MOVX    A,@DPTR
0004 54F0              ANL     A,#0F0H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 736
0007 904010            MOV     DPTR,#04010H
000A E4                CLR     A
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 739
000C 904008            MOV     DPTR,#04008H
000F E0                MOVX    A,@DPTR
0010 4480              ORL     A,#080H
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 742
0013 EF                MOV     A,R7
0014 904002            MOV     DPTR,#04002H
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 743
0018 EE                MOV     A,R6
0019 A3                INC     DPTR
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 752
001B 904001            MOV     DPTR,#04001H
001E E0                MOVX    A,@DPTR
001F 4401              ORL     A,#01H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 753
0022 22                RET     
             ; FUNCTION _CyBusClk_Internal_SetDivider (END)

             ; FUNCTION _CyBusClk_SetDivider (BEGIN)
                                           ; SOURCE LINE # 774
0000 900000      R     MOV     DPTR,#divider
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 775
                                           ; SOURCE LINE # 780
0008 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'interruptState' assigned to Register 'R1' ----
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 63  

000B A907              MOV     R1,AR7
                                           ; SOURCE LINE # 783
000D 904007            MOV     DPTR,#04007H
0010 E0                MOVX    A,@DPTR
0011 7F00              MOV     R7,#00H
0013 FE                MOV     R6,A
;---- Variable 'busClkDiv' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 784
0014 904006            MOV     DPTR,#04006H
0017 E0                MOVX    A,@DPTR
0018 FD                MOV     R5,A
0019 EE                MOV     A,R6
001A ED                MOV     A,R5
001B FF                MOV     R7,A
                                           ; SOURCE LINE # 786
001C 900000      R     MOV     DPTR,#divider
001F E0                MOVX    A,@DPTR
0020 7002              JNZ     ?C0179
0022 A3                INC     DPTR
0023 E0                MOVX    A,@DPTR
0024         ?C0179:
0024 6004              JZ      ?C0076
0026 EF                MOV     A,R7
0027 4E                ORL     A,R6
0028 703F              JNZ     ?C0075
002A         ?C0076:
                                           ; SOURCE LINE # 787
                                           ; SOURCE LINE # 789
002A 904004            MOV     DPTR,#04004H
002D E0                MOVX    A,@DPTR
;---- Variable 'masterClkDiv' assigned to Register 'R5' ----
002E FD                MOV     R5,A
                                           ; SOURCE LINE # 791
002F C3                CLR     C
0030 9407              SUBB    A,#07H
0032 5005              JNC     ?C0077
                                           ; SOURCE LINE # 792
                                           ; SOURCE LINE # 794
0034 7F07              MOV     R7,#07H
0036 120000      R     LCALL   _CyMasterClk_SetDivider
                                           ; SOURCE LINE # 795
0039         ?C0077:
                                           ; SOURCE LINE # 797
0039 900000      R     MOV     DPTR,#divider
003C E0                MOVX    A,@DPTR
003D FE                MOV     R6,A
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 4E                ORL     A,R6
0042 700C              JNZ     ?C0078
                                           ; SOURCE LINE # 798
                                           ; SOURCE LINE # 800
0044 904008            MOV     DPTR,#04008H
0047 E0                MOVX    A,@DPTR
0048 4440              ORL     A,#040H
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 801
004B 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 802
004E 8012              SJMP    ?C0079
0050         ?C0078:
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 64  

                                           ; SOURCE LINE # 804
                                           ; SOURCE LINE # 805
0050 900000      R     MOV     DPTR,#divider
0053 E0                MOVX    A,@DPTR
0054 FE                MOV     R6,A
0055 A3                INC     DPTR
0056 E0                MOVX    A,@DPTR
0057 FF                MOV     R7,A
0058 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 806
005B 904008            MOV     DPTR,#04008H
005E E0                MOVX    A,@DPTR
005F 54BF              ANL     A,#0BFH
0061 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 807
0062         ?C0079:
                                           ; SOURCE LINE # 810
0062 AF05              MOV     R7,AR5
0064 120000      R     LCALL   _CyMasterClk_SetDivider
                                           ; SOURCE LINE # 811
0067 800B              SJMP    ?C0080
0069         ?C0075:
                                           ; SOURCE LINE # 813
                                           ; SOURCE LINE # 814
0069 900000      R     MOV     DPTR,#divider
006C E0                MOVX    A,@DPTR
006D FE                MOV     R6,A
006E A3                INC     DPTR
006F E0                MOVX    A,@DPTR
0070 FF                MOV     R7,A
0071 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 815
0074         ?C0080:
                                           ; SOURCE LINE # 817
0074 AF01              MOV     R7,AR1
0076 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 818
0079 22                RET     
             ; FUNCTION _CyBusClk_SetDivider (END)

             ; FUNCTION _CyCpuClk_SetDivider (BEGIN)
                                           ; SOURCE LINE # 842
;---- Variable 'divider' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 843
                                           ; SOURCE LINE # 845
0000 EF                MOV     A,R7
0001 C4                SWAP    A
0002 54F0              ANL     A,#0F0H
0004 FF                MOV     R7,A
0005 904005            MOV     DPTR,#04005H
0008 E0                MOVX    A,@DPTR
0009 540F              ANL     A,#0FH
000B 4F                ORL     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 846
000D 22                RET     
             ; FUNCTION _CyCpuClk_SetDivider (END)

             ; FUNCTION _CyUsbClk_SetSource (BEGIN)
                                           ; SOURCE LINE # 864
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 865
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 65  

                                           ; SOURCE LINE # 866
0000 EF                MOV     A,R7
0001 5403              ANL     A,#03H
0003 FF                MOV     R7,A
0004 904009            MOV     DPTR,#04009H
0007 E0                MOVX    A,@DPTR
0008 54FC              ANL     A,#0FCH
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 868
000C 22                RET     
             ; FUNCTION _CyUsbClk_SetSource (END)

             ; FUNCTION CyILO_Start1K (BEGIN)
                                           ; SOURCE LINE # 882
                                           ; SOURCE LINE # 883
                                           ; SOURCE LINE # 885
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4402              ORL     A,#02H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 886
0007 22                RET     
             ; FUNCTION CyILO_Start1K (END)

             ; FUNCTION CyILO_Stop1K (BEGIN)
                                           ; SOURCE LINE # 903
                                           ; SOURCE LINE # 904
                                           ; SOURCE LINE # 906
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 54FD              ANL     A,#0FDH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 907
0007 22                RET     
             ; FUNCTION CyILO_Stop1K (END)

             ; FUNCTION CyILO_Start100K (BEGIN)
                                           ; SOURCE LINE # 917
                                           ; SOURCE LINE # 918
                                           ; SOURCE LINE # 919
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 920
0007 22                RET     
             ; FUNCTION CyILO_Start100K (END)

             ; FUNCTION CyILO_Stop100K (BEGIN)
                                           ; SOURCE LINE # 930
                                           ; SOURCE LINE # 931
                                           ; SOURCE LINE # 932
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 933
0007 22                RET     
             ; FUNCTION CyILO_Stop100K (END)

             ; FUNCTION CyILO_Enable33K (BEGIN)
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 66  

                                           ; SOURCE LINE # 946
                                           ; SOURCE LINE # 947
                                           ; SOURCE LINE # 949
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4420              ORL     A,#020H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 950
0007 22                RET     
             ; FUNCTION CyILO_Enable33K (END)

             ; FUNCTION CyILO_Disable33K (BEGIN)
                                           ; SOURCE LINE # 963
                                           ; SOURCE LINE # 964
                                           ; SOURCE LINE # 965
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 54DF              ANL     A,#0DFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 966
0007 22                RET     
             ; FUNCTION CyILO_Disable33K (END)

             ; FUNCTION _CyILO_SetSource (BEGIN)
                                           ; SOURCE LINE # 982
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 983
                                           ; SOURCE LINE # 985
0000 EF                MOV     A,R7
0001 25E0              ADD     A,ACC
0003 25E0              ADD     A,ACC
0005 540C              ANL     A,#0CH
0007 FF                MOV     R7,A
0008 904000            MOV     DPTR,#04000H
000B E0                MOVX    A,@DPTR
000C 54F3              ANL     A,#0F3H
000E 4F                ORL     A,R7
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 986
0010 22                RET     
             ; FUNCTION _CyILO_SetSource (END)

             ; FUNCTION _CyILO_SetPowerMode (BEGIN)
                                           ; SOURCE LINE # 1003
;---- Variable 'mode' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1004
                                           ; SOURCE LINE # 1008
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 FE                MOV     R6,A
;---- Variable 'state' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 1011
0005 EF                MOV     A,R7
0006 6006              JZ      ?C0091
                                           ; SOURCE LINE # 1012
                                           ; SOURCE LINE # 1013
0008 EE                MOV     A,R6
0009 4410              ORL     A,#010H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1014
000C 8007              SJMP    ?C0092
000E         ?C0091:
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 67  

                                           ; SOURCE LINE # 1016
                                           ; SOURCE LINE # 1017
000E EE                MOV     A,R6
000F 54EF              ANL     A,#0EFH
0011 904300            MOV     DPTR,#04300H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1018
0015         ?C0092:
                                           ; SOURCE LINE # 1021
0015 AF06              MOV     R7,AR6
0017 EE                MOV     A,R6
0018 5410              ANL     A,#010H
001A FF                MOV     R7,A
001B E4                CLR     A
001C C4                SWAP    A
001D F8                MOV     R0,A
001E 54F0              ANL     A,#0F0H
0020 C8                XCH     A,R0
0021 68                XRL     A,R0
0022 EF                MOV     A,R7
0023 C4                SWAP    A
0024 540F              ANL     A,#0FH
0026 48                ORL     A,R0
0027 FF                MOV     R7,A
                                           ; SOURCE LINE # 1022
0028         ?C0093:
0028 22                RET     
             ; FUNCTION _CyILO_SetPowerMode (END)

             ; FUNCTION CyXTAL_32KHZ_Start (BEGIN)
                                           ; SOURCE LINE # 1032
                                           ; SOURCE LINE # 1033
                                           ; SOURCE LINE # 1036
0000 90430A            MOV     DPTR,#0430AH
0003 74F3              MOV     A,#0F3H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1037
0006 904698            MOV     DPTR,#04698H
0009 7403              MOV     A,#03H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1038
000C 904309            MOV     DPTR,#04309H
000F E0                MOVX    A,@DPTR
0010 54F3              ANL     A,#0F3H
0012 4404              ORL     A,#04H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1042
0015 904308            MOV     DPTR,#04308H
0018 E0                MOVX    A,@DPTR
0019 4404              ORL     A,#04H
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1046
001C E0                MOVX    A,@DPTR
001D 4401              ORL     A,#01H
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1048
0020 900000      R     MOV     DPTR,#i
0023 7403              MOV     A,#03H
0025 F0                MOVX    @DPTR,A
0026 A3                INC     DPTR
0027 74E8              MOV     A,#0E8H
0029 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 68  

002A         ?C0094:
002A D3                SETB    C
002B 900000      R     MOV     DPTR,#i+01H
002E E0                MOVX    A,@DPTR
002F 9400              SUBB    A,#00H
0031 900000      R     MOV     DPTR,#i
0034 E0                MOVX    A,@DPTR
0035 9400              SUBB    A,#00H
0037 4024              JC      ?C0098
                                           ; SOURCE LINE # 1049
                                           ; SOURCE LINE # 1050
0039 120000      R     LCALL   CyXTAL_32KHZ_ReadStatus
003C EF                MOV     A,R7
003D 30E506            JNB     ACC.5,?C0097
                                           ; SOURCE LINE # 1051
                                           ; SOURCE LINE # 1053
0040 E4                CLR     A
0041 FF                MOV     R7,A
0042 120000      R     LCALL   _CyXTAL_32KHZ_SetPowerMode
                                           ; SOURCE LINE # 1055
0045 22                RET     
                                           ; SOURCE LINE # 1056
0046         ?C0097:
                                           ; SOURCE LINE # 1057
0046 7F01              MOV     R7,#01H
0048 7E00              MOV     R6,#00H
004A 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1058
004D 900000      R     MOV     DPTR,#i+01H
0050 E0                MOVX    A,@DPTR
0051 24FF              ADD     A,#0FFH
0053 F0                MOVX    @DPTR,A
0054 900000      R     MOV     DPTR,#i
0057 E0                MOVX    A,@DPTR
0058 34FF              ADDC    A,#0FFH
005A F0                MOVX    @DPTR,A
005B 80CD              SJMP    ?C0094
                                           ; SOURCE LINE # 1059
005D         ?C0098:
005D 22                RET     
             ; FUNCTION CyXTAL_32KHZ_Start (END)

             ; FUNCTION CyXTAL_32KHZ_Stop (BEGIN)
                                           ; SOURCE LINE # 1069
                                           ; SOURCE LINE # 1070
                                           ; SOURCE LINE # 1071
0000 90430A            MOV     DPTR,#0430AH
0003 74F3              MOV     A,#0F3H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1072
0006 904698            MOV     DPTR,#04698H
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1073
000B 904309            MOV     DPTR,#04309H
000E E0                MOVX    A,@DPTR
000F 54F3              ANL     A,#0F3H
0011 4404              ORL     A,#04H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1075
0014 904308            MOV     DPTR,#04308H
0017 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 69  

0018 54FC              ANL     A,#0FCH
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1078
001B E0                MOVX    A,@DPTR
001C 54FB              ANL     A,#0FBH
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1080
001F 22                RET     
             ; FUNCTION CyXTAL_32KHZ_Stop (END)

             ; FUNCTION CyXTAL_32KHZ_ReadStatus (BEGIN)
                                           ; SOURCE LINE # 1096
                                           ; SOURCE LINE # 1097
                                           ; SOURCE LINE # 1098
0000 904308            MOV     DPTR,#04308H
0003 E0                MOVX    A,@DPTR
0004 5420              ANL     A,#020H
0006 FF                MOV     R7,A
                                           ; SOURCE LINE # 1099
0007         ?C0100:
0007 22                RET     
             ; FUNCTION CyXTAL_32KHZ_ReadStatus (END)

             ; FUNCTION _CyXTAL_32KHZ_SetPowerMode (BEGIN)
                                           ; SOURCE LINE # 1118
;---- Variable 'mode' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1119
                                           ; SOURCE LINE # 1120
0000 904308            MOV     DPTR,#04308H
0003 E0                MOVX    A,@DPTR
0004 5402              ANL     A,#02H
0006 6004              JZ      ?C0101
0008 7E01              MOV     R6,#01H
000A 8002              SJMP    ?C0102
000C         ?C0101:
000C 7E00              MOV     R6,#00H
000E         ?C0102:
000E 900000      R     MOV     DPTR,#state
0011 EE                MOV     A,R6
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1122
0013 90430A            MOV     DPTR,#0430AH
0016 74F3              MOV     A,#0F3H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1124
0019 EF                MOV     A,R7
001A 6401              XRL     A,#01H
001C 7025              JNZ     ?C0103
                                           ; SOURCE LINE # 1125
                                           ; SOURCE LINE # 1127
001E 904698            MOV     DPTR,#04698H
0021 04                INC     A
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1128
0023 7F0A              MOV     R7,#0AH
0025 7E00              MOV     R6,#00H
0027 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1129
002A 904309            MOV     DPTR,#04309H
002D E0                MOVX    A,@DPTR
002E 54F3              ANL     A,#0F3H
0030 4408              ORL     A,#08H
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 70  

0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1131
0033 7F14              MOV     R7,#014H
0035 7E00              MOV     R6,#00H
0037 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1132
003A 904308            MOV     DPTR,#04308H
003D E0                MOVX    A,@DPTR
003E 4402              ORL     A,#02H
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1133
0041 801D              SJMP    ?C0104
0043         ?C0103:
                                           ; SOURCE LINE # 1135
                                           ; SOURCE LINE # 1137
0043 904698            MOV     DPTR,#04698H
0046 7406              MOV     A,#06H
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1138
0049 7F0A              MOV     R7,#0AH
004B 7E00              MOV     R6,#00H
004D 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1139
0050 904309            MOV     DPTR,#04309H
0053 E0                MOVX    A,@DPTR
0054 54F3              ANL     A,#0F3H
0056 4404              ORL     A,#04H
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1141
0059 904308            MOV     DPTR,#04308H
005C E0                MOVX    A,@DPTR
005D 54FD              ANL     A,#0FDH
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1142
0060         ?C0104:
                                           ; SOURCE LINE # 1144
0060 900000      R     MOV     DPTR,#state
0063 E0                MOVX    A,@DPTR
0064 FF                MOV     R7,A
                                           ; SOURCE LINE # 1145
0065         ?C0105:
0065 22                RET     
             ; FUNCTION _CyXTAL_32KHZ_SetPowerMode (END)

             ; FUNCTION _CyXTAL_Start (BEGIN)
                                           ; SOURCE LINE # 1182
;---- Variable 'wait' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1183
                                           ; SOURCE LINE # 1184
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#status
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1185
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1193
0008 904210            MOV     DPTR,#04210H
000B E0                MOVX    A,@DPTR
000C 4401              ORL     A,#01H
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1196
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 71  

000F EF                MOV     A,R7
0010 D3                SETB    C
0011 9400              SUBB    A,#00H
0013 5003              JNC     $ + 5H
0015 020000      R     LJMP    ?C0106
                                           ; SOURCE LINE # 1197
                                           ; SOURCE LINE # 1199
0018 904300            MOV     DPTR,#04300H
001B E0                MOVX    A,@DPTR
001C 900000      R     MOV     DPTR,#iloEnableState
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1200
0020 904380            MOV     DPTR,#04380H
0023 E0                MOVX    A,@DPTR
0024 900000      R     MOV     DPTR,#pmTwCfg0Tmp
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1201
0028 904382            MOV     DPTR,#04382H
002B E0                MOVX    A,@DPTR
002C 900000      R     MOV     DPTR,#pmTwCfg2Tmp
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1204
0030 7F18              MOV     R7,#018H
0032 120000      E     LCALL   _CyPmFtwSetInterval
                                           ; SOURCE LINE # 1205
0035 900000      R     MOV     DPTR,#status
0038 7410              MOV     A,#010H
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1208
003B         ?C0107:
003B 900000      R     MOV     DPTR,#timeout
003E E0                MOVX    A,@DPTR
003F D3                SETB    C
0040 9400              SUBB    A,#00H
0042 403B              JC      ?C0108
                                           ; SOURCE LINE # 1209
                                           ; SOURCE LINE # 1211
0044 904210            MOV     DPTR,#04210H
0047 E0                MOVX    A,@DPTR
0048 FF                MOV     R7,A
                                           ; SOURCE LINE # 1214
0049 900000      R     MOV     DPTR,#count
004C 7404              MOV     A,#04H
004E F0                MOVX    @DPTR,A
004F         ?C0110:
004F 900000      R     MOV     DPTR,#count
0052 E0                MOVX    A,@DPTR
0053 D3                SETB    C
0054 9400              SUBB    A,#00H
0056 4011              JC      ?C0111
                                           ; SOURCE LINE # 1215
0058         ?C0113:
                                           ; SOURCE LINE # 1216
0058 7F01              MOV     R7,#01H
005A 120000      E     LCALL   _CyPmReadStatus
005D EF                MOV     A,R7
005E 30E0F7            JNB     ACC.0,?C0113
                                           ; SOURCE LINE # 1217
                                           ; SOURCE LINE # 1219
0061         ?C0114:
                                           ; SOURCE LINE # 1220
0061         ?C0112:
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 72  

0061 900000      R     MOV     DPTR,#count
0064 E0                MOVX    A,@DPTR
0065 14                DEC     A
0066 F0                MOVX    @DPTR,A
0067 80E6              SJMP    ?C0110
0069         ?C0111:
                                           ; SOURCE LINE # 1227
0069 904210            MOV     DPTR,#04210H
006C E0                MOVX    A,@DPTR
006D 5480              ANL     A,#080H
006F 7006              JNZ     ?C0109
                                           ; SOURCE LINE # 1228
                                           ; SOURCE LINE # 1229
0071 900000      R     MOV     DPTR,#status
0074 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1230
0075 8008              SJMP    ?C0108
                                           ; SOURCE LINE # 1231
                                           ; SOURCE LINE # 1232
0077         ?C0109:
0077 900000      R     MOV     DPTR,#timeout
007A E0                MOVX    A,@DPTR
007B 14                DEC     A
007C F0                MOVX    @DPTR,A
007D 80BC              SJMP    ?C0107
007F         ?C0108:
                                           ; SOURCE LINE # 1236
007F 900000      R     MOV     DPTR,#iloEnableState
0082 E0                MOVX    A,@DPTR
0083 5404              ANL     A,#04H
0085 7003              JNZ     ?C0116
                                           ; SOURCE LINE # 1237
                                           ; SOURCE LINE # 1238
0087 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 1239
008A         ?C0116:
                                           ; SOURCE LINE # 1240
008A 900000      R     MOV     DPTR,#pmTwCfg0Tmp
008D E0                MOVX    A,@DPTR
008E 904380            MOV     DPTR,#04380H
0091 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1241
0092 900000      R     MOV     DPTR,#pmTwCfg2Tmp
0095 E0                MOVX    A,@DPTR
0096 904382            MOV     DPTR,#04382H
0099 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1242
009A         ?C0106:
                                           ; SOURCE LINE # 1244
009A 900000      R     MOV     DPTR,#status
009D E0                MOVX    A,@DPTR
009E FF                MOV     R7,A
                                           ; SOURCE LINE # 1245
009F         ?C0117:
009F 22                RET     
             ; FUNCTION _CyXTAL_Start (END)

             ; FUNCTION CyXTAL_Stop (BEGIN)
                                           ; SOURCE LINE # 1255
                                           ; SOURCE LINE # 1256
                                           ; SOURCE LINE # 1258
0000 904210            MOV     DPTR,#04210H
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 73  

0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1259
0007 22                RET     
             ; FUNCTION CyXTAL_Stop (END)

             ; FUNCTION CyXTAL_EnableErrStatus (BEGIN)
                                           ; SOURCE LINE # 1270
                                           ; SOURCE LINE # 1271
                                           ; SOURCE LINE # 1273
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1274
0007 22                RET     
             ; FUNCTION CyXTAL_EnableErrStatus (END)

             ; FUNCTION CyXTAL_DisableErrStatus (BEGIN)
                                           ; SOURCE LINE # 1285
                                           ; SOURCE LINE # 1286
                                           ; SOURCE LINE # 1288
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1289
0007 22                RET     
             ; FUNCTION CyXTAL_DisableErrStatus (END)

             ; FUNCTION CyXTAL_ReadStatus (BEGIN)
                                           ; SOURCE LINE # 1305
                                           ; SOURCE LINE # 1306
                                           ; SOURCE LINE # 1311
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 5480              ANL     A,#080H
0006 6004              JZ      ?C0121
0008 7F01              MOV     R7,#01H
000A 8002              SJMP    ?C0122
000C         ?C0121:
000C 7F00              MOV     R7,#00H
000E         ?C0122:
                                           ; SOURCE LINE # 1312
000E         ?C0123:
000E 22                RET     
             ; FUNCTION CyXTAL_ReadStatus (END)

             ; FUNCTION CyXTAL_EnableFaultRecovery (BEGIN)
                                           ; SOURCE LINE # 1325
                                           ; SOURCE LINE # 1326
                                           ; SOURCE LINE # 1327
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 4440              ORL     A,#040H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1328
0007 22                RET     
             ; FUNCTION CyXTAL_EnableFaultRecovery (END)

             ; FUNCTION CyXTAL_DisableFaultRecovery (BEGIN)
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 74  

                                           ; SOURCE LINE # 1340
                                           ; SOURCE LINE # 1341
                                           ; SOURCE LINE # 1342
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 54BF              ANL     A,#0BFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1343
0007 22                RET     
             ; FUNCTION CyXTAL_DisableFaultRecovery (END)

             ; FUNCTION _CyXTAL_SetStartup (BEGIN)
                                           ; SOURCE LINE # 1361
;---- Variable 'setting' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1362
                                           ; SOURCE LINE # 1363
0000 EF                MOV     A,R7
0001 541F              ANL     A,#01FH
0003 FF                MOV     R7,A
0004 904212            MOV     DPTR,#04212H
0007 E0                MOVX    A,@DPTR
0008 54E0              ANL     A,#0E0H
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1365
000C 22                RET     
             ; FUNCTION _CyXTAL_SetStartup (END)

             ; FUNCTION _CyXTAL_SetFbVoltage (BEGIN)
                                           ; SOURCE LINE # 1380
;---- Variable 'setting' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1381
                                           ; SOURCE LINE # 1382
0000 EF                MOV     A,R7
0001 540F              ANL     A,#0FH
0003 FF                MOV     R7,A
0004 904213            MOV     DPTR,#04213H
0007 E0                MOVX    A,@DPTR
0008 54F0              ANL     A,#0F0H
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1384
000C 22                RET     
             ; FUNCTION _CyXTAL_SetFbVoltage (END)

             ; FUNCTION _CyXTAL_SetWdVoltage (BEGIN)
                                           ; SOURCE LINE # 1398
;---- Variable 'setting' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1399
                                           ; SOURCE LINE # 1401
0000 EF                MOV     A,R7
0001 C4                SWAP    A
0002 5470              ANL     A,#070H
0004 FF                MOV     R7,A
0005 904213            MOV     DPTR,#04213H
0008 E0                MOVX    A,@DPTR
0009 548F              ANL     A,#08FH
000B 4F                ORL     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1402
000D 22                RET     
             ; FUNCTION _CyXTAL_SetWdVoltage (END)
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 75  


             ; FUNCTION _?CyHalt (BEGIN)
                                           ; SOURCE LINE # 1414
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1416
                                           ; SOURCE LINE # 1417
                                           ; SOURCE LINE # 1419
0008         ?C0129:
                                           ; SOURCE LINE # 1426
0008 9046EA            MOV     DPTR,#046EAH
000B 7401              MOV     A,#01H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1428
000E 900001            MOV     DPTR,#01H
0011 120000      E     LCALL   ?C?ADDXBP
0014 22                RET     
             ; FUNCTION _?CyHalt (END)

             ; FUNCTION CySoftwareReset (BEGIN)
                                           ; SOURCE LINE # 1438
                                           ; SOURCE LINE # 1439
                                           ; SOURCE LINE # 1440
0000 9046F6            MOV     DPTR,#046F6H
0003 E0                MOVX    A,@DPTR
0004 4401              ORL     A,#01H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1441
0007 22                RET     
             ; FUNCTION CySoftwareReset (END)

             ; FUNCTION _?CyDelay (BEGIN)
                                           ; SOURCE LINE # 1459
0000 90FFFC            MOV     DPTR,#0FFFCH
0003 120000      E     LCALL   ?C?ADDXBP
0006 120000      E     LCALL   ?C?LSTXDATA
0009         ?C0132:
                                           ; SOURCE LINE # 1461
0009 850083      E     MOV     DPH,?C_XBP
000C 850082      E     MOV     DPL,?C_XBP+01H
000F E0                MOVX    A,@DPTR
0010 A3                INC     DPTR
0011 E0                MOVX    A,@DPTR
0012 A3                INC     DPTR
0013 E0                MOVX    A,@DPTR
0014 FE                MOV     R6,A
0015 A3                INC     DPTR
0016 E0                MOVX    A,@DPTR
0017 D3                SETB    C
0018 9400              SUBB    A,#00H
001A EE                MOV     A,R6
001B 9480              SUBB    A,#080H
001D 403D              JC      ?C0133
                                           ; SOURCE LINE # 1462
                                           ; SOURCE LINE # 1467
001F 900000      R     MOV     DPTR,#cydelay_32k_ms
0022 E0                MOVX    A,@DPTR
0023 FC                MOV     R4,A
0024 A3                INC     DPTR
0025 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 76  

0026 FD                MOV     R5,A
0027 A3                INC     DPTR
0028 E0                MOVX    A,@DPTR
0029 FE                MOV     R6,A
002A A3                INC     DPTR
002B E0                MOVX    A,@DPTR
002C FF                MOV     R7,A
002D 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 1468
0030 850083      E     MOV     DPH,?C_XBP
0033 850082      E     MOV     DPL,?C_XBP+01H
0036 C083              PUSH    DPH
0038 C082              PUSH    DPL
003A E0                MOVX    A,@DPTR
003B FC                MOV     R4,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FD                MOV     R5,A
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 FE                MOV     R6,A
0042 A3                INC     DPTR
0043 E0                MOVX    A,@DPTR
0044 2400              ADD     A,#00H
0046 FF                MOV     R7,A
0047 EE                MOV     A,R6
0048 3480              ADDC    A,#080H
004A FE                MOV     R6,A
004B ED                MOV     A,R5
004C 34FF              ADDC    A,#0FFH
004E FD                MOV     R5,A
004F EC                MOV     A,R4
0050 34FF              ADDC    A,#0FFH
0052 FC                MOV     R4,A
0053 D082              POP     DPL
0055 D083              POP     DPH
0057 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1469
005A 80AD              SJMP    ?C0132
005C         ?C0133:
                                           ; SOURCE LINE # 1471
005C 900000      R     MOV     DPTR,#cydelay_freq_khz
005F E0                MOVX    A,@DPTR
0060 FC                MOV     R4,A
0061 A3                INC     DPTR
0062 E0                MOVX    A,@DPTR
0063 FD                MOV     R5,A
0064 A3                INC     DPTR
0065 E0                MOVX    A,@DPTR
0066 FE                MOV     R6,A
0067 A3                INC     DPTR
0068 E0                MOVX    A,@DPTR
0069 FF                MOV     R7,A
006A 850083      E     MOV     DPH,?C_XBP
006D 850082      E     MOV     DPL,?C_XBP+01H
0070 E0                MOVX    A,@DPTR
0071 F8                MOV     R0,A
0072 A3                INC     DPTR
0073 E0                MOVX    A,@DPTR
0074 F9                MOV     R1,A
0075 A3                INC     DPTR
0076 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 77  

0077 FA                MOV     R2,A
0078 A3                INC     DPTR
0079 E0                MOVX    A,@DPTR
007A FB                MOV     R3,A
007B 120000      E     LCALL   ?C?LMUL
007E 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 1472
0081 900004            MOV     DPTR,#04H
0084 120000      E     LCALL   ?C?ADDXBP
0087 22                RET     
             ; FUNCTION _?CyDelay (END)

             ; FUNCTION _?CyDelayFreq (BEGIN)
                                           ; SOURCE LINE # 1520
0000 90FFFC            MOV     DPTR,#0FFFCH
0003 120000      E     LCALL   ?C?ADDXBP
0006 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1522
0009 850083      E     MOV     DPH,?C_XBP
000C 850082      E     MOV     DPL,?C_XBP+01H
000F E0                MOVX    A,@DPTR
0010 A3                INC     DPTR
0011 E0                MOVX    A,@DPTR
0012 A3                INC     DPTR
0013 E0                MOVX    A,@DPTR
0014 FE                MOV     R6,A
0015 A3                INC     DPTR
0016 E0                MOVX    A,@DPTR
0017 4E                ORL     A,R6
0018 6019              JZ      ?C0135
                                           ; SOURCE LINE # 1523
                                           ; SOURCE LINE # 1524
001A 850083      E     MOV     DPH,?C_XBP
001D 850082      E     MOV     DPL,?C_XBP+01H
0020 E0                MOVX    A,@DPTR
0021 FC                MOV     R4,A
0022 A3                INC     DPTR
0023 E0                MOVX    A,@DPTR
0024 FD                MOV     R5,A
0025 A3                INC     DPTR
0026 E0                MOVX    A,@DPTR
0027 FE                MOV     R6,A
0028 A3                INC     DPTR
0029 E0                MOVX    A,@DPTR
002A FF                MOV     R7,A
002B 900000      R     MOV     DPTR,#cydelay_freq_hz
002E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1525
0031 800E              SJMP    ?C0136
0033         ?C0135:
                                           ; SOURCE LINE # 1527
                                           ; SOURCE LINE # 1528
0033 7F00              MOV     R7,#00H
0035 7E6C              MOV     R6,#06CH
0037 7DDC              MOV     R5,#0DCH
0039 7C02              MOV     R4,#02H
003B 900000      R     MOV     DPTR,#cydelay_freq_hz
003E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1529
0041         ?C0136:
                                           ; SOURCE LINE # 1531
0041 900000      R     MOV     DPTR,#cydelay_freq_hz
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 78  

0044 E0                MOVX    A,@DPTR
0045 FC                MOV     R4,A
0046 A3                INC     DPTR
0047 E0                MOVX    A,@DPTR
0048 FD                MOV     R5,A
0049 A3                INC     DPTR
004A E0                MOVX    A,@DPTR
004B FE                MOV     R6,A
004C A3                INC     DPTR
004D E0                MOVX    A,@DPTR
004E 243F              ADD     A,#03FH
0050 FF                MOV     R7,A
0051 EE                MOV     A,R6
0052 3442              ADDC    A,#042H
0054 FE                MOV     R6,A
0055 ED                MOV     A,R5
0056 340F              ADDC    A,#0FH
0058 FD                MOV     R5,A
0059 E4                CLR     A
005A 3C                ADDC    A,R4
005B FC                MOV     R4,A
005C 7B40              MOV     R3,#040H
005E 7A42              MOV     R2,#042H
0060 790F              MOV     R1,#0FH
0062 7800              MOV     R0,#00H
0064 120000      E     LCALL   ?C?ULDIV
0067 900000      R     MOV     DPTR,#cydelay_freq_mhz
006A EF                MOV     A,R7
006B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1532
006C A3                INC     DPTR
006D E0                MOVX    A,@DPTR
006E FC                MOV     R4,A
006F A3                INC     DPTR
0070 E0                MOVX    A,@DPTR
0071 FD                MOV     R5,A
0072 A3                INC     DPTR
0073 E0                MOVX    A,@DPTR
0074 FE                MOV     R6,A
0075 A3                INC     DPTR
0076 E0                MOVX    A,@DPTR
0077 24E7              ADD     A,#0E7H
0079 FF                MOV     R7,A
007A EE                MOV     A,R6
007B 3403              ADDC    A,#03H
007D FE                MOV     R6,A
007E E4                CLR     A
007F 3D                ADDC    A,R5
0080 FD                MOV     R5,A
0081 E4                CLR     A
0082 3C                ADDC    A,R4
0083 FC                MOV     R4,A
0084 E4                CLR     A
0085 7BE8              MOV     R3,#0E8H
0087 7A03              MOV     R2,#03H
0089 F9                MOV     R1,A
008A F8                MOV     R0,A
008B 120000      E     LCALL   ?C?ULDIV
008E 900000      R     MOV     DPTR,#cydelay_freq_khz
0091 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1533
0094 E4                CLR     A
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 79  

0095 FF                MOV     R7,A
0096 7E80              MOV     R6,#080H
0098 FD                MOV     R5,A
0099 FC                MOV     R4,A
009A 900000      R     MOV     DPTR,#cydelay_freq_khz
009D E0                MOVX    A,@DPTR
009E F8                MOV     R0,A
009F A3                INC     DPTR
00A0 E0                MOVX    A,@DPTR
00A1 F9                MOV     R1,A
00A2 A3                INC     DPTR
00A3 E0                MOVX    A,@DPTR
00A4 FA                MOV     R2,A
00A5 A3                INC     DPTR
00A6 E0                MOVX    A,@DPTR
00A7 FB                MOV     R3,A
00A8 120000      E     LCALL   ?C?LMUL
00AB 900000      R     MOV     DPTR,#cydelay_32k_ms
00AE 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1534
00B1 900004            MOV     DPTR,#04H
00B4 120000      E     LCALL   ?C?ADDXBP
00B7 22                RET     
             ; FUNCTION _?CyDelayFreq (END)

             ; FUNCTION _CyWdtStart (BEGIN)
                                           ; SOURCE LINE # 1578
;---- Variable 'lpMode' assigned to Register 'R5' ----
;---- Variable 'ticks' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1579
                                           ; SOURCE LINE # 1581
0000 EF                MOV     A,R7
0001 5403              ANL     A,#03H
0003 FF                MOV     R7,A
0004 904383            MOV     DPTR,#04383H
0007 E0                MOVX    A,@DPTR
0008 54FC              ANL     A,#0FCH
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1584
000C E0                MOVX    A,@DPTR
000D 4480              ORL     A,#080H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1585
0010 E0                MOVX    A,@DPTR
0011 547F              ANL     A,#07FH
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1589
0014 AF05              MOV     R7,AR5
0016 EF                MOV     A,R7
0017 C4                SWAP    A
0018 33                RLC     A
0019 5460              ANL     A,#060H
001B FF                MOV     R7,A
001C E0                MOVX    A,@DPTR
001D 549F              ANL     A,#09FH
001F 4F                ORL     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1592
0021 E0                MOVX    A,@DPTR
0022 4410              ORL     A,#010H
0024 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 80  

                                           ; SOURCE LINE # 1593
0025 22                RET     
             ; FUNCTION _CyWdtStart (END)

             ; FUNCTION CyWdtClear (BEGIN)
                                           ; SOURCE LINE # 1603
                                           ; SOURCE LINE # 1604
                                           ; SOURCE LINE # 1605
0000 904384            MOV     DPTR,#04384H
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1606
0006 22                RET     
             ; FUNCTION CyWdtClear (END)

             ; FUNCTION _CyVdLvDigitEnable (BEGIN)
                                           ; SOURCE LINE # 1647
0000 900000      R     MOV     DPTR,#reset
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1648
                                           ; SOURCE LINE # 1652
0008 120000      E     LCALL   CyEnterCriticalSection
000B 900000      R     MOV     DPTR,#interruptState
000E EF                MOV     A,R7
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1655
0010 9044C0            MOV     DPTR,#044C0H
0013 E0                MOVX    A,@DPTR
0014 5401              ANL     A,#01H
0016 FF                MOV     R7,A
0017 E4                CLR     A
0018 FC                MOV     R4,A
0019 FD                MOV     R5,A
001A FE                MOV     R6,A
001B 900000      R     MOV     DPTR,#intRegTmp
001E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1658
0021 9044C8            MOV     DPTR,#044C8H
0024 7401              MOV     A,#01H
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1660
0027 9046F7            MOV     DPTR,#046F7H
002A E0                MOVX    A,@DPTR
002B 54BF              ANL     A,#0BFH
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1663
002E 9046F4            MOV     DPTR,#046F4H
0031 E0                MOVX    A,@DPTR
0032 54F0              ANL     A,#0F0H
0034 FF                MOV     R7,A
0035 900000      R     MOV     DPTR,#threshold
0038 E0                MOVX    A,@DPTR
0039 540F              ANL     A,#0FH
003B 4F                ORL     A,R7
003C 9046F4            MOV     DPTR,#046F4H
003F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1664
0040 A3                INC     DPTR
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 81  

0041 E0                MOVX    A,@DPTR
0042 4401              ORL     A,#01H
0044 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1667
0045 7F01              MOV     R7,#01H
0047 7E00              MOV     R6,#00H
0049 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1669
004C 7F01              MOV     R7,#01H
004E 120000      R     LCALL   _CyVdStickyStatus
                                           ; SOURCE LINE # 1671
0051 900000      R     MOV     DPTR,#reset
0054 E0                MOVX    A,@DPTR
0055 6009              JZ      ?C0140
                                           ; SOURCE LINE # 1672
                                           ; SOURCE LINE # 1673
0057 9046F7            MOV     DPTR,#046F7H
005A E0                MOVX    A,@DPTR
005B 4440              ORL     A,#040H
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1674
005E 8007              SJMP    ?C0141
0060         ?C0140:
                                           ; SOURCE LINE # 1676
                                           ; SOURCE LINE # 1677
0060 9046F7            MOV     DPTR,#046F7H
0063 E0                MOVX    A,@DPTR
0064 54BF              ANL     A,#0BFH
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1678
0067         ?C0141:
                                           ; SOURCE LINE # 1681
0067 9044D8            MOV     DPTR,#044D8H
006A 7401              MOV     A,#01H
006C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1684
006D 900000      R     MOV     DPTR,#intRegTmp
0070 E0                MOVX    A,@DPTR
0071 A3                INC     DPTR
0072 E0                MOVX    A,@DPTR
0073 A3                INC     DPTR
0074 E0                MOVX    A,@DPTR
0075 A3                INC     DPTR
0076 E0                MOVX    A,@DPTR
0077 9044C0            MOV     DPTR,#044C0H
007A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1686
007B 900000      R     MOV     DPTR,#interruptState
007E E0                MOVX    A,@DPTR
007F FF                MOV     R7,A
0080 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1687
0083 22                RET     
             ; FUNCTION _CyVdLvDigitEnable (END)

             ; FUNCTION _CyVdLvAnalogEnable (BEGIN)
                                           ; SOURCE LINE # 1727
0000 900000      R     MOV     DPTR,#reset
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 82  

0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1728
                                           ; SOURCE LINE # 1732
0008 120000      E     LCALL   CyEnterCriticalSection
000B 900000      R     MOV     DPTR,#interruptState
000E EF                MOV     A,R7
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1735
0010 9044C0            MOV     DPTR,#044C0H
0013 E0                MOVX    A,@DPTR
0014 5401              ANL     A,#01H
0016 FF                MOV     R7,A
0017 E4                CLR     A
0018 FC                MOV     R4,A
0019 FD                MOV     R5,A
001A FE                MOV     R6,A
001B 900000      R     MOV     DPTR,#intRegTmp
001E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1738
0021 9044C8            MOV     DPTR,#044C8H
0024 7401              MOV     A,#01H
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1740
0027 9046F7            MOV     DPTR,#046F7H
002A E0                MOVX    A,@DPTR
002B 547F              ANL     A,#07FH
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1742
002E 900000      R     MOV     DPTR,#threshold
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
0033 C4                SWAP    A
0034 54F0              ANL     A,#0F0H
0036 FF                MOV     R7,A
0037 9046F4            MOV     DPTR,#046F4H
003A E0                MOVX    A,@DPTR
003B 540F              ANL     A,#0FH
003D 4F                ORL     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1743
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 4402              ORL     A,#02H
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1746
0044 7F01              MOV     R7,#01H
0046 7E00              MOV     R6,#00H
0048 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1748
004B 7F02              MOV     R7,#02H
004D 120000      R     LCALL   _CyVdStickyStatus
                                           ; SOURCE LINE # 1750
0050 900000      R     MOV     DPTR,#reset
0053 E0                MOVX    A,@DPTR
0054 6009              JZ      ?C0143
                                           ; SOURCE LINE # 1751
                                           ; SOURCE LINE # 1752
0056 9046F7            MOV     DPTR,#046F7H
0059 E0                MOVX    A,@DPTR
005A 4480              ORL     A,#080H
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1753
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 83  

005D 8007              SJMP    ?C0144
005F         ?C0143:
                                           ; SOURCE LINE # 1755
                                           ; SOURCE LINE # 1756
005F 9046F7            MOV     DPTR,#046F7H
0062 E0                MOVX    A,@DPTR
0063 547F              ANL     A,#07FH
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1757
0066         ?C0144:
                                           ; SOURCE LINE # 1760
0066 9044D8            MOV     DPTR,#044D8H
0069 7401              MOV     A,#01H
006B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1763
006C 900000      R     MOV     DPTR,#intRegTmp
006F E0                MOVX    A,@DPTR
0070 A3                INC     DPTR
0071 E0                MOVX    A,@DPTR
0072 A3                INC     DPTR
0073 E0                MOVX    A,@DPTR
0074 A3                INC     DPTR
0075 E0                MOVX    A,@DPTR
0076 9044C0            MOV     DPTR,#044C0H
0079 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1765
007A 900000      R     MOV     DPTR,#interruptState
007D E0                MOVX    A,@DPTR
007E FF                MOV     R7,A
007F 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1766
0082 22                RET     
             ; FUNCTION _CyVdLvAnalogEnable (END)

             ; FUNCTION CyVdLvDigitDisable (BEGIN)
                                           ; SOURCE LINE # 1781
                                           ; SOURCE LINE # 1782
                                           ; SOURCE LINE # 1783
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1784
0007 9046F7            MOV     DPTR,#046F7H
000A E0                MOVX    A,@DPTR
000B 54BF              ANL     A,#0BFH
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1785
000E 7F01              MOV     R7,#01H
0010 120000      R     LCALL   _CyVdStickyStatus
0013         ?C0146:
                                           ; SOURCE LINE # 1787
0013 7F01              MOV     R7,#01H
0015 120000      R     LCALL   _CyVdStickyStatus
0018 EF                MOV     A,R7
0019 20E0F7            JB      ACC.0,?C0146
                                           ; SOURCE LINE # 1788
                                           ; SOURCE LINE # 1790
001C         ?C0147:
                                           ; SOURCE LINE # 1791
001C         ?C0148:
001C 22                RET     
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 84  

             ; FUNCTION CyVdLvDigitDisable (END)

             ; FUNCTION CyVdLvAnalogDisable (BEGIN)
                                           ; SOURCE LINE # 1806
                                           ; SOURCE LINE # 1807
                                           ; SOURCE LINE # 1808
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FD              ANL     A,#0FDH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1809
0007 9046F7            MOV     DPTR,#046F7H
000A E0                MOVX    A,@DPTR
000B 547F              ANL     A,#07FH
000D F0                MOVX    @DPTR,A
000E         ?C0149:
                                           ; SOURCE LINE # 1810
000E 7F02              MOV     R7,#02H
0010 120000      R     LCALL   _CyVdStickyStatus
0013 EF                MOV     A,R7
0014 20E1F7            JB      ACC.1,?C0149
                                           ; SOURCE LINE # 1811
                                           ; SOURCE LINE # 1813
0017         ?C0150:
                                           ; SOURCE LINE # 1814
0017         ?C0151:
0017 22                RET     
             ; FUNCTION CyVdLvAnalogDisable (END)

             ; FUNCTION CyVdHvAnalogEnable (BEGIN)
                                           ; SOURCE LINE # 1829
                                           ; SOURCE LINE # 1830
                                           ; SOURCE LINE # 1834
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#interruptState
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1837
0008 9044C0            MOV     DPTR,#044C0H
000B E0                MOVX    A,@DPTR
000C 5401              ANL     A,#01H
000E FF                MOV     R7,A
000F E4                CLR     A
0010 FC                MOV     R4,A
0011 FD                MOV     R5,A
0012 FE                MOV     R6,A
0013 900000      R     MOV     DPTR,#intRegTmp
0016 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1840
0019 9044C8            MOV     DPTR,#044C8H
001C 7401              MOV     A,#01H
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1842
001F 9046F7            MOV     DPTR,#046F7H
0022 E0                MOVX    A,@DPTR
0023 547F              ANL     A,#07FH
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1844
0026 9046F5            MOV     DPTR,#046F5H
0029 E0                MOVX    A,@DPTR
002A 4404              ORL     A,#04H
002C F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 85  

                                           ; SOURCE LINE # 1847
002D 7F01              MOV     R7,#01H
002F 7E00              MOV     R6,#00H
0031 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1849
0034 7F04              MOV     R7,#04H
0036 120000      R     LCALL   _CyVdStickyStatus
                                           ; SOURCE LINE # 1852
0039 9044D8            MOV     DPTR,#044D8H
003C 7401              MOV     A,#01H
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1855
003F 900000      R     MOV     DPTR,#intRegTmp
0042 E0                MOVX    A,@DPTR
0043 A3                INC     DPTR
0044 E0                MOVX    A,@DPTR
0045 A3                INC     DPTR
0046 E0                MOVX    A,@DPTR
0047 A3                INC     DPTR
0048 E0                MOVX    A,@DPTR
0049 9044C0            MOV     DPTR,#044C0H
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1857
004D 900000      R     MOV     DPTR,#interruptState
0050 E0                MOVX    A,@DPTR
0051 FF                MOV     R7,A
0052 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1858
0055 22                RET     
             ; FUNCTION CyVdHvAnalogEnable (END)

             ; FUNCTION CyVdHvAnalogDisable (BEGIN)
                                           ; SOURCE LINE # 1873
                                           ; SOURCE LINE # 1874
                                           ; SOURCE LINE # 1875
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
0007         ?C0153:
                                           ; SOURCE LINE # 1876
0007 7F04              MOV     R7,#04H
0009 120000      R     LCALL   _CyVdStickyStatus
000C EF                MOV     A,R7
000D 20E2F7            JB      ACC.2,?C0153
                                           ; SOURCE LINE # 1877
                                           ; SOURCE LINE # 1879
0010         ?C0154:
                                           ; SOURCE LINE # 1880
0010         ?C0155:
0010 22                RET     
             ; FUNCTION CyVdHvAnalogDisable (END)

             ; FUNCTION _CyVdStickyStatus (BEGIN)
                                           ; SOURCE LINE # 1909
0000 900000      R     MOV     DPTR,#mask
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1910
                                           ; SOURCE LINE # 1915
0005 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'interruptState' assigned to Register 'R5' ----
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 86  

0008 AD07              MOV     R5,AR7
                                           ; SOURCE LINE # 1917
000A 900000      R     MOV     DPTR,#interruptStatus
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F 9046FA            MOV     DPTR,#046FAH
0012 E0                MOVX    A,@DPTR
0013 FE                MOV     R6,A
0014 EF                MOV     A,R7
0015 4E                ORL     A,R6
0016 900000      R     MOV     DPTR,#interruptStatus
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1918
001A E0                MOVX    A,@DPTR
001B FC                MOV     R4,A
001C 5407              ANL     A,#07H
001E 900000      R     MOV     DPTR,#tmpStatus
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1919
0022 900000      R     MOV     DPTR,#mask
0025 E0                MOVX    A,@DPTR
0026 F4                CPL     A
0027 FF                MOV     R7,A
0028 EC                MOV     A,R4
0029 5F                ANL     A,R7
002A 900000      R     MOV     DPTR,#interruptStatus
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1921
002E AF05              MOV     R7,AR5
0030 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1923
0033 900000      R     MOV     DPTR,#tmpStatus
0036 E0                MOVX    A,@DPTR
0037 FF                MOV     R7,A
                                           ; SOURCE LINE # 1924
0038         ?C0156:
0038 22                RET     
             ; FUNCTION _CyVdStickyStatus (END)

             ; FUNCTION CyVdRealTimeStatus (BEGIN)
                                           ; SOURCE LINE # 1949
                                           ; SOURCE LINE # 1950
                                           ; SOURCE LINE # 1954
0000 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'interruptState' assigned to Register 'R5' ----
0003 AD07              MOV     R5,AR7
                                           ; SOURCE LINE # 1955
0005 9046FC            MOV     DPTR,#046FCH
0008 E0                MOVX    A,@DPTR
0009 5407              ANL     A,#07H
000B 900000      R     MOV     DPTR,#vdFlagsState
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1956
000F 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1958
0012 900000      R     MOV     DPTR,#vdFlagsState
0015 E0                MOVX    A,@DPTR
0016 FF                MOV     R7,A
                                           ; SOURCE LINE # 1959
0017         ?C0157:
0017 22                RET     
             ; FUNCTION CyVdRealTimeStatus (END)
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 87  


             ; FUNCTION CyDisableInts (BEGIN)
                                           ; SOURCE LINE # 1972
                                           ; SOURCE LINE # 1973
                                           ; SOURCE LINE # 1977
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#interruptState
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1982
0008 9044C8            MOV     DPTR,#044C8H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D E4                CLR     A
000E FC                MOV     R4,A
000F FD                MOV     R5,A
0010 FE                MOV     R6,A
0011 900000      R     MOV     DPTR,#intState
0014 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1983
0017 900000      R     MOV     DPTR,#intState
001A E0                MOVX    A,@DPTR
001B F8                MOV     R0,A
001C A3                INC     DPTR
001D E0                MOVX    A,@DPTR
001E F9                MOV     R1,A
001F A3                INC     DPTR
0020 E0                MOVX    A,@DPTR
0021 FA                MOV     R2,A
0022 A3                INC     DPTR
0023 E0                MOVX    A,@DPTR
0024 FB                MOV     R3,A
0025 C000              PUSH    AR0
0027 9044C9            MOV     DPTR,#044C9H
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C E4                CLR     A
002D FC                MOV     R4,A
002E FD                MOV     R5,A
002F FE                MOV     R6,A
0030 7808              MOV     R0,#08H
0032 120000      E     LCALL   ?C?LSHL
0035 D000              POP     AR0
0037 EB                MOV     A,R3
0038 4F                ORL     A,R7
0039 FF                MOV     R7,A
003A EA                MOV     A,R2
003B 4E                ORL     A,R6
003C FE                MOV     R6,A
003D E9                MOV     A,R1
003E 4D                ORL     A,R5
003F FD                MOV     R5,A
0040 E8                MOV     A,R0
0041 4C                ORL     A,R4
0042 FC                MOV     R4,A
0043 900000      R     MOV     DPTR,#intState
0046 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1984
0049 900000      R     MOV     DPTR,#intState
004C E0                MOVX    A,@DPTR
004D F8                MOV     R0,A
004E A3                INC     DPTR
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 88  

004F E0                MOVX    A,@DPTR
0050 F9                MOV     R1,A
0051 A3                INC     DPTR
0052 E0                MOVX    A,@DPTR
0053 FA                MOV     R2,A
0054 A3                INC     DPTR
0055 E0                MOVX    A,@DPTR
0056 FB                MOV     R3,A
0057 C000              PUSH    AR0
0059 9044CA            MOV     DPTR,#044CAH
005C E0                MOVX    A,@DPTR
005D FF                MOV     R7,A
005E E4                CLR     A
005F FC                MOV     R4,A
0060 FD                MOV     R5,A
0061 FE                MOV     R6,A
0062 7810              MOV     R0,#010H
0064 120000      E     LCALL   ?C?LSHL
0067 D000              POP     AR0
0069 EB                MOV     A,R3
006A 4F                ORL     A,R7
006B FF                MOV     R7,A
006C EA                MOV     A,R2
006D 4E                ORL     A,R6
006E FE                MOV     R6,A
006F E9                MOV     A,R1
0070 4D                ORL     A,R5
0071 FD                MOV     R5,A
0072 E8                MOV     A,R0
0073 4C                ORL     A,R4
0074 FC                MOV     R4,A
0075 900000      R     MOV     DPTR,#intState
0078 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1985
007B 900000      R     MOV     DPTR,#intState
007E E0                MOVX    A,@DPTR
007F F8                MOV     R0,A
0080 A3                INC     DPTR
0081 E0                MOVX    A,@DPTR
0082 F9                MOV     R1,A
0083 A3                INC     DPTR
0084 E0                MOVX    A,@DPTR
0085 FA                MOV     R2,A
0086 A3                INC     DPTR
0087 E0                MOVX    A,@DPTR
0088 FB                MOV     R3,A
0089 C000              PUSH    AR0
008B 9044CB            MOV     DPTR,#044CBH
008E E0                MOVX    A,@DPTR
008F FF                MOV     R7,A
0090 E4                CLR     A
0091 FC                MOV     R4,A
0092 FD                MOV     R5,A
0093 FE                MOV     R6,A
0094 7818              MOV     R0,#018H
0096 120000      E     LCALL   ?C?LSHL
0099 D000              POP     AR0
009B EB                MOV     A,R3
009C 4F                ORL     A,R7
009D FF                MOV     R7,A
009E EA                MOV     A,R2
009F 4E                ORL     A,R6
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 89  

00A0 FE                MOV     R6,A
00A1 E9                MOV     A,R1
00A2 4D                ORL     A,R5
00A3 FD                MOV     R5,A
00A4 E8                MOV     A,R0
00A5 4C                ORL     A,R4
00A6 FC                MOV     R4,A
00A7 900000      R     MOV     DPTR,#intState
00AA 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1989
00AD 9044C8            MOV     DPTR,#044C8H
00B0 74FF              MOV     A,#0FFH
00B2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1990
00B3 A3                INC     DPTR
00B4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1991
00B5 A3                INC     DPTR
00B6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1992
00B7 A3                INC     DPTR
00B8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2004
00B9 900000      R     MOV     DPTR,#interruptState
00BC E0                MOVX    A,@DPTR
00BD FF                MOV     R7,A
00BE 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2006
00C1 900000      R     MOV     DPTR,#intState
00C4 E0                MOVX    A,@DPTR
00C5 FC                MOV     R4,A
00C6 A3                INC     DPTR
00C7 E0                MOVX    A,@DPTR
00C8 FD                MOV     R5,A
00C9 A3                INC     DPTR
00CA E0                MOVX    A,@DPTR
00CB FE                MOV     R6,A
00CC A3                INC     DPTR
00CD E0                MOVX    A,@DPTR
00CE FF                MOV     R7,A
                                           ; SOURCE LINE # 2007
00CF         ?C0158:
00CF 22                RET     
             ; FUNCTION CyDisableInts (END)

             ; FUNCTION _CyEnableInts (BEGIN)
                                           ; SOURCE LINE # 2019
0000 900000      R     MOV     DPTR,#mask
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2020
                                           ; SOURCE LINE # 2024
0006 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'interruptState' assigned to Register 'R3' ----
0009 AB07              MOV     R3,AR7
                                           ; SOURCE LINE # 2029
000B 900000      R     MOV     DPTR,#mask
000E E0                MOVX    A,@DPTR
000F FC                MOV     R4,A
0010 A3                INC     DPTR
0011 E0                MOVX    A,@DPTR
0012 FD                MOV     R5,A
0013 A3                INC     DPTR
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 90  

0014 E0                MOVX    A,@DPTR
0015 FE                MOV     R6,A
0016 A3                INC     DPTR
0017 E0                MOVX    A,@DPTR
0018 FF                MOV     R7,A
0019 7818              MOV     R0,#018H
001B 120000      E     LCALL   ?C?ULSHR
001E 9044C3            MOV     DPTR,#044C3H
0021 EF                MOV     A,R7
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2030
0023 900000      R     MOV     DPTR,#mask
0026 E0                MOVX    A,@DPTR
0027 FC                MOV     R4,A
0028 A3                INC     DPTR
0029 E0                MOVX    A,@DPTR
002A FD                MOV     R5,A
002B A3                INC     DPTR
002C E0                MOVX    A,@DPTR
002D FE                MOV     R6,A
002E A3                INC     DPTR
002F E0                MOVX    A,@DPTR
0030 FF                MOV     R7,A
0031 7810              MOV     R0,#010H
0033 120000      E     LCALL   ?C?ULSHR
0036 9044C2            MOV     DPTR,#044C2H
0039 EF                MOV     A,R7
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2031
003B 900000      R     MOV     DPTR,#mask
003E E0                MOVX    A,@DPTR
003F FC                MOV     R4,A
0040 A3                INC     DPTR
0041 E0                MOVX    A,@DPTR
0042 FD                MOV     R5,A
0043 A3                INC     DPTR
0044 E0                MOVX    A,@DPTR
0045 FE                MOV     R6,A
0046 A3                INC     DPTR
0047 E0                MOVX    A,@DPTR
0048 FF                MOV     R7,A
0049 7808              MOV     R0,#08H
004B 120000      E     LCALL   ?C?ULSHR
004E 9044C1            MOV     DPTR,#044C1H
0051 EF                MOV     A,R7
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2032
0053 900000      R     MOV     DPTR,#mask
0056 E0                MOVX    A,@DPTR
0057 A3                INC     DPTR
0058 E0                MOVX    A,@DPTR
0059 A3                INC     DPTR
005A E0                MOVX    A,@DPTR
005B A3                INC     DPTR
005C E0                MOVX    A,@DPTR
005D 9044C0            MOV     DPTR,#044C0H
0060 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2040
0061 AF03              MOV     R7,AR3
0063 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2042
0066 22                RET     
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 91  

             ; FUNCTION _CyEnableInts (END)

             ; FUNCTION IntDefaultHandler (BEGIN)
                                           ; SOURCE LINE # 2304
0000         ?C0160:
                                           ; SOURCE LINE # 2310
                                           ; SOURCE LINE # 2311
                                           ; SOURCE LINE # 2316
0000 80FE              SJMP    ?C0160
0002 32                RETI    
             ; FUNCTION IntDefaultHandler (END)

             ; FUNCTION CyIntInitVectors (BEGIN)
                                           ; SOURCE LINE # 2328
                                           ; SOURCE LINE # 2329
                                           ; SOURCE LINE # 2332
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#i
0004 F0                MOVX    @DPTR,A
0005         ?C0163:
0005 900000      R     MOV     DPTR,#i
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A D3                SETB    C
000B 941F              SUBB    A,#01FH
000D 5020              JNC     ?C0166
                                           ; SOURCE LINE # 2333
                                           ; SOURCE LINE # 2334
000F EF                MOV     A,R7
0010 75F002            MOV     B,#02H
0013 A4                MUL     AB
0014 2400              ADD     A,#00H
0016 FF                MOV     R7,A
0017 E5F0              MOV     A,B
0019 3444              ADDC    A,#044H
001B FA                MOV     R2,A
001C A907              MOV     R1,AR7
001E 7B01              MOV     R3,#01H
0020 7C00        R     MOV     R4,#HIGH IntDefaultHandler
0022 7D00        R     MOV     R5,#LOW IntDefaultHandler
0024 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 2335
0027 900000      R     MOV     DPTR,#i
002A E0                MOVX    A,@DPTR
002B 04                INC     A
002C F0                MOVX    @DPTR,A
002D 80D6              SJMP    ?C0163
                                           ; SOURCE LINE # 2336
002F         ?C0166:
002F 22                RET     
             ; FUNCTION CyIntInitVectors (END)

             ; FUNCTION _CyIntSetVector (BEGIN)
                                           ; SOURCE LINE # 2352
0000 900000      R     MOV     DPTR,#address
0003 EC                MOV     A,R4
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
0008 900000      R     MOV     DPTR,#number
000B EF                MOV     A,R7
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 92  

000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2353
                                           ; SOURCE LINE # 2359
000D 541F              ANL     A,#01FH
000F 25E0              ADD     A,ACC
0011 FF                MOV     R7,A
0012 E4                CLR     A
0013 33                RLC     A
0014 FE                MOV     R6,A
0015 E4                CLR     A
0016 2F                ADD     A,R7
0017 FF                MOV     R7,A
0018 EE                MOV     A,R6
0019 3444              ADDC    A,#044H
001B FA                MOV     R2,A
001C A907              MOV     R1,AR7
001E 7B01              MOV     R3,#01H
0020 120000      E     LCALL   _cyread16_nodpx
0023 900000      R     MOV     DPTR,#oldIsr
0026 EE                MOV     A,R6
0027 F0                MOVX    @DPTR,A
0028 A3                INC     DPTR
0029 EF                MOV     A,R7
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2363
002B 900000      R     MOV     DPTR,#number
002E E0                MOVX    A,@DPTR
002F 75F002            MOV     B,#02H
0032 A4                MUL     AB
0033 2400              ADD     A,#00H
0035 FF                MOV     R7,A
0036 E5F0              MOV     A,B
0038 3444              ADDC    A,#044H
003A FA                MOV     R2,A
003B A907              MOV     R1,AR7
003D 7B01              MOV     R3,#01H
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 FE                MOV     R6,A
0042 A3                INC     DPTR
0043 E0                MOVX    A,@DPTR
0044 FF                MOV     R7,A
0045 FD                MOV     R5,A
0046 AC06              MOV     R4,AR6
0048 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 2365
004B 900000      R     MOV     DPTR,#oldIsr
004E E0                MOVX    A,@DPTR
004F FE                MOV     R6,A
0050 A3                INC     DPTR
0051 E0                MOVX    A,@DPTR
0052 FF                MOV     R7,A
                                           ; SOURCE LINE # 2366
0053         ?C0167:
0053 22                RET     
             ; FUNCTION _CyIntSetVector (END)

             ; FUNCTION _CyIntGetVector (BEGIN)
                                           ; SOURCE LINE # 2381
;---- Variable 'number' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2382
                                           ; SOURCE LINE # 2385
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 93  

0000 EF                MOV     A,R7
0001 541F              ANL     A,#01FH
0003 25E0              ADD     A,ACC
0005 FF                MOV     R7,A
0006 E4                CLR     A
0007 33                RLC     A
0008 FE                MOV     R6,A
0009 E4                CLR     A
000A 2F                ADD     A,R7
000B FF                MOV     R7,A
000C EE                MOV     A,R6
000D 3444              ADDC    A,#044H
000F FA                MOV     R2,A
0010 A907              MOV     R1,AR7
0012 7B01              MOV     R3,#01H
0014 120000      E     LCALL   _cyread16_nodpx
                                           ; SOURCE LINE # 2387
0017         ?C0168:
0017 22                RET     
             ; FUNCTION _CyIntGetVector (END)

             ; FUNCTION _CyIntSetPriority (BEGIN)
                                           ; SOURCE LINE # 2400
;---- Variable 'priority' assigned to Register 'R5' ----
;---- Variable 'number' assigned to Register 'R4' ----
0000 AC07              MOV     R4,AR7
                                           ; SOURCE LINE # 2401
                                           ; SOURCE LINE # 2406
0002 ED                MOV     A,R5
0003 5407              ANL     A,#07H
0005 75F020            MOV     B,#020H
0008 A4                MUL     AB
0009 FF                MOV     R7,A
000A EC                MOV     A,R4
000B 541F              ANL     A,#01FH
000D 2480              ADD     A,#080H
000F F582              MOV     DPL,A
0011 E4                CLR     A
0012 3444              ADDC    A,#044H
0014 F583              MOV     DPH,A
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2408
0018 22                RET     
             ; FUNCTION _CyIntSetPriority (END)

             ; FUNCTION _CyIntGetPriority (BEGIN)
                                           ; SOURCE LINE # 2423
;---- Variable 'number' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2424
                                           ; SOURCE LINE # 2429
0000 EF                MOV     A,R7
0001 541F              ANL     A,#01FH
0003 2480              ADD     A,#080H
0005 F582              MOV     DPL,A
0007 E4                CLR     A
0008 3444              ADDC    A,#044H
000A F583              MOV     DPH,A
000C E0                MOVX    A,@DPTR
000D FF                MOV     R7,A
000E C4                SWAP    A
000F 13                RRC     A
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 94  

0010 5407              ANL     A,#07H
0012 FF                MOV     R7,A
;---- Variable 'priority' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2431
                                           ; SOURCE LINE # 2432
0013         ?C0170:
0013 22                RET     
             ; FUNCTION _CyIntGetPriority (END)

             ; FUNCTION _CyIntGetState (BEGIN)
                                           ; SOURCE LINE # 2447
;---- Variable 'number' assigned to Register 'R5' ----
0000 AD07              MOV     R5,AR7
                                           ; SOURCE LINE # 2448
                                           ; SOURCE LINE # 2454
0002 ED                MOV     A,R5
0003 541F              ANL     A,#01FH
0005 7E00              MOV     R6,#00H
0007 7803              MOV     R0,#03H
0009         ?C0180:
0009 CE                XCH     A,R6
000A C3                CLR     C
000B 13                RRC     A
000C CE                XCH     A,R6
000D 13                RRC     A
000E D8F9              DJNZ    R0,?C0180
0010 24C0              ADD     A,#0C0H
0012 FF                MOV     R7,A
0013 EE                MOV     A,R6
0014 3444              ADDC    A,#044H
0016 FE                MOV     R6,A
;---- Variable 'stateReg' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 2457
0017 ED                MOV     A,R5
0018 5407              ANL     A,#07H
001A FD                MOV     R5,A
001B 7401              MOV     A,#01H
001D A805              MOV     R0,AR5
001F 08                INC     R0
0020 8002              SJMP    ?C0182
0022         ?C0181:
0022 C3                CLR     C
0023 33                RLC     A
0024         ?C0182:
0024 D8FC              DJNZ    R0,?C0181
0026 FD                MOV     R5,A
0027 8F82              MOV     DPL,R7
0029 8E83              MOV     DPH,R6
002B E0                MOVX    A,@DPTR
002C 5D                ANL     A,R5
002D 6004              JZ      ?C0171
002F 7F01              MOV     R7,#01H
0031 8002              SJMP    ?C0172
0033         ?C0171:
0033 7F00              MOV     R7,#00H
0035         ?C0172:
                                           ; SOURCE LINE # 2458
0035         ?C0173:
0035 22                RET     
             ; FUNCTION _CyIntGetState (END)

             ; FUNCTION _CyGetUniqueId (BEGIN)
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 95  

                                           ; SOURCE LINE # 2885
0000 900000      R     MOV     DPTR,#uniqueId
0003 EB                MOV     A,R3
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EA                MOV     A,R2
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 E9                MOV     A,R1
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2886
                                           ; SOURCE LINE # 2898
000B 7B0C              MOV     R3,#0CH
000D 7A01              MOV     R2,#01H
000F 7903              MOV     R1,#03H
0011 120000      E     LCALL   _cyread8
0014 E4                CLR     A
0015 FC                MOV     R4,A
0016 FD                MOV     R5,A
0017 FE                MOV     R6,A
0018 900000      R     MOV     DPTR,#uniqueId
001B E0                MOVX    A,@DPTR
001C FB                MOV     R3,A
001D A3                INC     DPTR
001E E0                MOVX    A,@DPTR
001F FA                MOV     R2,A
0020 A3                INC     DPTR
0021 E0                MOVX    A,@DPTR
0022 F9                MOV     R1,A
0023 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 2899
0026 900000      R     MOV     DPTR,#uniqueId
0029 E0                MOVX    A,@DPTR
002A FB                MOV     R3,A
002B A3                INC     DPTR
002C E0                MOVX    A,@DPTR
002D FA                MOV     R2,A
002E A3                INC     DPTR
002F E0                MOVX    A,@DPTR
0030 F9                MOV     R1,A
0031 C003              PUSH    AR3
0033 C002              PUSH    AR2
0035 C001              PUSH    AR1
0037 120000      E     LCALL   ?C?LLDPTR
003A C004              PUSH    AR4
003C C005              PUSH    AR5
003E C006              PUSH    AR6
0040 C007              PUSH    AR7
0042 7B0C              MOV     R3,#0CH
0044 7A01              MOV     R2,#01H
0046 7904              MOV     R1,#04H
0048 120000      E     LCALL   _cyread8
004B E4                CLR     A
004C FC                MOV     R4,A
004D FD                MOV     R5,A
004E FE                MOV     R6,A
004F 7808              MOV     R0,#08H
0051 120000      E     LCALL   ?C?LSHL
0054 A804              MOV     R0,AR4
0056 A905              MOV     R1,AR5
0058 AA06              MOV     R2,AR6
005A AB07              MOV     R3,AR7
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 96  

005C D007              POP     AR7
005E D006              POP     AR6
0060 D005              POP     AR5
0062 D004              POP     AR4
0064 EF                MOV     A,R7
0065 4B                ORL     A,R3
0066 FF                MOV     R7,A
0067 EE                MOV     A,R6
0068 4A                ORL     A,R2
0069 FE                MOV     R6,A
006A ED                MOV     A,R5
006B 49                ORL     A,R1
006C FD                MOV     R5,A
006D EC                MOV     A,R4
006E 48                ORL     A,R0
006F FC                MOV     R4,A
0070 D001              POP     AR1
0072 D002              POP     AR2
0074 D003              POP     AR3
0076 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 2900
0079 900000      R     MOV     DPTR,#uniqueId
007C E0                MOVX    A,@DPTR
007D FB                MOV     R3,A
007E A3                INC     DPTR
007F E0                MOVX    A,@DPTR
0080 FA                MOV     R2,A
0081 A3                INC     DPTR
0082 E0                MOVX    A,@DPTR
0083 F9                MOV     R1,A
0084 C003              PUSH    AR3
0086 C002              PUSH    AR2
0088 C001              PUSH    AR1
008A 120000      E     LCALL   ?C?LLDPTR
008D C004              PUSH    AR4
008F C005              PUSH    AR5
0091 C006              PUSH    AR6
0093 C007              PUSH    AR7
0095 7B00              MOV     R3,#00H
0097 7A46              MOV     R2,#046H
0099 79EC              MOV     R1,#0ECH
009B 120000      E     LCALL   _cyread8
009E E4                CLR     A
009F FC                MOV     R4,A
00A0 FD                MOV     R5,A
00A1 FE                MOV     R6,A
00A2 7810              MOV     R0,#010H
00A4 120000      E     LCALL   ?C?LSHL
00A7 A804              MOV     R0,AR4
00A9 A905              MOV     R1,AR5
00AB AA06              MOV     R2,AR6
00AD AB07              MOV     R3,AR7
00AF D007              POP     AR7
00B1 D006              POP     AR6
00B3 D005              POP     AR5
00B5 D004              POP     AR4
00B7 EF                MOV     A,R7
00B8 4B                ORL     A,R3
00B9 FF                MOV     R7,A
00BA EE                MOV     A,R6
00BB 4A                ORL     A,R2
00BC FE                MOV     R6,A
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 97  

00BD ED                MOV     A,R5
00BE 49                ORL     A,R1
00BF FD                MOV     R5,A
00C0 EC                MOV     A,R4
00C1 48                ORL     A,R0
00C2 FC                MOV     R4,A
00C3 D001              POP     AR1
00C5 D002              POP     AR2
00C7 D003              POP     AR3
00C9 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 2901
00CC 900000      R     MOV     DPTR,#uniqueId
00CF E0                MOVX    A,@DPTR
00D0 FB                MOV     R3,A
00D1 A3                INC     DPTR
00D2 E0                MOVX    A,@DPTR
00D3 FA                MOV     R2,A
00D4 A3                INC     DPTR
00D5 E0                MOVX    A,@DPTR
00D6 F9                MOV     R1,A
00D7 C003              PUSH    AR3
00D9 C002              PUSH    AR2
00DB C001              PUSH    AR1
00DD 120000      E     LCALL   ?C?LLDPTR
00E0 C004              PUSH    AR4
00E2 C005              PUSH    AR5
00E4 C006              PUSH    AR6
00E6 C007              PUSH    AR7
00E8 7B0C              MOV     R3,#0CH
00EA 7A01              MOV     R2,#01H
00EC 7902              MOV     R1,#02H
00EE 120000      E     LCALL   _cyread8
00F1 E4                CLR     A
00F2 FC                MOV     R4,A
00F3 FD                MOV     R5,A
00F4 FE                MOV     R6,A
00F5 7818              MOV     R0,#018H
00F7 120000      E     LCALL   ?C?LSHL
00FA A804              MOV     R0,AR4
00FC A905              MOV     R1,AR5
00FE AA06              MOV     R2,AR6
0100 AB07              MOV     R3,AR7
0102 D007              POP     AR7
0104 D006              POP     AR6
0106 D005              POP     AR5
0108 D004              POP     AR4
010A EF                MOV     A,R7
010B 4B                ORL     A,R3
010C FF                MOV     R7,A
010D EE                MOV     A,R6
010E 4A                ORL     A,R2
010F FE                MOV     R6,A
0110 ED                MOV     A,R5
0111 49                ORL     A,R1
0112 FD                MOV     R5,A
0113 EC                MOV     A,R4
0114 48                ORL     A,R0
0115 FC                MOV     R4,A
0116 D001              POP     AR1
0118 D002              POP     AR2
011A D003              POP     AR3
011C 120000      E     LCALL   ?C?LSTPTR
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 98  

                                           ; SOURCE LINE # 2903
011F 7B0C              MOV     R3,#0CH
0121 7A01              MOV     R2,#01H
0123 7901              MOV     R1,#01H
0125 120000      E     LCALL   _cyread8
0128 E4                CLR     A
0129 FC                MOV     R4,A
012A FD                MOV     R5,A
012B FE                MOV     R6,A
012C 900000      R     MOV     DPTR,#uniqueId
012F E0                MOVX    A,@DPTR
0130 FB                MOV     R3,A
0131 A3                INC     DPTR
0132 E0                MOVX    A,@DPTR
0133 FA                MOV     R2,A
0134 A3                INC     DPTR
0135 E0                MOVX    A,@DPTR
0136 2404              ADD     A,#04H
0138 F9                MOV     R1,A
0139 E4                CLR     A
013A 3A                ADDC    A,R2
013B FA                MOV     R2,A
013C 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 2904
013F 900000      R     MOV     DPTR,#uniqueId
0142 E0                MOVX    A,@DPTR
0143 FB                MOV     R3,A
0144 A3                INC     DPTR
0145 E0                MOVX    A,@DPTR
0146 FA                MOV     R2,A
0147 A3                INC     DPTR
0148 E0                MOVX    A,@DPTR
0149 2404              ADD     A,#04H
014B F9                MOV     R1,A
014C E4                CLR     A
014D 3A                ADDC    A,R2
014E FA                MOV     R2,A
014F C003              PUSH    AR3
0151 C002              PUSH    AR2
0153 C001              PUSH    AR1
0155 120000      E     LCALL   ?C?LLDPTR
0158 C004              PUSH    AR4
015A C005              PUSH    AR5
015C C006              PUSH    AR6
015E C007              PUSH    AR7
0160 7B0C              MOV     R3,#0CH
0162 7A01              MOV     R2,#01H
0164 7900              MOV     R1,#00H
0166 120000      E     LCALL   _cyread8
0169 E4                CLR     A
016A FC                MOV     R4,A
016B FD                MOV     R5,A
016C FE                MOV     R6,A
016D 7808              MOV     R0,#08H
016F 120000      E     LCALL   ?C?LSHL
0172 A804              MOV     R0,AR4
0174 A905              MOV     R1,AR5
0176 AA06              MOV     R2,AR6
0178 AB07              MOV     R3,AR7
017A D007              POP     AR7
017C D006              POP     AR6
017E D005              POP     AR5
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 99  

0180 D004              POP     AR4
0182 EF                MOV     A,R7
0183 4B                ORL     A,R3
0184 FF                MOV     R7,A
0185 EE                MOV     A,R6
0186 4A                ORL     A,R2
0187 FE                MOV     R6,A
0188 ED                MOV     A,R5
0189 49                ORL     A,R1
018A FD                MOV     R5,A
018B EC                MOV     A,R4
018C 48                ORL     A,R0
018D FC                MOV     R4,A
018E D001              POP     AR1
0190 D002              POP     AR2
0192 D003              POP     AR3
0194 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 2905
0197 900000      R     MOV     DPTR,#uniqueId
019A E0                MOVX    A,@DPTR
019B FB                MOV     R3,A
019C A3                INC     DPTR
019D E0                MOVX    A,@DPTR
019E FA                MOV     R2,A
019F A3                INC     DPTR
01A0 E0                MOVX    A,@DPTR
01A1 2404              ADD     A,#04H
01A3 F9                MOV     R1,A
01A4 E4                CLR     A
01A5 3A                ADDC    A,R2
01A6 FA                MOV     R2,A
01A7 C003              PUSH    AR3
01A9 C002              PUSH    AR2
01AB C001              PUSH    AR1
01AD 120000      E     LCALL   ?C?LLDPTR
01B0 C004              PUSH    AR4
01B2 C005              PUSH    AR5
01B4 C006              PUSH    AR6
01B6 C007              PUSH    AR7
01B8 7B0C              MOV     R3,#0CH
01BA 7A01              MOV     R2,#01H
01BC 7905              MOV     R1,#05H
01BE 120000      E     LCALL   _cyread8
01C1 E4                CLR     A
01C2 FC                MOV     R4,A
01C3 FD                MOV     R5,A
01C4 FE                MOV     R6,A
01C5 7810              MOV     R0,#010H
01C7 120000      E     LCALL   ?C?LSHL
01CA A804              MOV     R0,AR4
01CC A905              MOV     R1,AR5
01CE AA06              MOV     R2,AR6
01D0 AB07              MOV     R3,AR7
01D2 D007              POP     AR7
01D4 D006              POP     AR6
01D6 D005              POP     AR5
01D8 D004              POP     AR4
01DA EF                MOV     A,R7
01DB 4B                ORL     A,R3
01DC FF                MOV     R7,A
01DD EE                MOV     A,R6
01DE 4A                ORL     A,R2
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 100 

01DF FE                MOV     R6,A
01E0 ED                MOV     A,R5
01E1 49                ORL     A,R1
01E2 FD                MOV     R5,A
01E3 EC                MOV     A,R4
01E4 48                ORL     A,R0
01E5 FC                MOV     R4,A
01E6 D001              POP     AR1
01E8 D002              POP     AR2
01EA D003              POP     AR3
01EC 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 2906
01EF 900000      R     MOV     DPTR,#uniqueId
01F2 E0                MOVX    A,@DPTR
01F3 FB                MOV     R3,A
01F4 A3                INC     DPTR
01F5 E0                MOVX    A,@DPTR
01F6 FA                MOV     R2,A
01F7 A3                INC     DPTR
01F8 E0                MOVX    A,@DPTR
01F9 2404              ADD     A,#04H
01FB F9                MOV     R1,A
01FC E4                CLR     A
01FD 3A                ADDC    A,R2
01FE FA                MOV     R2,A
01FF C003              PUSH    AR3
0201 C002              PUSH    AR2
0203 C001              PUSH    AR1
0205 120000      E     LCALL   ?C?LLDPTR
0208 C004              PUSH    AR4
020A C005              PUSH    AR5
020C C006              PUSH    AR6
020E C007              PUSH    AR7
0210 7B0C              MOV     R3,#0CH
0212 7A01              MOV     R2,#01H
0214 7906              MOV     R1,#06H
0216 120000      E     LCALL   _cyread8
0219 E4                CLR     A
021A FC                MOV     R4,A
021B FD                MOV     R5,A
021C FE                MOV     R6,A
021D 7818              MOV     R0,#018H
021F 120000      E     LCALL   ?C?LSHL
0222 A804              MOV     R0,AR4
0224 A905              MOV     R1,AR5
0226 AA06              MOV     R2,AR6
0228 AB07              MOV     R3,AR7
022A D007              POP     AR7
022C D006              POP     AR6
022E D005              POP     AR5
0230 D004              POP     AR4
0232 EF                MOV     A,R7
0233 4B                ORL     A,R3
0234 FF                MOV     R7,A
0235 EE                MOV     A,R6
0236 4A                ORL     A,R2
0237 FE                MOV     R6,A
0238 ED                MOV     A,R5
0239 49                ORL     A,R1
023A FD                MOV     R5,A
023B EC                MOV     A,R4
023C 48                ORL     A,R0
C51 COMPILER V9.51   CYLIB                                                                 02/07/2017 16:12:21 PAGE 101 

023D FC                MOV     R4,A
023E D001              POP     AR1
0240 D002              POP     AR2
0242 D003              POP     AR3
0244 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 2908
0247 22                RET     
             ; FUNCTION _CyGetUniqueId (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3697    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     15      62
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
