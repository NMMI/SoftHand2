C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Release\ADC.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\4.0\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -Generated_Source\PSoC3\ADC.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB DF(NDEBUG) WL(2
                    -) PR(.\DP8051_Keil_951\Release/ADC.lst) CD OT(8,SPEED) OJ(.\DP8051_Keil_951\Release\ADC.obj)

line level    source

*** MESSAGE C286 IN LINE 0 OF (null): license limits optimization to level 5
   1          /*******************************************************************************
   2          * File Name: ADC.c
   3          * Version 3.20
   4          *
   5          * Description:
   6          *  This file provides the source code to the API for the Delta-Sigma ADC
   7          *  Component.
   8          *
   9          * Note:
  10          *
  11          ********************************************************************************
  12          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  13          * You may use this file only in accordance with the license, terms, conditions,
  14          * disclaimers, and limitations in the end user license agreement accompanying
  15          * the software package with which this file was provided.
  16          *******************************************************************************/
  17          
  18          #include "ADC.h"
  19          
  20          #if(ADC_DEFAULT_INTERNAL_CLK)
  21              #include "ADC_theACLK.h"
  22          #endif /* ADC_DEFAULT_INTERNAL_CLK */
  23          
  24          #include "ADC_Ext_CP_Clk.h"
  25          
  26          #if(ADC_DEFAULT_INPUT_MODE)
  27              #include "ADC_AMux.h"
  28          #endif /* ADC_DEFAULT_INPUT_MODE */
  29          
  30          
  31          /***************************************
  32          * Global data allocation
  33          ***************************************/
  34          
  35          /* Software flag for checking conversion completed or not */
  36          volatile uint8 ADC_convDone = 0u;
  37          
  38          /* Software flag to stop conversion for single sample conversion mode
  39          *   with resolution above 16 bits 
  40          */
  41          volatile uint8 ADC_stopConversion = 0u;
  42          
  43          /* To run the initialization block only at the start up */
  44          uint8 ADC_initVar = 0u;
  45          
  46          /* To check whether ADC started or not before switching the configuration */
  47          volatile uint8 ADC_started = 0u;
  48          
  49          /* Flag to hold ADC config number. By default active config is 1. */
  50          volatile uint8 ADC_Config = 1u;
  51          
  52          volatile int32 ADC_Offset;
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 2   

  53          volatile int32 ADC_CountsPerVolt;
  54          
  55          
  56          /***************************************
  57          * Local data allocation
  58          ***************************************/
  59          
  60          /* The array with precalculated gain compensation coefficients */
  61          static ADC_GCOR_STRUCT ADC_gcor[ADC_DEFAULT_NUM_CONFIGS];
  62          
  63          
  64          
  65          /***************************************
  66          * Forward function references
  67          ***************************************/
  68          static void ADC_InitConfig(uint8 config) ;
  69          static void ADC_GainCompensation(uint8 inputRange, uint16 idealDecGain, uint16 idealOddDecGain, 
  70                                      uint8 resolution, uint8 config) ;
  71          static void ADC_SetDSMRef0Reg(uint8 value) ;
  72          
  73          
  74          /******************************************************************************
  75          * Function Name: ADC_Init
  76          *******************************************************************************
  77          *
  78          * Summary:
  79          *  Initialize component's parameters to the parameters set by user in the
  80          *  customizer of the component placed onto schematic. Usually called in
  81          * ADC_Start().
  82          *
  83          *
  84          * Parameters:
  85          *  None
  86          *
  87          * Return:
  88          *  None
  89          *
  90          *******************************************************************************/
  91          void ADC_Init(void) 
  92          {
  93   1      
  94   1          ADC_Config = 1u;
  95   1          ADC_convDone = 0u;
  96   1      
  97   1          ADC_Ext_CP_Clk_SetMode(CYCLK_DUTY);
  98   1      
  99   1          /* This is only valid if there is an internal clock */
 100   1          #if(ADC_DEFAULT_INTERNAL_CLK)
 101   1              ADC_theACLK_SetMode(CYCLK_DUTY);
 102   1          #endif /* ADC_DEFAULT_INTERNAL_CLK */
 103   1      
 104   1          #if(ADC_IRQ_REMOVE == 0u)
 105   1              /* Set interrupt priority */
 106   1              CyIntSetPriority(ADC_INTC_NUMBER, ADC_INTC_PRIOR_NUMBER);
 107   1          #endif   /* End ADC_IRQ_REMOVE */
 108   1      
 109   1          /* Init static registers with common configuration */
 110   1          ADC_DSM_DEM0_REG    = ADC_CFG1_DSM_DEM0;
 111   1          ADC_DSM_DEM1_REG    = ADC_CFG1_DSM_DEM1;
 112   1          ADC_DSM_MISC_REG    = ADC_CFG1_DSM_MISC;
 113   1          ADC_DSM_CLK_REG    |= ADC_CFG1_DSM_CLK;
 114   1          ADC_DSM_REF1_REG    = ADC_CFG1_DSM_REF1;
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 3   

 115   1      
 116   1          ADC_DSM_OUT0_REG    = ADC_CFG1_DSM_OUT0;
 117   1          ADC_DSM_OUT1_REG    = ADC_CFG1_DSM_OUT1;
 118   1      
 119   1          ADC_DSM_CR0_REG     = ADC_CFG1_DSM_CR0;
 120   1          ADC_DSM_CR1_REG     = ADC_CFG1_DSM_CR1;
 121   1      #if(ADC_MI_ENABLE != 0u) /* Enable Modulator Input */
                  ADC_DSM_CR3_REG     |= ADC_DSM_MODBIT_EN;
              #else
 124   1          ADC_DSM_CR3_REG     = ADC_CFG1_DSM_CR3;
 125   1      #endif /* ADC_MI_ENABLE != 0u*/    
 126   1          ADC_DSM_CR8_REG     = ADC_CFG1_DSM_CR8;
 127   1          ADC_DSM_CR9_REG     = ADC_CFG1_DSM_CR9;
 128   1          ADC_DSM_CR13_REG    = ADC_CFG1_DSM_CR13;
 129   1      
 130   1          ADC_DEC_SR_REG      = ADC_CFG1_DEC_SR;
 131   1      
 132   1          /* Calculate Gain compensation coefficients for all configurations */
 133   1          ADC_GainCompensation(ADC_CFG1_INPUT_RANGE,
 134   1                                            ADC_CFG1_IDEAL_DEC_GAIN,
 135   1                                            ADC_CFG1_IDEAL_ODDDEC_GAIN,
 136   1                                            ADC_CFG1_RESOLUTION,
 137   1                                            ADC_CFG1);
 138   1          #if(ADC_DEFAULT_NUM_CONFIGS > 1)
                      ADC_GainCompensation(ADC_CFG2_INPUT_RANGE,
                                                        ADC_CFG2_IDEAL_DEC_GAIN,
                                                        ADC_CFG2_IDEAL_ODDDEC_GAIN,
                                                        ADC_CFG2_RESOLUTION,
                                                        ADC_CFG2);
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 1 */
 145   1          #if(ADC_DEFAULT_NUM_CONFIGS > 2)
                      ADC_GainCompensation(ADC_CFG3_INPUT_RANGE,
                                                        ADC_CFG3_IDEAL_DEC_GAIN,
                                                        ADC_CFG3_IDEAL_ODDDEC_GAIN,
                                                        ADC_CFG3_RESOLUTION,
                                                        ADC_CFG3);
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 2 */
 152   1          #if(ADC_DEFAULT_NUM_CONFIGS > 3)
                      ADC_GainCompensation(ADC_CFG4_INPUT_RANGE,
                                                        ADC_CFG4_IDEAL_DEC_GAIN,
                                                        ADC_CFG4_IDEAL_ODDDEC_GAIN,
                                                        ADC_CFG4_RESOLUTION,
                                                        ADC_CFG4);
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 3 */
 159   1      
 160   1          /* Set GCOR register for config1 */
 161   1          ADC_DEC_GVAL_REG = ADC_gcor[ADC_Config - 1u].gval;
 162   1          CY_SET_REG16(ADC_DEC_GCOR_16B_PTR, ADC_gcor[ADC_Config - 1u].gcor);
 163   1      
 164   1          /* Initialize the registers with default customizer settings for config1 */
 165   1          ADC_InitConfig(ADC_Config);
 166   1      }
 167          
 168          
 169          /******************************************************************************
 170          * Function Name: ADC_Enable
 171          *******************************************************************************
 172          *
 173          * Summary:
 174          *  Enables the ADC DelSig block operation.
 175          *
 176          *
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 4   

 177          * Parameters:
 178          *  None
 179          *
 180          * Return:
 181          *  None
 182          *
 183          *******************************************************************************/
 184          void ADC_Enable(void) 
 185          {
 186   1              uint8 config;
 187   1          uint8 enableInterrupts;
 188   1          enableInterrupts = CyEnterCriticalSection();
 189   1      
 190   1          /* Read volatile variable to the local variable */
 191   1          config = ADC_Config;
 192   1          
 193   1          /* Enable active mode power for ADC */
 194   1          ADC_PWRMGR_DEC_REG |= ADC_ACT_PWR_DEC_EN;
 195   1          ADC_PWRMGR_DSM_REG |= ADC_ACT_PWR_DSM_EN;
 196   1      
 197   1           /* Enable alternative active mode power for ADC */
 198   1          ADC_STBY_PWRMGR_DEC_REG |= ADC_STBY_PWR_DEC_EN;
 199   1          ADC_STBY_PWRMGR_DSM_REG |= ADC_STBY_PWR_DSM_EN;
 200   1      
 201   1          /* Disable PRES, Enable power to VCMBUF0, REFBUF0 and REFBUF1, enable PRES */
 202   1          ADC_RESET_CR4_REG |= ADC_IGNORE_PRESA1;
 203   1          ADC_RESET_CR5_REG |= ADC_IGNORE_PRESA2;
 204   1      
 205   1          ADC_DSM_CR17_REG |= (ADC_DSM_EN_BUF_VREF | ADC_DSM_EN_BUF_VCM);
 206   1      
 207   1          /* Code to disable the REFBUF0 if reference chosen is External ref */
 208   1          #if (((ADC_CFG1_REFERENCE == ADC_EXT_REF_ON_P03) || \
 209   1                (ADC_CFG1_REFERENCE == ADC_EXT_REF_ON_P32)) || \
 210   1               ((ADC_DEFAULT_NUM_CONFIGS > 1) && \
 211   1                ((ADC_CFG2_REFERENCE == ADC_EXT_REF_ON_P03) ||  \
 212   1                 (ADC_CFG2_REFERENCE == ADC_EXT_REF_ON_P32))) || \
 213   1               ((ADC_DEFAULT_NUM_CONFIGS > 2) && \
 214   1                ((ADC_CFG3_REFERENCE == ADC_EXT_REF_ON_P03) ||  \
 215   1                 (ADC_CFG3_REFERENCE == ADC_EXT_REF_ON_P32))) || \
 216   1               ((ADC_DEFAULT_NUM_CONFIGS > 3) && \
 217   1                ((ADC_CFG4_REFERENCE == ADC_EXT_REF_ON_P03) || \
 218   1                 (ADC_CFG4_REFERENCE == ADC_EXT_REF_ON_P32))))
                      if (((config == 1u) &&
                          ((ADC_CFG1_REFERENCE == ADC_EXT_REF_ON_P03) ||
                           (ADC_CFG1_REFERENCE == ADC_EXT_REF_ON_P32))) ||
                          ((config == 2u) &&
                          ((ADC_CFG2_REFERENCE == ADC_EXT_REF_ON_P03) ||
                           (ADC_CFG2_REFERENCE == ADC_EXT_REF_ON_P32))) ||
                          ((config == 3u) &&
                          ((ADC_CFG3_REFERENCE == ADC_EXT_REF_ON_P03) ||
                           (ADC_CFG3_REFERENCE == ADC_EXT_REF_ON_P32))) ||
                          ((config == 4u) &&
                          ((ADC_CFG4_REFERENCE == ADC_EXT_REF_ON_P03) ||
                           (ADC_CFG4_REFERENCE == ADC_EXT_REF_ON_P32))))
                      {
                          /* Disable the REFBUF0 */
                          ADC_DSM_CR17_REG &= (uint8)~ADC_DSM_EN_BUF_VREF;
                      }
                  #endif /* External ref */
 236   1      
 237   1          #if (((ADC_CFG1_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) || \
 238   1               ((ADC_DEFAULT_NUM_CONFIGS > 1) && \
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 5   

 239   1                (ADC_CFG2_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)) || \
 240   1               ((ADC_DEFAULT_NUM_CONFIGS > 2) && \
 241   1                (ADC_CFG3_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)) || \
 242   1               ((ADC_DEFAULT_NUM_CONFIGS > 3) && \
 243   1                (ADC_CFG4_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF))))
                      if(((config == 1u) &&
                          (ADC_CFG1_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) &&
                          ((ADC_CFG1_REFERENCE != ADC_EXT_REF_ON_P03) &&
                           (ADC_CFG1_REFERENCE != ADC_EXT_REF_ON_P32))) ||
                           ((config == 2u) &&
                            (ADC_CFG2_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) &&
                           ((ADC_CFG2_REFERENCE != ADC_EXT_REF_ON_P03) &&
                           (ADC_CFG2_REFERENCE != ADC_EXT_REF_ON_P32))) ||
                           ((config == 3u) &&
                            (ADC_CFG3_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) &&
                           ((ADC_CFG3_REFERENCE != ADC_EXT_REF_ON_P03) &&
                           (ADC_CFG3_REFERENCE != ADC_EXT_REF_ON_P32))) ||
                           ((config == 4u) &&
                            (ADC_CFG4_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF) &&
                           ((ADC_CFG4_REFERENCE != ADC_EXT_REF_ON_P03) &&
                           (ADC_CFG4_REFERENCE != ADC_EXT_REF_ON_P32))))
                      {
                          /* Enable the REFBUF1 */
                          ADC_DSM_REF0_REG |= ADC_DSM_EN_BUF_VREF_INN;
                      }
                  #endif /* VSSA_TO_2VREF */
 265   1          if(config != 0u)
 266   1          {
 267   2              /* Suppress compiler warning */
 268   2          }
 269   1      
 270   1          /* Wait for 3 microseconds */
 271   1          CyDelayUs(ADC_PRES_DELAY_TIME);
 272   1      
 273   1          /* Enable the press circuit */
 274   1          ADC_RESET_CR4_REG &= (uint8)~ADC_IGNORE_PRESA1;
 275   1          ADC_RESET_CR5_REG &= (uint8)~ADC_IGNORE_PRESA2;
 276   1      
 277   1          /* Enable negative pumps for DSM  */
 278   1          ADC_PUMP_CR1_REG  |= ( ADC_PUMP_CR1_CLKSEL | ADC_PUMP_CR1_FORCE );
 279   1      
 280   1          /* Enable Modulator Chopping if required */
 281   1          ADC_DSM_CR2_REG = ADC_CFG1_DSM_CR2;
 282   1      
 283   1          /* This is only valid if there is an internal clock */
 284   1          #if(ADC_DEFAULT_INTERNAL_CLK)
 285   1              ADC_PWRMGR_CLK_REG |= ADC_ACT_PWR_CLK_EN;
 286   1              ADC_STBY_PWRMGR_CLK_REG |= ADC_STBY_PWR_CLK_EN;
 287   1          #endif /* ADC_DEFAULT_INTERNAL_CLK */
 288   1      
 289   1          /* Enable the active and alternate active power for charge pump clock */
 290   1          ADC_PWRMGR_CHARGE_PUMP_CLK_REG |= ADC_ACT_PWR_CHARGE_PUMP_CLK_EN;
 291   1          ADC_STBY_PWRMGR_CHARGE_PUMP_CLK_REG |= ADC_STBY_PWR_CHARGE_PUMP_CLK_EN;
 292   1      
 293   1          #if(ADC_IRQ_REMOVE == 0u)
 294   1              /* Clear a pending interrupt */
 295   1              CyIntClearPending(ADC_INTC_NUMBER);
 296   1              /* Enable interrupt */
 297   1              CyIntEnable(ADC_INTC_NUMBER);
 298   1          #endif   /* End ADC_IRQ_REMOVE */
 299   1      
 300   1          CyExitCriticalSection(enableInterrupts);
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 6   

 301   1      
 302   1      }
 303          
 304          
 305          /*******************************************************************************
 306          * Function Name: ADC_Start
 307          ********************************************************************************
 308          *
 309          * Summary:
 310          *  Performs all required initialization for this component and enables
 311          *  the power. It configure all the register the first time it is called.
 312          *  Subsequent calls of the Start function only enable the ADC and turn
 313          *  on the power. If multiple configurations are selected, it will
 314          *  configure the ADC for configuration 1 by default, unless the
 315          *  ADC_SelectConfiguration( ) function has been called to change
 316          *  the default setting.
 317          *
 318          * Parameters:
 319          *  None
 320          *
 321          * Return:
 322          *  None
 323          *
 324          * Global variables:
 325          *  ADC_initVar:  Used to check the initial configuration,
 326          *  modified when this function is called for the first time.
 327          *
 328          *******************************************************************************/
 329          void ADC_Start(void) 
 330          {
 331   1          if(ADC_initVar == 0u)
 332   1          {
 333   2              if(ADC_started == 0u)
 334   2              {
 335   3                  ADC_Init();
 336   3              }
 337   2              ADC_initVar = 1u;
 338   2          }
 339   1      
 340   1          /* Enable the ADC */
 341   1          ADC_Enable();
 342   1      }
 343          
 344          
 345          /*******************************************************************************
 346          * Function Name: ADC_Stop
 347          ********************************************************************************
 348          *
 349          * Summary:
 350          *  This function stops and powers down the ADC component and the internal
 351          *  clock if the external clock is not selected. If an external clock is
 352          *  used, it is up to the designer to power down the external clock it
 353          *  required.
 354          *
 355          * Parameters:
 356          *  None
 357          *
 358          * Return:
 359          *  None
 360          *
 361          *******************************************************************************/
 362          void ADC_Stop(void) 
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 7   

 363          {
 364   1          uint8 enableInterrupts;
 365   1          enableInterrupts = CyEnterCriticalSection();
 366   1      
 367   1          /* Stop conversions */
 368   1          ADC_DEC_CR_REG &= (uint8)~ADC_DEC_START_CONV;
 369   1          ADC_DEC_SR_REG |=  ADC_DEC_INTR_CLEAR;
 370   1      
 371   1          /* Disable PRES, Disable power to VCMBUF0, REFBUF0 and REFBUF1,
 372   1             enable PRES */
 373   1          ADC_RESET_CR4_REG |= ADC_IGNORE_PRESA1;
 374   1          ADC_RESET_CR5_REG |= ADC_IGNORE_PRESA2;
 375   1      
 376   1          ADC_DSM_CR17_REG &= (uint8)~(ADC_DSM_EN_BUF_VREF | ADC_DSM_EN_BUF_VCM);
 377   1          ADC_DSM_REF0_REG &= (uint8)~ADC_DSM_EN_BUF_VREF_INN;
 378   1      
 379   1          /* Wait for 3 microseconds. */
 380   1          CyDelayUs(ADC_PRES_DELAY_TIME);
 381   1      
 382   1          /* Enable the press circuit */
 383   1          ADC_RESET_CR4_REG &= (uint8)~ADC_IGNORE_PRESA1;
 384   1          ADC_RESET_CR5_REG &= (uint8)~ADC_IGNORE_PRESA2;
 385   1      
 386   1          /* Disable power to the ADC */
 387   1          ADC_PWRMGR_DSM_REG &= (uint8)~ADC_ACT_PWR_DSM_EN;
 388   1      
 389   1          /* Disable power to Decimator block */
 390   1          ADC_PWRMGR_DEC_REG &= (uint8)~ADC_ACT_PWR_DEC_EN;
 391   1      
 392   1          /* Disable alternative active power to the ADC */
 393   1          ADC_STBY_PWRMGR_DEC_REG &= (uint8)~ADC_STBY_PWR_DEC_EN;
 394   1          ADC_STBY_PWRMGR_DSM_REG &= (uint8)~ADC_STBY_PWR_DSM_EN;
 395   1      
 396   1         /* Disable negative pumps for DSM  */
 397   1          ADC_PUMP_CR1_REG &= (uint8)~(ADC_PUMP_CR1_CLKSEL | ADC_PUMP_CR1_FORCE );
 398   1      
 399   1          /* This is only valid if there is an internal clock */
 400   1          #if(ADC_DEFAULT_INTERNAL_CLK)
 401   1              ADC_PWRMGR_CLK_REG &= (uint8)~ADC_ACT_PWR_CLK_EN;
 402   1              ADC_STBY_PWRMGR_CLK_REG &= (uint8)~ADC_STBY_PWR_CLK_EN;
 403   1          #endif /* ADC_DEFAULT_INTERNAL_CLK */
 404   1      
 405   1          /* Disable Modulator Chopping */
 406   1          ADC_DSM_CR2_REG &= (uint8)~ADC_DSM_MOD_CHOP_EN;
 407   1          /* Disable power to charge pump clock */
 408   1          ADC_PWRMGR_CHARGE_PUMP_CLK_REG &= (uint8)~ADC_ACT_PWR_CHARGE_PUMP_CLK_EN;
 409   1          ADC_STBY_PWRMGR_CHARGE_PUMP_CLK_REG &= (uint8)~ADC_STBY_PWR_CHARGE_PUMP_CLK_EN;
 410   1          
 411   1          CyExitCriticalSection(enableInterrupts);
 412   1      }
 413          
 414          
 415          /*******************************************************************************
 416          * Function Name: ADC_SetBufferGain
 417          ********************************************************************************
 418          *
 419          * Summary:
 420          *  Sets input buffer gain.
 421          *
 422          * Parameters:
 423          *  gain:  Two bit value to select a gain of 1, 2, 4, or 8.
 424          *
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 8   

 425          * Return:
 426          *  None
 427          *
 428          *******************************************************************************/
 429          void ADC_SetBufferGain(uint8 gain) 
 430          {
 431   1          uint8 tmpReg;
 432   1          tmpReg = ADC_DSM_BUF1_REG & (uint8)~ADC_DSM_GAIN_MASK;
 433   1          tmpReg |= (uint8)(gain << ADC_DSM_GAIN_SHIFT) & ADC_DSM_GAIN_MASK;
 434   1          ADC_DSM_BUF1_REG = tmpReg;
 435   1      }
 436          
 437          
 438          /*******************************************************************************
 439          * Function Name: ADC_SetCoherency
 440          ********************************************************************************
 441          *
 442          * Summary:
 443          *  This function allows the user to change which of the ADC's 3 word
 444          *  result will trigger a coherency unlock. The ADC's result will not be
 445          *  updated until the set byte is read either by the ADC or DMA. 
 446          *  By default the LSB is the coherency byte for right alignment data format. 
 447          *  The middle or high byte is set automatically depend on left alignment 
 448          *  configuration for DMA data transfer.
 449          *  If DMA or if a custom API requires different byte to be read the last,
 450          *  this API should be used to set the last byte of the ADC result that is read. 
 451          *  If a multibyte read is performed either by DMA or the ARM processor, the
 452          *  coherency can be set to any byte in the last word read.
 453          *
 454          * Parameters:
 455          *  coherency:  Two bit value to set the coherency bit.
 456          *           00-Coherency checking off
 457          *           01-low byte is key byte
 458          *           02-middle byte is the key byte
 459          *           03-high byte is the key byte
 460          *
 461          * Return:
 462          *  None
 463          *
 464          *******************************************************************************/
 465          void ADC_SetCoherency(uint8 coherency) 
 466          {
 467   1          uint8 tmpReg;
 468   1      
 469   1          tmpReg = ADC_DEC_COHER_REG & (uint8)~ADC_DEC_SAMP_KEY_MASK;
 470   1          tmpReg |= coherency & ADC_DEC_SAMP_KEY_MASK;
 471   1          ADC_DEC_COHER_REG = tmpReg;
 472   1      }
 473          
 474          
 475          /*******************************************************************************
 476          * Function Name: ADC_SetGCOR
 477          ********************************************************************************
 478          *
 479          * Summary:
 480          *  Calculates a new GCOR value and writes it into the GCOR register. 
 481          *  The GCOR value is a 16-bit value that represents a gain of 0 to 2. 
 482          *  The ADC result is multiplied by this value before it is placed in the ADC 
 483          *  output registers. The numerical format for the GCOR value is:
 484          *  0x0000 -> 0.000
 485          *  0x8000 -> 1.000
 486          *  0xFFFF -> 1.99997
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 9   

 487          *  When executing the function, the old GCOR value is multiplied by
 488          *  gainAdjust and reloaded into the GCOR register.
 489          *
 490          * Parameters:
 491          *  gainAdjust:  floating point value to set GCOR registers.
 492          *
 493          * Return:
 494          *  uint8: 0 - if GCOR value is within the expected range.
 495          *         1 - the correction value is outside GCOR value range of
 496          *             0.00 to 1.9999.
 497          *
 498          * Side Effects:  The GVAL register is set to the amount of valid bits in the
 499          *                GCOR  register minus one. If GVAL is 15 (0x0F), all 16 bits
 500          *                of the GCOR registers will be valid. If for example GVAL is
 501          *                11 (0x0B) only 12 bits will be valid. The least 4 bits will
 502          *                be lost when the GCOR value is shifted 4 places to the right.
 503          *
 504          ******************************************************************************/
 505          uint8 ADC_SetGCOR(float32 gainAdjust) 
 506          {
 507   1          uint16 tmpReg;
 508   1          uint8 status;
 509   1          float32 tmpValue;
 510   1      
 511   1          tmpReg = ADC_gcor[ADC_Config - 1u].gcor;
 512   1          tmpValue = ((float32)tmpReg / (float32)ADC_IDEAL_GAIN_CONST);
 513   1          tmpValue = tmpValue * gainAdjust;
 514   1      
 515   1          if (tmpValue > 1.9999)
 516   1          {
 517   2              status = 1u;
 518   2          }
 519   1          else
 520   1          {
 521   2              tmpValue *= (float32)ADC_IDEAL_GAIN_CONST;
 522   2                      tmpReg = (uint16)tmpValue;
 523   2              CY_SET_REG16(ADC_DEC_GCOR_16B_PTR, tmpReg);
 524   2              /* Update gain array to be used by SelectConfiguration() API */
 525   2             ADC_gcor[ADC_Config - 1u].gcor = tmpReg;
 526   2      
 527   2              status = 0u;
 528   2      
 529   2          }
 530   1          return(status);
 531   1      }
 532          
 533          
 534          /******************************************************************************
 535          * Function Name: ADC_ReadGCOR
 536          *******************************************************************************
 537          *
 538          * Summary:
 539          *  This API returns the current GCOR register value, normalized based on the
 540          *  GVAL register settings.
 541          *  For example, if the GCOR value is 0x0812 and the GVAL register is set to 
 542          *  11 (0x0B) then the returned value will be shifted by for bits to the left.
 543          *  (Actual GCOR value = 0x0812, returned value = 0x8120)
 544          *
 545          * Parameters:
 546          *  None
 547          *
 548          * Return:
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 10  

 549          *  uint16:  Normalized GCOR value.
 550          *
 551          *******************************************************************************/
 552          uint16 ADC_ReadGCOR(void) 
 553          {
 554   1          uint8 gValue;
 555   1          uint16 gcorValue;
 556   1      
 557   1          gValue = ADC_DEC_GVAL_REG;
 558   1          gcorValue = CY_GET_REG16(ADC_DEC_GCOR_16B_PTR);
 559   1      
 560   1          if (gValue < ADC_MAX_GVAL)
 561   1          {
 562   2              gcorValue <<= ADC_MAX_GVAL - gValue;
 563   2          }
 564   1      
 565   1          return gcorValue;
 566   1      }
 567          
 568          
 569          /*******************************************************************************
 570          * Function Name: ADC_StartConvert
 571          ********************************************************************************
 572          *
 573          * Summary:
 574          *  Forces the ADC to initiate a conversion. If in the "Single Sample"
 575          *  mode, one conversion will be performed then the ADC will halt. If in
 576          *  one of the other three conversion modes, the ADC will run
 577          *  continuously until the ADC_Stop() or ADC_StopConvert() is called.
 578          *
 579          * Parameters:
 580          *  None
 581          *
 582          * Return:
 583          *  None
 584          *
 585          *******************************************************************************/
 586          void ADC_StartConvert(void) 
 587          {
 588   1          /* Start the conversion */
 589   1          ADC_DEC_CR_REG |= ADC_DEC_START_CONV;
 590   1      }
 591          
 592          
 593          /*******************************************************************************
 594          * Function Name: ADC_StopConvert
 595          ********************************************************************************
 596          *
 597          * Summary:
 598          *  Forces the ADC to stop all conversions. If the ADC is in the middle of a
 599          *  conversion, the ADC will be reset and not provide a result for that partial
 600          *  conversion.
 601          *
 602          * Parameters:
 603          *  None
 604          *
 605          * Return:
 606          *  None
 607          *
 608          *******************************************************************************/
 609          void ADC_StopConvert(void) 
 610          {
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 11  

 611   1          /* Stop all conversions */
 612   1          ADC_DEC_CR_REG &= (uint8)~ADC_DEC_START_CONV;
 613   1      }
 614          
 615          
 616          /*******************************************************************************
 617          * Function Name: ADC_IsEndConversion
 618          ********************************************************************************
 619          *
 620          * Summary:
 621          *  Checks the status that the most recently started conversion has completed.
 622          *  The status is cleared by any of ADC_GetResult8(), ADC_GetResult16() or 
 623          *  ADC_GetResult32() API.
 624          *  This function provides the programmer with two options. In one mode this 
 625          *  function immediately returns with the conversion status. In the other mode,
 626          *  the function does not return (blocking) until the conversion has completed.
 627          *
 628          * Parameters:
 629          *  retMode: Check conversion return mode. See the following table for options.
 630          *   ADC_RETURN_STATUS -   Immediately returns conversion result
 631          *                                      status.
 632          *   ADC_WAIT_FOR_RESULT - Does not return until ADC conversion
 633          *                                      is complete.
 634          *
 635          * Return:
 636          *  If a nonzero value is returned, the last conversion has completed.
 637          *  If the returned value is zero, the ADC is still calculating the last result.
 638          *
 639          * Global variables:
 640          *  ADC_convDone:  Used to check whether conversion is complete
 641          *  or not for single sample mode with resolution is above 16
 642          *
 643          *******************************************************************************/
 644          uint8 ADC_IsEndConversion(uint8 retMode) 
 645          {
 646   1          uint8 status;
 647   1      
 648   1          do
 649   1          {
 650   2              /* Check for stop convert if conversion mode is Single Sample with
 651   2              *   resolution above 16 bit
 652   2              */
 653   2              if(ADC_stopConversion != 0u)
 654   2              {
 655   3                  status = ADC_convDone;
 656   3              }
 657   2              else
 658   2              {
 659   3                  status = ADC_DEC_SR_REG & ADC_DEC_CONV_DONE;
 660   3              }
 661   2          }while((status != ADC_DEC_CONV_DONE) && (retMode == ADC_WAIT_FOR_RESULT));
 662   1      
 663   1          return(status);
 664   1      }
 665          
 666          
 667          /*******************************************************************************
 668          * Function Name: ADC_GetResult8
 669          ********************************************************************************
 670          *
 671          * Summary:
 672          *  This function returns the result of an 8-bit conversion. If the
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 12  

 673          *  resolution is set greater than 8-bits, the LSB of the result will be
 674          *  returned. When the ADC is configured for 8-bit single ended mode,
 675          *  the ADC_GetResult16() function should be used instead. This
 676          *  function returns only signed 8-bit values. The maximum positive
 677          *  signed 8-bit value is 127, but in singled ended 8-bit mode, the
 678          *  maximum positive value is 255.
 679          *
 680          * Parameters:
 681          *  None
 682          *
 683          * Return:
 684          *  int8: The LSB of the last ADC conversion.
 685          *
 686          * Global variables:
 687          *  ADC_convDone:  Cleared in single sample mode with resolution
 688          *                              above 16 bits
 689          *
 690          *******************************************************************************/
 691          int8 ADC_GetResult8( void ) 
 692          {
 693   1          int8 result;
 694   1          uint8 coherency;
 695   1      
 696   1          /* Read active coherency configuration */
 697   1          coherency = ADC_DEC_COHER_REG & ADC_DEC_SAMP_KEY_MASK;
 698   1      
 699   1          result = (int8)ADC_DEC_SAMP_REG;
 700   1      
 701   1          if(coherency == ADC_DEC_SAMP_KEY_MID)
 702   1          {   /* Dummy read of the middle byte to unlock the coherency */
 703   2              (void)ADC_DEC_SAMPM_REG;
 704   2          }
 705   1          else  if(coherency == ADC_DEC_SAMP_KEY_HIGH)
 706   1          {   /* Dummy read of the MSB byte to unlock the coherency */
 707   2              (void)ADC_DEC_SAMPH_REG;
 708   2          }
 709   1          else /*No action required for other coherency */
 710   1          {
 711   2          }
 712   1          /* Clear conversion complete status in Single Sample mode with resolution above 16 bit */
 713   1          if(ADC_stopConversion != 0u)
 714   1          {
 715   2              ADC_convDone = 0u;
 716   2          }
 717   1          return (result);
 718   1      }
 719          
 720          
 721          /*******************************************************************************
 722          * Function Name: ADC_GetResult16
 723          ********************************************************************************
 724          *
 725          * Summary:
 726          *  Returns a 16-bit result for a conversion with a result that has a
 727          *  resolution of 8 to 16 bits. If the resolution is set greater than 16-bits,
 728          *  it will return the 16 least significant bits of the result. When the ADC
 729          *  is configured for 16-bit single ended mode, the ADC_GetResult32()
 730          *  function should be used instead. This function returns only signed
 731          *  16-bit result, which allows a maximum positive value of 32767, not 65535.
 732          *  This function supports different coherency settings.
 733          *
 734          * Parameters:
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 13  

 735          *   void
 736          *
 737          * Return:
 738          *  int16:  ADC result.
 739          *
 740          * Global variables:
 741          *  ADC_convDone:  Cleared in single sample mode with resolution
 742          *                              above 16 bits
 743          *
 744          *******************************************************************************/
 745          int16 ADC_GetResult16(void) 
 746          {
 747   1          uint16 result;
 748   1          uint8 coherency;
 749   1      
 750   1          /* Read active coherency configuration */
 751   1          coherency = ADC_DEC_COHER_REG & ADC_DEC_SAMP_KEY_MASK;
 752   1      
 753   1          if(coherency <= ADC_DEC_SAMP_KEY_LOW)
 754   1          {   /*  Use default method to read result registers i.e. LSB byte read at the end*/
 755   2              #if (CY_PSOC3)
 756   2                  result = ADC_DEC_SAMPM_REG;
 757   2                  result = (result << 8u) | ADC_DEC_SAMP_REG;
 758   2              #else
                          result = (CY_GET_REG16(ADC_DEC_SAMP_16B_PTR));
                      #endif /* CY_PSOC3 */
 761   2          }
 762   1          else /* MID or HIGH */
 763   1          {   /* Read middle byte at the end */
 764   2              #if (CY_PSOC3)
 765   2                  result = (CY_GET_REG16(ADC_DEC_SAMP_16B_PTR));
 766   2              #else
                          result = ADC_DEC_SAMP_REG;
                          result |=  (uint16)((uint16)ADC_DEC_SAMPM_REG << 8u);
                      #endif /* CY_PSOC3 */
 770   2              if(coherency == ADC_DEC_SAMP_KEY_HIGH)
 771   2              {   /* Dummy read of the MSB byte to unlock the coherency */
 772   3                  (void)ADC_DEC_SAMPH_REG;
 773   3              }
 774   2          }
 775   1          /* Clear conversion complete status in Single Sample mode with resolution above 16 bit */
 776   1          if(ADC_stopConversion != 0u)
 777   1          {
 778   2              ADC_convDone = 0u;
 779   2          }
 780   1      
 781   1          return ((int16)result);
 782   1      }
 783          
 784          
 785          /*******************************************************************************
 786          * Function Name: ADC_GetResult32
 787          ********************************************************************************
 788          *
 789          * Summary:
 790          *  Returns a 32-bit result for a conversion with a result that has a
 791          *  resolution of 8 to 20 bits.
 792          *  This function supports different coherency settings.
 793          *
 794          * Parameters:
 795          *  None
 796          *
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 14  

 797          * Return:
 798          *  int32: Result of the last ADC conversion.
 799          *
 800          * Global variables:
 801          *  ADC_convDone:  Cleared in single sample mode with resolution
 802          *                              above 16 bits
 803          *
 804          *******************************************************************************/
 805          int32 ADC_GetResult32(void) 
 806          {
 807   1          uint32 result;
 808   1          uint8 coherency;
 809   1          #if (CY_PSOC3)
 810   1                  uint16 tmp;
 811   1          #endif /* CY_PSOC3 */
 812   1      
 813   1          /* Read active coherency configuration */
 814   1          coherency = ADC_DEC_COHER_REG & ADC_DEC_SAMP_KEY_MASK;
 815   1      
 816   1          if(coherency <= ADC_DEC_SAMP_KEY_LOW)
 817   1          {   /*  Use default method to read result registers i.e. LSB byte read at the end*/
 818   2              #if (CY_PSOC3)
 819   2                  result = ADC_DEC_SAMPH_REG;
 820   2                  if((result & 0x80u) != 0u)
 821   2                  {   /* Sign extend */
 822   3                      result |= 0xFF00u;
 823   3                  }
 824   2                  result = (result << 8u) | ADC_DEC_SAMPM_REG;
 825   2                  result = (result << 8u) | ADC_DEC_SAMP_REG;
 826   2              #else
                          result = CY_GET_REG16(ADC_DEC_SAMPH_16B_PTR);
                          result = (result << 16u) | (CY_GET_REG16(ADC_DEC_SAMP_16B_PTR));
                      #endif /* CY_PSOC3 */
 830   2          }
 831   1          else if(coherency == ADC_DEC_SAMP_KEY_MID)
 832   1          {   /* Read middle byte at the end */
 833   2              #if (CY_PSOC3)
 834   2                  result = ADC_DEC_SAMPH_REG;
 835   2                  if((result & 0x80u) != 0u)
 836   2                  {   /* Sign extend */
 837   3                      result |= 0xFF00u;
 838   3                  }
 839   2                  result = (result << 16u) | (CY_GET_REG16(ADC_DEC_SAMP_16B_PTR));
 840   2              #else
                          result = CY_GET_REG16(ADC_DEC_SAMPH_16B_PTR);
                          result = (result << 16u) | ADC_DEC_SAMP_REG;
                          result |=  (uint32)((uint32)ADC_DEC_SAMPM_REG << 8u);
                      #endif /* CY_PSOC3 */
 845   2          }
 846   1          else /*ADC_DEC_SAMP_KEY_HIGH */
 847   1          {
 848   2              /* Read MSB byte at the end */
 849   2              #if (CY_PSOC3)
 850   2                  result = CY_GET_REG16(ADC_DEC_SAMP_16B_PTR);
 851   2                              tmp = ADC_DEC_SAMPH_REG;
 852   2                  if((tmp & 0x80u) != 0u)
 853   2                  {   /* Sign extend */
 854   3                      tmp |= 0xFF00u;
 855   3                  }
 856   2                  result |= (uint32)tmp << 16u;
 857   2              #else
                          result = CY_GET_REG16(ADC_DEC_SAMP_16B_PTR);
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 15  

                          result |= (uint32)((uint32)CY_GET_REG16(ADC_DEC_SAMPH_16B_PTR) << 16u);
                      #endif /* CY_PSOC3 */
 861   2          }
 862   1          /* Clear conversion complete status in Single Sample mode with resolution above 16 bit */
 863   1          if(ADC_stopConversion != 0u)
 864   1          {
 865   2              ADC_convDone = 0u;
 866   2          }
 867   1      
 868   1          return ((int32)result);
 869   1      }
 870          
 871          
 872          /*******************************************************************************
 873          * Function Name: ADC_SetOffset
 874          ********************************************************************************
 875          *
 876          * Summary:
 877          *  Sets the ADC offset which is used by the functions ADC_CountsTo_uVolts, 
 878          *  ADC_CountsTo_mVolts, and ADC_CountsTo_Volts to subtract the offset from the 
 879          *  given reading before calculating the voltage conversion.
 880          *
 881          * Parameters:
 882          *  int32:  This value is a measured value when the inputs are shorted or 
 883          *          connected to the same input voltage.
 884          *
 885          * Return:
 886          *  None
 887          *
 888          * Global variables:
 889          *  ADC_Offset:  Modified to set the user provided offset. This
 890          *  variable is used for offset calibration purpose.
 891          *
 892          * Side Effects:
 893          *  Affects the ADC_CountsTo_Volts,
 894          *  ADC_CountsTo_mVolts, ADC_CountsTo_uVolts functions
 895          *  by subtracting the given offset.
 896          *
 897          *******************************************************************************/
 898          void ADC_SetOffset(int32 offset) 
 899          {
 900   1      
 901   1          ADC_Offset = offset;
 902   1      }
 903          
 904          
 905          /*******************************************************************************
 906          * Function Name: ADC_SetGain
 907          ********************************************************************************
 908          *
 909          * Summary:
 910          *  Sets the ADC gain in counts per volt for the voltage conversion
 911          *  functions below. This value is set by default by the reference and
 912          *  input range settings. It should only be used to further calibrate the
 913          *  ADC with a known input or if an external reference is used. This
 914          *  function may also be used to calibrate an entire signal chain, not
 915          *  just the ADC.
 916          *
 917          * Parameters:
 918          *  int32: ADC gain in counts per volt.
 919          *
 920          * Return:
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 16  

 921          *  None
 922          *
 923          * Global variables:
 924          *  ADC_CountsPerVolt:  modified to set the ADC gain in counts
 925          *   per volt.
 926          *
 927          * Side Effects:
 928          *  Affects the ADC_CountsTo_Volts,
 929          *  ADC_CountsTo_mVolts, ADC_CountsTo_uVolts functions
 930          *  supplying the correct conversion between ADC counts and voltage.
 931          *
 932          *******************************************************************************/
 933          void ADC_SetGain(int32 adcGain) 
 934          {
 935   1          ADC_CountsPerVolt = adcGain;
 936   1      }
 937          
 938          
 939          /*******************************************************************************
 940          * Function Name: ADC_CountsTo_mVolts
 941          ********************************************************************************
 942          *
 943          * Summary:
 944          *  Converts the ADC counts output to mVolts as a 16-bit integer. For
 945          *  example, if the ADC measured 0.534 volts, the return value would
 946          *  be 534 mVolts.
 947          *
 948          * Parameters:
 949          *  int32: adcCounts Result from the ADC conversion.
 950          *
 951          * Return:
 952          *  int16:  Result in mVolts
 953          *
 954          * Global variables:
 955          *  ADC_CountsPerVolt:  used to convert ADC counts to mVolts.
 956          *  ADC_Offset:  Used as the offset while converting ADC counts
 957          *   to mVolts.
 958          *
 959          *******************************************************************************/
 960          int16 ADC_CountsTo_mVolts(int32 adcCounts) 
 961          {
 962   1      
 963   1          int16 mVolts;
 964   1      
 965   1          /* Convert adcCounts to the right align if left option selected */
 966   1          #if(ADC_CFG1_DEC_DIV != 0)
                      if(ADC_Config == ADC_CFG1)
                      {
                          adcCounts /= ADC_CFG1_DEC_DIV;
                      }
                  #endif /* ADC_CFG1_DEC_DIV */
 972   1          #if((ADC_CFG2_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 1))
                      if(ADC_Config == ADC_CFG2)
                      {
                          adcCounts /= ADC_CFG2_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
 978   1          #if((ADC_CFG3_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 2))
                      if(ADC_Config == ADC_CFG3)
                      {
                          adcCounts /= ADC_CFG3_DEC_DIV;
                      }
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 17  

                  #endif /* ADC_CFG2_DEC_DIV */
 984   1          #if((ADC_CFG4_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 3))
                      if(ADC_Config == ADC_CFG4)
                      {
                          adcCounts /= ADC_CFG4_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
 990   1      
 991   1          /* Subtract ADC offset */
 992   1          adcCounts -= ADC_Offset;
 993   1      
 994   1          mVolts = (int16)(( adcCounts * ADC_1MV_COUNTS ) / ADC_CountsPerVolt) ;
 995   1      
 996   1          return(mVolts);
 997   1      }
 998          
 999          
1000          /*******************************************************************************
1001          * Function Name: ADC_CountsTo_Volts
1002          ********************************************************************************
1003          *
1004          * Summary:
1005          *  Converts the ADC output to Volts as a floating point number. For
1006          *  example, if the ADC measure a voltage of 1.2345 Volts, the
1007          *  returned result would be +1.2345 Volts.
1008          *
1009          * Parameters:
1010          *  int32 adcCounts:  Result from the ADC conversion.
1011          *
1012          * Return:
1013          *  float32: Result in Volts
1014          *
1015          * Global variables:
1016          *  ADC_CountsPerVolt:  used to convert to Volts.
1017          *  ADC_Offset:  Used as the offset while converting ADC counts
1018          *   to Volts.
1019          *
1020          *******************************************************************************/
1021          float32 ADC_CountsTo_Volts(int32 adcCounts) 
1022          {
1023   1      
1024   1          float32 Volts;
1025   1      
1026   1          /* Convert adcCounts to the right align if left option selected */
1027   1          #if(ADC_CFG1_DEC_DIV != 0)
                      if(ADC_Config == ADC_CFG1)
                      {
                          adcCounts /= ADC_CFG1_DEC_DIV;
                      }
                  #endif /* ADC_CFG1_DEC_DIV */
1033   1          #if((ADC_CFG2_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 1))
                      if(ADC_Config == ADC_CFG2)
                      {
                          adcCounts /= ADC_CFG2_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
1039   1          #if((ADC_CFG3_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 2))
                      if(ADC_Config == ADC_CFG3)
                      {
                          adcCounts /= ADC_CFG3_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 18  

1045   1          #if((ADC_CFG4_DEC_DIV != 0) && (ADC_DEFAULT_NUM_CONFIGS > 3))
                      if(ADC_Config == ADC_CFG4)
                      {
                          adcCounts /= ADC_CFG4_DEC_DIV;
                      }
                  #endif /* ADC_CFG2_DEC_DIV */
1051   1      
1052   1          /* Subtract ADC offset */
1053   1          adcCounts -= ADC_Offset;
1054   1      
1055   1          Volts = (float32)adcCounts / (float32)ADC_CountsPerVolt;
1056   1      
1057   1          return( Volts );
1058   1      }
1059          
1060          
1061          /*******************************************************************************
1062          * Function Name: ADC_CountsTo_uVolts
1063          ********************************************************************************
1064          *
1065          * Summary:
1066          *  Converts the ADC output to uVolts as a 32-bit integer. For example,
1067          *  if the ADC measured -0.02345 Volts, the return value would be -23450 uVolts.
1068          *
1069          * Parameters:
1070          *  int32 adcCounts: Result from the ADC conversion.
1071          *
1072          * Return:
1073          *  int32:  Result in uVolts
1074          *
1075          * Global variables:
1076          *  ADC_CountsPerVolt:  used to convert ADC counts to mVolts.
1077          *  ADC_Offset:  Used as the offset while converting ADC counts
1078          *   to mVolts.
1079          *
1080          * Theory:
1081          *  Care must be taken to not exceed the maximum value for a 31 bit signed
1082          *  number in the conversion to uVolts and at the same time not lose resolution.
1083          *
1084          *  uVolts = ((A * adcCounts) / ((int32)ADC_CountsPerVolt / B));
1085          *
1086          *******************************************************************************/
1087          int32 ADC_CountsTo_uVolts(int32 adcCounts) 
1088          {
1089   1      
1090   1          int32 uVolts;
1091   1          int32 coefA;
1092   1          int32 coefB;
1093   1          uint8 resolution;
1094   1      
1095   1          /* Set the resolution based on the configuration */
1096   1          /* Convert adcCounts to the right align if left option selected */
1097   1          if (ADC_Config == ADC_CFG1)
1098   1          {
1099   2              resolution = ADC_CFG1_RESOLUTION;
1100   2              #if(ADC_CFG1_DEC_DIV != 0)
                          adcCounts /= ADC_CFG1_DEC_DIV;
                      #endif /* ADC_CFG1_DEC_DIV */
1103   2          }
1104   1          else if (ADC_Config == ADC_CFG2)
1105   1          {
1106   2              resolution = ADC_CFG2_RESOLUTION;
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 19  

1107   2              #if(ADC_CFG2_DEC_DIV != 0)
                          adcCounts /= ADC_CFG2_DEC_DIV;
                      #endif /* ADC_CFG2_DEC_DIV */
1110   2          }
1111   1          else if (ADC_Config == ADC_CFG3)
1112   1          {
1113   2              resolution = ADC_CFG3_RESOLUTION;
1114   2              #if(ADC_CFG3_DEC_DIV != 0)
                          adcCounts /= ADC_CFG3_DEC_DIV;
                      #endif /* ADC_CFG3_DEC_DIV */
1117   2          }
1118   1          else
1119   1          {
1120   2              resolution = ADC_CFG4_RESOLUTION;
1121   2              #if(ADC_CFG4_DEC_DIV != 0)
                          adcCounts /= ADC_CFG4_DEC_DIV;
                      #endif /* ADC_CFG4_DEC_DIV */
1124   2          }
1125   1      
1126   1          switch (resolution)
1127   1          {
1128   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_12) || \
1129   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_12) || \
1130   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_12) || \
1131   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_12) )
1132   2                  case (uint8)ADC__BITS_12:
1133   2                      coefA = ADC_1UV_COUNTS / ADC_DIVISOR_2;
1134   2                      coefB = ADC_DIVISOR_2;
1135   2                      break;
1136   2              #endif /* ADC__BITS_12 */    
1137   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_13) || \
1138   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_13) || \
1139   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_13) || \
1140   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_13) )
                          case (uint8)ADC__BITS_13:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_4;
                              coefB = ADC_DIVISOR_4;
                              break;
                      #endif /* ADC__BITS_13 */    
1146   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_14) || \
1147   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_14) || \
1148   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_14) || \
1149   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_14) )
                          case (uint8)ADC__BITS_14:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_8;
                              coefB = ADC_DIVISOR_8;
                              break;
                      #endif /* ADC__BITS_14 */    
1155   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_15) || \
1156   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_15) || \
1157   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_15) || \
1158   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_15) )
                          case (uint8)ADC__BITS_15:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_16;
                              coefB = ADC_DIVISOR_16;
                              break;
                      #endif /* ADC__BITS_15 */    
1164   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_16) || \
1165   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_16) || \
1166   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_16) || \
1167   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_16) )
1168   2                  case (uint8)ADC__BITS_16:
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 20  

1169   2                      coefA = ADC_1UV_COUNTS / ADC_DIVISOR_32;
1170   2                      coefB = ADC_DIVISOR_32;
1171   2                      break;
1172   2              #endif /* ADC__BITS_16 */    
1173   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_17) || \
1174   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_17) || \
1175   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_17) || \
1176   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_17) )
                          case (uint8)ADC__BITS_17:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_64;
                              coefB = ADC_DIVISOR_64;
                              break;
                      #endif /* ADC__BITS_17 */    
1182   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_18) || \
1183   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_18) || \
1184   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_18) || \
1185   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_18) )
                          case (uint8)ADC__BITS_18:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_125;
                              coefB = ADC_DIVISOR_125;
                              break;
                      #endif /* ADC__BITS_18 */    
1191   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_19) || \
1192   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_19) || \
1193   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_19) || \
1194   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_19) )
                          case (uint8)ADC__BITS_19:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_250;
                              coefB = ADC_DIVISOR_250;
                              break;
                      #endif /* ADC__BITS_19 */    
1200   2              #if( (ADC_CFG1_RESOLUTION == ADC__BITS_20) || \
1201   2                   (ADC_CFG2_RESOLUTION == ADC__BITS_20) || \
1202   2                   (ADC_CFG3_RESOLUTION == ADC__BITS_20) || \
1203   2                   (ADC_CFG4_RESOLUTION == ADC__BITS_20) )
                          case (uint8)ADC__BITS_20:
                              coefA = ADC_1UV_COUNTS / ADC_DIVISOR_500;
                              coefB = ADC_DIVISOR_500;
                              break;
                      #endif /* ADC__BITS_20 */    
1209   2              default:    /* resolution < 12 */
1210   2                  /* 11 bits ADC + 2^20(1048576) = 31 bits */
1211   2                  coefA = ADC_1UV_COUNTS;
1212   2                  coefB = ADC_DIVISOR_1;
1213   2                  break;
1214   2          }
1215   1          coefB = ADC_CountsPerVolt / coefB;
1216   1          uVolts = ((coefA * adcCounts) / coefB) - ((coefA * ADC_Offset) / coefB);
1217   1      
1218   1          return( uVolts );
1219   1      }
1220          
1221          
1222          /*******************************************************************************
1223          * Function Name: ADC_InitConfig(uint8 config)
1224          ********************************************************************************
1225          *
1226          * Summary:
1227          *  Initializes all registers based on customizer settings
1228          *
1229          * Parameters:
1230          *   void
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 21  

1231          *
1232          * Return:
1233          *  None
1234          *
1235          * Global variables:
1236          *  ADC_CountsPerVolt:  Used to set the default counts per volt.
1237          *
1238          * Side Effects: Rewrites the coherency set by ADC_SetCoherency()
1239          *   API to the default value.
1240          *
1241          *******************************************************************************/
1242          static void ADC_InitConfig(uint8 config) 
1243          {
1244   1          ADC_stopConversion = 0u;
1245   1      
1246   1          if (config == 1u)
1247   1          {
1248   2              /* Default Config */
1249   2              ADC_DEC_CR_REG      = ADC_CFG1_DEC_CR;
1250   2              ADC_DEC_SHIFT1_REG  = ADC_CFG1_DEC_SHIFT1;
1251   2              ADC_DEC_SHIFT2_REG  = ADC_CFG1_DEC_SHIFT2;
1252   2              ADC_DEC_DR2_REG     = ADC_CFG1_DEC_DR2;
1253   2              ADC_DEC_DR2H_REG    = ADC_CFG1_DEC_DR2H;
1254   2              ADC_DEC_DR1_REG     = ADC_CFG1_DEC_DR1;
1255   2              ADC_DEC_OCOR_REG    = ADC_CFG1_DEC_OCOR;
1256   2              ADC_DEC_OCORM_REG   = ADC_CFG1_DEC_OCORM;
1257   2              ADC_DEC_OCORH_REG   = ADC_CFG1_DEC_OCORH;
1258   2              ADC_DEC_COHER_REG   = ADC_CFG1_DEC_COHER;
1259   2      
1260   2              ADC_DSM_CR4_REG     = ADC_CFG1_DSM_CR4;
1261   2              ADC_DSM_CR5_REG     = ADC_CFG1_DSM_CR5;
1262   2              ADC_DSM_CR6_REG     = ADC_CFG1_DSM_CR6;
1263   2              ADC_DSM_CR7_REG     = ADC_CFG1_DSM_CR7;
1264   2              ADC_DSM_CR10_REG    = ADC_CFG1_DSM_CR10;
1265   2              ADC_DSM_CR11_REG    = ADC_CFG1_DSM_CR11;
1266   2              ADC_DSM_CR12_REG    = ADC_CFG1_DSM_CR12;
1267   2              ADC_DSM_CR14_REG    = ADC_CFG1_DSM_CR14;
1268   2              ADC_DSM_CR15_REG    = ADC_CFG1_DSM_CR15;
1269   2              ADC_DSM_CR16_REG    = ADC_CFG1_DSM_CR16;
1270   2              ADC_DSM_CR17_REG    = ADC_CFG1_DSM_CR17;
1271   2              /* Set DSM_REF0_REG by disabling and enabling the PRESS circuit */
1272   2              ADC_SetDSMRef0Reg(ADC_CFG1_DSM_REF0);
1273   2              ADC_DSM_REF2_REG    = ADC_CFG1_DSM_REF2;
1274   2              ADC_DSM_REF3_REG    = ADC_CFG1_DSM_REF3;
1275   2      
1276   2              ADC_DSM_BUF0_REG    = ADC_CFG1_DSM_BUF0;
1277   2              ADC_DSM_BUF1_REG    = ADC_CFG1_DSM_BUF1;
1278   2              ADC_DSM_BUF2_REG    = ADC_CFG1_DSM_BUF2;
1279   2              ADC_DSM_BUF3_REG    = ADC_CFG1_DSM_BUF3;
1280   2      
1281   2              /* To select either Vssa or Vref to -ve input of DSM depending on
1282   2              *  the input  range selected.
1283   2              */
1284   2              #if(ADC_DEFAULT_INPUT_MODE)
1285   2                  #if (ADC_CFG1_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)
                              ADC_AMux_Select(1u);
                          #else
1288   2                      ADC_AMux_Select(0u);
1289   2                  #endif /* ADC_IR_VSSA_TO_2VREF) */
1290   2              #endif /* ADC_DEFAULT_INPUT_MODE */
1291   2      
1292   2              /* Set the Conversion stop if resolution is above 16 bit and conversion
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 22  

1293   2              *   mode is Single sample
1294   2              */
1295   2              #if(ADC_CFG1_RESOLUTION > 16 && \
1296   2                  ADC_CFG1_CONV_MODE == ADC_MODE_SINGLE_SAMPLE)
                          ADC_stopConversion = 1u;
                      #endif /* Single sample with resolution above 16 bits. */
1299   2      
1300   2              ADC_CountsPerVolt = (int32)ADC_CFG1_COUNTS_PER_VOLT;
1301   2      
1302   2              ADC_Ext_CP_Clk_SetDividerRegister(ADC_CFG1_CP_CLK_DIVIDER, 1u);
1303   2      
1304   2              /* This is only valid if there is an internal clock */
1305   2              #if(ADC_DEFAULT_INTERNAL_CLK)
1306   2                  ADC_theACLK_SetDividerRegister(ADC_CFG1_ADC_CLK_DIVIDER, 1u);
1307   2              #endif /* ADC_DEFAULT_INTERNAL_CLK */
1308   2      
1309   2              #if(ADC_IRQ_REMOVE == 0u)
1310   2                  /* Set interrupt vector */
1311   2                  (void)CyIntSetVector(ADC_INTC_NUMBER, &ADC_ISR1);
1312   2              #endif   /* End ADC_IRQ_REMOVE */
1313   2          }
1314   1      
1315   1          #if(ADC_DEFAULT_NUM_CONFIGS > 1)
                      if(config == 2u)
                      {
                          /* Second Config */
                          ADC_DEC_CR_REG      = ADC_CFG2_DEC_CR;
                          ADC_DEC_SHIFT1_REG  = ADC_CFG2_DEC_SHIFT1;
                          ADC_DEC_SHIFT2_REG  = ADC_CFG2_DEC_SHIFT2;
                          ADC_DEC_DR2_REG     = ADC_CFG2_DEC_DR2;
                          ADC_DEC_DR2H_REG    = ADC_CFG2_DEC_DR2H;
                          ADC_DEC_DR1_REG     = ADC_CFG2_DEC_DR1;
                          ADC_DEC_OCOR_REG    = ADC_CFG2_DEC_OCOR;
                          ADC_DEC_OCORM_REG   = ADC_CFG2_DEC_OCORM;
                          ADC_DEC_OCORH_REG   = ADC_CFG2_DEC_OCORH;
                          ADC_DEC_COHER_REG   = ADC_CFG2_DEC_COHER;
              
                          ADC_DSM_CR4_REG     = ADC_CFG2_DSM_CR4;
                          ADC_DSM_CR5_REG     = ADC_CFG2_DSM_CR5;
                          ADC_DSM_CR6_REG     = ADC_CFG2_DSM_CR6;
                          ADC_DSM_CR7_REG     = ADC_CFG2_DSM_CR7;
                          ADC_DSM_CR10_REG    = ADC_CFG2_DSM_CR10;
                          ADC_DSM_CR11_REG    = ADC_CFG2_DSM_CR11;
                          ADC_DSM_CR12_REG    = ADC_CFG2_DSM_CR12;
                          ADC_DSM_CR14_REG    = ADC_CFG2_DSM_CR14;
                          ADC_DSM_CR15_REG    = ADC_CFG2_DSM_CR15;
                          ADC_DSM_CR16_REG    = ADC_CFG2_DSM_CR16;
                          ADC_DSM_CR17_REG    = ADC_CFG2_DSM_CR17;
                          /* Set DSM_REF0_REG by disabling and enabling the PRESS cirucit */
                          ADC_SetDSMRef0Reg(ADC_CFG2_DSM_REF0);
                          ADC_DSM_REF2_REG    = ADC_CFG2_DSM_REF2;
                          ADC_DSM_REF3_REG    = ADC_CFG2_DSM_REF3;
              
                          ADC_DSM_BUF0_REG    = ADC_CFG2_DSM_BUF0;
                          ADC_DSM_BUF1_REG    = ADC_CFG2_DSM_BUF1;
                          ADC_DSM_BUF2_REG    = ADC_CFG2_DSM_BUF2;
                          ADC_DSM_BUF3_REG    = ADC_CFG2_DSM_BUF3;
              
                          /* To select either Vssa or Vref to -ve input of DSM depending on
                          *  the input range selected.
                          */
              
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 23  

                          #if(ADC_DEFAULT_INPUT_MODE)
                              #if (ADC_CFG2_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)
                                  ADC_AMux_Select(1u);
                              #else
                                  ADC_AMux_Select(0u);
                              #endif /* ADC_IR_VSSA_TO_2VREF) */
                          #endif /* ADC_DEFAULT_INPUT_MODE */
              
                          /* Set the Conversion stop if resolution is above 16 bit and
                          *   conversion mode is Single sample
                          */
                          #if(ADC_CFG2_RESOLUTION > 16 && \
                              ADC_CFG2_CONV_MODE == ADC_MODE_SINGLE_SAMPLE)
                              ADC_stopConversion = 1u;
                          #endif /* Single sample with resolution above 16 bits. */
              
                          ADC_CountsPerVolt = (int32)ADC_CFG2_COUNTS_PER_VOLT;
              
                          ADC_Ext_CP_Clk_SetDividerRegister(ADC_CFG2_CP_CLK_DIVIDER, 1u);
              
                          /* This is only valid if there is an internal clock */
                          #if(ADC_DEFAULT_INTERNAL_CLK)
                              ADC_theACLK_SetDividerRegister(ADC_CFG2_ADC_CLK_DIVIDER, 1u);
                          #endif /* ADC_DEFAULT_INTERNAL_CLK */
              
                          #if(ADC_IRQ_REMOVE == 0u)
                              /* Set interrupt vector */
                              (void)CyIntSetVector(ADC_INTC_NUMBER, &ADC_ISR2);
                          #endif   /* End ADC_IRQ_REMOVE */
                      }
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 1 */
1386   1      
1387   1          #if(ADC_DEFAULT_NUM_CONFIGS > 2)
                      if(config == 3u)
                      {
                          /* Third Config */
                          ADC_DEC_CR_REG      = ADC_CFG3_DEC_CR;
                          ADC_DEC_SHIFT1_REG  = ADC_CFG3_DEC_SHIFT1;
                          ADC_DEC_SHIFT2_REG  = ADC_CFG3_DEC_SHIFT2;
                          ADC_DEC_DR2_REG     = ADC_CFG3_DEC_DR2;
                          ADC_DEC_DR2H_REG    = ADC_CFG3_DEC_DR2H;
                          ADC_DEC_DR1_REG     = ADC_CFG3_DEC_DR1;
                          ADC_DEC_OCOR_REG    = ADC_CFG3_DEC_OCOR;
                          ADC_DEC_OCORM_REG   = ADC_CFG3_DEC_OCORM;
                          ADC_DEC_OCORH_REG   = ADC_CFG3_DEC_OCORH;
                          ADC_DEC_COHER_REG   = ADC_CFG3_DEC_COHER;
              
                          ADC_DSM_CR4_REG     = ADC_CFG3_DSM_CR4;
                          ADC_DSM_CR5_REG     = ADC_CFG3_DSM_CR5;
                          ADC_DSM_CR6_REG     = ADC_CFG3_DSM_CR6;
                          ADC_DSM_CR7_REG     = ADC_CFG3_DSM_CR7;
                          ADC_DSM_CR10_REG    = ADC_CFG3_DSM_CR10;
                          ADC_DSM_CR11_REG    = ADC_CFG3_DSM_CR11;
                          ADC_DSM_CR12_REG    = ADC_CFG3_DSM_CR12;
                          ADC_DSM_CR14_REG    = ADC_CFG3_DSM_CR14;
                          ADC_DSM_CR15_REG    = ADC_CFG3_DSM_CR15;
                          ADC_DSM_CR16_REG    = ADC_CFG3_DSM_CR16;
                          ADC_DSM_CR17_REG    = ADC_CFG3_DSM_CR17;
                          /* Set DSM_REF0_REG by disabling and enabling the PRESS circuit */
                          ADC_SetDSMRef0Reg(ADC_CFG3_DSM_REF0);
                          ADC_DSM_REF2_REG    = ADC_CFG3_DSM_REF2;
                          ADC_DSM_REF3_REG    = ADC_CFG3_DSM_REF3;
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 24  

              
                          ADC_DSM_BUF0_REG    = ADC_CFG3_DSM_BUF0;
                          ADC_DSM_BUF1_REG    = ADC_CFG3_DSM_BUF1;
                          ADC_DSM_BUF2_REG    = ADC_CFG3_DSM_BUF2;
                          ADC_DSM_BUF3_REG    = ADC_CFG3_DSM_BUF3;
              
                          /* To select either Vssa or Vref to -ve input of DSM depending on
                          *  the input range selected.
                          */
                          #if(ADC_DEFAULT_INPUT_MODE)
                              #if (ADC_CFG3_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)
                                  ADC_AMux_Select(1u);
                              #else
                                  ADC_AMux_Select(0u);
                              #endif /* ADC_IR_VSSA_TO_2VREF) */
                          #endif /* ADC_DEFAULT_INPUT_MODE */
              
                          /* Set the Conversion stop if resolution is above 16 bit and
                             conversion  mode is Single sample */
                          #if(ADC_CFG3_RESOLUTION > 16 && \
                              ADC_CFG3_CONV_MODE == ADC_MODE_SINGLE_SAMPLE)
                              ADC_stopConversion = 1u;
                          #endif /* Single sample with resolution above 16 bits */
              
                          ADC_CountsPerVolt = (int32)ADC_CFG3_COUNTS_PER_VOLT;
              
                          ADC_Ext_CP_Clk_SetDividerRegister(ADC_CFG3_CP_CLK_DIVIDER, 1u);
              
                          /* This is only valid if there is an internal clock */
                          #if(ADC_DEFAULT_INTERNAL_CLK)
                              ADC_theACLK_SetDividerRegister(ADC_CFG3_ADC_CLK_DIVIDER, 1u);
                          #endif /* ADC_DEFAULT_INTERNAL_CLK */
              
                          #if(ADC_IRQ_REMOVE == 0u)
                              /* Set interrupt vector */
                              (void)CyIntSetVector(ADC_INTC_NUMBER, &ADC_ISR3);
                          #endif   /* End ADC_IRQ_REMOVE */
                      }
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 2 */
1456   1      
1457   1          #if(ADC_DEFAULT_NUM_CONFIGS > 3)
                      if (config == 4u)
                      {
                          /* Fourth Config */
                          ADC_DEC_CR_REG      = ADC_CFG4_DEC_CR;
                          ADC_DEC_SHIFT1_REG  = ADC_CFG4_DEC_SHIFT1;
                          ADC_DEC_SHIFT2_REG  = ADC_CFG4_DEC_SHIFT2;
                          ADC_DEC_DR2_REG     = ADC_CFG4_DEC_DR2;
                          ADC_DEC_DR2H_REG    = ADC_CFG4_DEC_DR2H;
                          ADC_DEC_DR1_REG     = ADC_CFG4_DEC_DR1;
                          ADC_DEC_OCOR_REG    = ADC_CFG4_DEC_OCOR;
                          ADC_DEC_OCORM_REG   = ADC_CFG4_DEC_OCORM;
                          ADC_DEC_OCORH_REG   = ADC_CFG4_DEC_OCORH;
                          ADC_DEC_COHER_REG   = ADC_CFG4_DEC_COHER;
              
                          ADC_DSM_CR4_REG     = ADC_CFG4_DSM_CR4;
                          ADC_DSM_CR5_REG     = ADC_CFG4_DSM_CR5;
                          ADC_DSM_CR6_REG     = ADC_CFG4_DSM_CR6;
                          ADC_DSM_CR7_REG     = ADC_CFG4_DSM_CR7;
                          ADC_DSM_CR10_REG    = ADC_CFG4_DSM_CR10;
                          ADC_DSM_CR11_REG    = ADC_CFG4_DSM_CR11;
                          ADC_DSM_CR12_REG    = ADC_CFG4_DSM_CR12;
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 25  

                          ADC_DSM_CR14_REG    = ADC_CFG4_DSM_CR14;
                          ADC_DSM_CR15_REG    = ADC_CFG4_DSM_CR15;
                          ADC_DSM_CR16_REG    = ADC_CFG4_DSM_CR16;
                          ADC_DSM_CR17_REG    = ADC_CFG4_DSM_CR17;
                          /* Set DSM_REF0_REG by disabling and enabling the PRESS circuit */
                          ADC_SetDSMRef0Reg(ADC_CFG4_DSM_REF0);
                          ADC_DSM_REF2_REG    = ADC_CFG4_DSM_REF2;
                          ADC_DSM_REF3_REG    = ADC_CFG4_DSM_REF3;
              
                          ADC_DSM_BUF0_REG    = ADC_CFG4_DSM_BUF0;
                          ADC_DSM_BUF1_REG    = ADC_CFG4_DSM_BUF1;
                          ADC_DSM_BUF2_REG    = ADC_CFG4_DSM_BUF2;
                          ADC_DSM_BUF3_REG    = ADC_CFG4_DSM_BUF3;
              
                          /* To select either Vssa or Vref to -ve input of DSM depending on
                          *  the input range selected.
                          */
                          #if(ADC_DEFAULT_INPUT_MODE)
                              #if (ADC_CFG4_INPUT_RANGE == ADC_IR_VSSA_TO_2VREF)
                                  ADC_AMux_Select(1u);
                              #else
                                  ADC_AMux_Select(0u);
                              #endif /* ADC_IR_VSSA_TO_2VREF) */
                          #endif /* ADC_DEFAULT_INPUT_MODE */
              
                          /* Set the Conversion stop if resolution is above 16 bit and
                             conversion mode is Single sample */
                          #if(ADC_CFG4_RESOLUTION > 16 && \
                              ADC_CFG4_CONV_MODE == ADC_MODE_SINGLE_SAMPLE)
                              ADC_stopConversion = 1u;
                          #endif /* Single sample with resolution above 16 bits */
              
                          ADC_CountsPerVolt = (int32)ADC_CFG4_COUNTS_PER_VOLT;
              
                          ADC_Ext_CP_Clk_SetDividerRegister(ADC_CFG4_CP_CLK_DIVIDER, 1u);
              
                          /* This is only valid if there is an internal clock */
                          #if(ADC_DEFAULT_INTERNAL_CLK)
                              ADC_theACLK_SetDividerRegister(ADC_CFG4_ADC_CLK_DIVIDER, 1u);
                          #endif /* ADC_DEFAULT_INTERNAL_CLK */
              
                          #if(ADC_IRQ_REMOVE == 0u)
                              /* Set interrupt vector */
                              (void)CyIntSetVector(ADC_INTC_NUMBER, &ADC_ISR4);
                          #endif   /* End ADC_IRQ_REMOVE */
                      }
                  #endif /* ADC_DEFAULT_NUM_CONFIGS > 3 */
1526   1      }
1527          
1528          
1529          /*******************************************************************************
1530          * Function Name: ADC_SelectCofiguration
1531          ********************************************************************************
1532          *
1533          * Summary:
1534          *  Sets one of up to four ADC configurations. Before setting the new
1535          *  configuration, the ADC is stopped and powered down. After setting
1536          *  the new configuration, the ADC can be powered and conversion
1537          *  can be restarted depending up on the value of second parameter
1538          *  restart. If the value of this parameter is 1, then ADC will be
1539          *  restarted. If this value is zero, then user must call ADC_Start
1540          *  and ADC_StartConvert() to restart the conversion.
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 26  

1541          *
1542          * Parameters:
1543          *  config:  configuration user wants to select.
1544          *           Valid range: 1..4
1545          *  restart:  Restart option. 1 means start the ADC and restart the conversion.
1546          *                            0 means do not start the ADC and conversion.
1547          *
1548          * Return:
1549          *  None
1550          *
1551          *******************************************************************************/
1552          void ADC_SelectConfiguration(uint8 config, uint8 restart)
1553                                                        
1554          {
1555   1          /* Check whether the configuration number is valid or not */
1556   1          if((config > 0u) && (config <= ADC_DEFAULT_NUM_CONFIGS))
1557   1          {
1558   2              /* Set the flag to ensure Start() API doesn't override the 
1559   2                      *  selected configuration
1560   2                      */
1561   2              if(ADC_initVar == 0u)
1562   2              {
1563   3                  ADC_started = 1u;
1564   3              }
1565   2      
1566   2              /* Update the config flag */
1567   2              ADC_Config = config;
1568   2      
1569   2              /* Stop the ADC  */
1570   2              ADC_Stop();
1571   2      
1572   2              /* Set the  ADC registers based on the configuration */
1573   2              ADC_InitConfig(config);
1574   2      
1575   2              /* Compensate the gain */
1576   2              ADC_DEC_GVAL_REG = ADC_gcor[config - 1u].gval;
1577   2              CY_SET_REG16(ADC_DEC_GCOR_16B_PTR, ADC_gcor[config - 1u].gcor);
1578   2      
1579   2              if(restart == 1u)
1580   2              {
1581   3                  /* Restart the ADC */
1582   3                  ADC_Start();
1583   3      
1584   3                  /* Restart the ADC conversion */
1585   3                  ADC_StartConvert();
1586   3              }
1587   2          }
1588   1          else
1589   1          {
1590   2              /* Halt CPU in debug mode if config is out of valid range */
1591   2              CYASSERT(0u != 0u);
1592   2          }
1593   1      }
1594          
1595          
1596          /*******************************************************************************
1597          * Function Name: ADC_GainCompensation
1598          ********************************************************************************
1599          *
1600          * Summary:
1601          *  This API calculates the trim value and then store this to gcor structure.
1602          *
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 27  

1603          * Parameters:
1604          *  inputRange:  input range for which trim value is to be calculated.
1605          *  IdealDecGain:  Ideal Decimator gain for the selected resolution and
1606          *                 conversion  mode.
1607          *  IdealOddDecGain:  Ideal odd decimation gain for the selected resolution and
1608                               conversion mode.
1609          *  resolution:  Resolution to select the proper flash location for trim value.
1610          *  config:      Specifies the configuration number
1611          *               Valid range: 1..4
1612          *
1613          * Return:
1614          *  None
1615          *
1616          *******************************************************************************/
1617          static void ADC_GainCompensation(uint8 inputRange, uint16 idealDecGain, uint16 idealOddDecGain,
1618                                        uint8 resolution, uint8 config) 
1619          {
1620   1          int8 flash;
1621   1              int32 normalised;
1622   1              uint16 gcorValue;
1623   1          uint32 gcorTmp;
1624   1      
1625   1          if((config > 0u) && (config <= ADC_DEFAULT_NUM_CONFIGS))
1626   1          {
1627   2              switch(inputRange)
1628   2              {
1629   3                  case ADC_IR_VNEG_VREF_DIFF:
1630   3                  case ADC_IR_VSSA_TO_2VREF:
1631   3                      /* Normalize the flash Value */
1632   3                      if(resolution > 15u)
1633   3                      {
1634   4                          flash = ADC_DEC_TRIM_VREF_DIFF_16_20;
1635   4                      }
1636   3                      else
1637   3                      {
1638   4                          flash = ADC_DEC_TRIM_VREF_DIFF_8_15;
1639   4                      }
1640   3                      break;
1641   3      
1642   3                  case ADC_IR_VNEG_VREF_2_DIFF:
1643   3                      /* Normalize the flash Value */
1644   3                      if(resolution > 15u)
1645   3                      {
1646   4                          flash = ADC_DEC_TRIM_VREF_2_DIFF_16_20;
1647   4                      }
1648   3                      else
1649   3                      {
1650   4                          flash = ADC_DEC_TRIM_VREF_2_DIFF_8_15;
1651   4                      }
1652   3                      break;
1653   3      
1654   3                  case ADC_IR_VNEG_VREF_4_DIFF:
1655   3                      /* Normalize the flash Value */
1656   3                      if(resolution > 15u)
1657   3                      {
1658   4                          flash = ADC_DEC_TRIM_VREF_4_DIFF_16_20;
1659   4                      }
1660   3                      else
1661   3                      {
1662   4                          flash = ADC_DEC_TRIM_VREF_4_DIFF_8_15;
1663   4                      }
1664   3                      break;
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 28  

1665   3      
1666   3                  case ADC_IR_VNEG_VREF_16_DIFF:
1667   3                      /* Normalize the flash Value */
1668   3                      if(resolution > 15u)
1669   3                      {
1670   4                          flash = ADC_DEC_TRIM_VREF_16_DIFF_16_20;
1671   4                      }
1672   3                      else
1673   3                      {
1674   4                          flash = ADC_DEC_TRIM_VREF_16_DIFF_8_15;
1675   4                      }
1676   3                      break;
1677   3      
1678   3                  default:
1679   3                      flash = 0;
1680   3                      break;
1681   3              }
1682   2      
1683   2              /* Add two values */
1684   2                      normalised = (int32)idealDecGain + ((int32)flash * 32);
1685   2              gcorTmp = (uint32)normalised * (uint32)idealOddDecGain;
1686   2              gcorValue = (uint16)(gcorTmp / ADC_IDEAL_GAIN_CONST);
1687   2      
1688   2              if (resolution < (ADC_MAX_GVAL - 1u))
1689   2              {
1690   3                  gcorValue = (gcorValue >> (ADC_MAX_GVAL - (resolution + 1u)));
1691   3                  ADC_gcor[config - 1u].gval = (resolution + 1u);
1692   3              }
1693   2              else
1694   2              {
1695   3                  /* Use all 16 bits */
1696   3                  ADC_gcor[config - 1u].gval = ADC_MAX_GVAL;
1697   3              }
1698   2      
1699   2              /* Save the gain correction register value */
1700   2              ADC_gcor[config - 1u].gcor = gcorValue;
1701   2          }
1702   1          else
1703   1          {
1704   2              /* Halt CPU in debug mode if config is out of valid range */
1705   2              CYASSERT(0u != 0u);
1706   2          }
1707   1      }
1708          
1709          
1710          /******************************************************************************
1711          * Function Name: ADC_SetDSMRef0Reg(uint8)
1712          ******************************************************************************
1713          *
1714          * Summary:
1715          *  This API sets the DSM_REF0 register. This is written for internal use.
1716          *
1717          * Parameters:
1718          *  value:  Value to be written to DSM_REF0 register.
1719          *
1720          * Return:
1721          *  None
1722          *
1723          ******************************************************************************/
1724          static void ADC_SetDSMRef0Reg(uint8 value) 
1725          {
1726   1          uint8 enableInterrupts;
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 29  

1727   1          enableInterrupts = CyEnterCriticalSection();
1728   1      
1729   1          /* Disable PRES, Enable power to VCMBUF0, REFBUF0 and REFBUF1, enable PRES */
1730   1          ADC_RESET_CR4_REG |= (ADC_IGNORE_PRESA1 | ADC_IGNORE_PRESD1);
1731   1          ADC_RESET_CR5_REG |= (ADC_IGNORE_PRESA2 | ADC_IGNORE_PRESD2);
1732   1          ADC_DSM_REF0_REG = value;
1733   1      
1734   1          /* Wait for 3 microseconds */
1735   1          CyDelayUs(ADC_PRES_DELAY_TIME);
1736   1          /* Enable the press circuit */
1737   1          ADC_RESET_CR4_REG &= (uint8)~(ADC_IGNORE_PRESA1 | ADC_IGNORE_PRESD1);
1738   1          ADC_RESET_CR5_REG &= (uint8)~(ADC_IGNORE_PRESA2 | ADC_IGNORE_PRESD2);
1739   1      
1740   1          CyExitCriticalSection(enableInterrupts);
1741   1      }
1742          
1743          
1744          /*******************************************************************************
1745          * Function Name: ADC_Read8
1746          ********************************************************************************
1747          *
1748          * Summary:
1749          *  This function simplifies getting results from the ADC when only a
1750          *  single reading is required. When called, it will start ADC
1751          *  conversions, wait for the conversion to be complete, stop ADC
1752          *  conversion and return the result. This is a blocking function and will
1753          *  not return until the result is ready.
1754          *
1755          * Parameters:
1756          *  None
1757          *
1758          * Return:
1759          *  int8:  ADC result.
1760          *
1761          *******************************************************************************/
1762          int8 ADC_Read8(void) 
1763          {
1764   1          int8 result;
1765   1      
1766   1          /* Clear pending conversion done status */
1767   1          ADC_DEC_SR_REG |= ADC_DEC_INTR_CLEAR;
1768   1          ADC_StartConvert();
1769   1          (void)ADC_IsEndConversion(ADC_WAIT_FOR_RESULT);
1770   1           result = ADC_GetResult8();
1771   1          ADC_StopConvert();
1772   1          
1773   1           return(result);
1774   1      }
1775          
1776          
1777          /*******************************************************************************
1778          * Function Name: ADC_Read16
1779          ********************************************************************************
1780          *
1781          * Summary:
1782          *  This function simplifies getting results from the ADC when only a
1783          *  single reading is required. When called, it will start ADC
1784          *  conversions, wait for the conversion to be complete, stop ADC
1785          *  conversion and return the result. This is a blocking function and will
1786          *  not return until the result is ready.
1787          *
1788          * Parameters:
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 30  

1789          *   void
1790          *
1791          * Return:
1792          *  int16:  ADC result.
1793          *
1794          *******************************************************************************/
1795          int16 ADC_Read16(void) 
1796          {
1797   1          int16 result;
1798   1      
1799   1          /* Clear pending conversion done status */
1800   1          ADC_DEC_SR_REG |= ADC_DEC_INTR_CLEAR;
1801   1          ADC_StartConvert();
1802   1          (void)ADC_IsEndConversion(ADC_WAIT_FOR_RESULT);
1803   1           result = ADC_GetResult16();
1804   1          ADC_StopConvert();
1805   1          
1806   1           return(result);
1807   1      }
1808          
1809          
1810          /*******************************************************************************
1811          * Function Name: ADC_Read32
1812          ********************************************************************************
1813          *
1814          * Summary:
1815          *  This function simplifies getting results from the ADC when only a
1816          *  single reading is required. When called, it will start ADC
1817          *  conversions, wait for the conversion to be complete, stop ADC
1818          *  conversion and return the result. This is a blocking function and will
1819          *  not return until the result is ready.
1820          *
1821          * Parameters:
1822          *  None
1823          *
1824          * Return:
1825          *  int32: ADC result.
1826          *
1827          *******************************************************************************/
1828          int32 ADC_Read32(void) 
1829          {
1830   1          int32 result;
1831   1          
1832   1          /* Clear pending conversion done status */
1833   1          ADC_DEC_SR_REG |= ADC_DEC_INTR_CLEAR;
1834   1          ADC_StartConvert();
1835   1          (void)ADC_IsEndConversion(ADC_WAIT_FOR_RESULT);
1836   1           result = ADC_GetResult32();
1837   1          ADC_StopConvert();
1838   1          
1839   1           return(result);
1840   1      }
1841          
1842          
1843          /* [] END OF FILE */
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 31  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION ADC_Init (BEGIN)
                                           ; SOURCE LINE # 91
                                           ; SOURCE LINE # 92
                                           ; SOURCE LINE # 94
0000 900000      R     MOV     DPTR,#ADC_Config
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 95
0006 E4                CLR     A
0007 900000      R     MOV     DPTR,#ADC_convDone
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 97
000B 7F10              MOV     R7,#010H
000D 120000      E     LCALL   _ADC_Ext_CP_Clk_SetModeRegister
                                           ; SOURCE LINE # 101
0010 7F10              MOV     R7,#010H
0012 120000      E     LCALL   _ADC_theACLK_SetModeRegister
                                           ; SOURCE LINE # 106
0015 7D07              MOV     R5,#07H
0017 7F1D              MOV     R7,#01DH
0019 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 110
001C 905896            MOV     DPTR,#05896H
001F 7404              MOV     A,#04H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 111
0022 A3                INC     DPTR
0023 E4                CLR     A
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 112
0025 90589E            MOV     DPTR,#0589EH
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 113
0029 905B07            MOV     DPTR,#05B07H
002C E0                MOVX    A,@DPTR
002D 4418              ORL     A,#018H
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 114
0030 905893            MOV     DPTR,#05893H
0033 E4                CLR     A
0034 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 116
0035 905B88            MOV     DPTR,#05B88H
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 117
0039 A3                INC     DPTR
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 119
003B 905880            MOV     DPTR,#05880H
003E 740A              MOV     A,#0AH
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 120
0041 A3                INC     DPTR
0042 E4                CLR     A
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 124
0044 905883            MOV     DPTR,#05883H
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 126
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 32  

0048 905888            MOV     DPTR,#05888H
004B 7412              MOV     A,#012H
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 127
004E A3                INC     DPTR
004F 04                INC     A
0050 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 128
0051 90588D            MOV     DPTR,#0588DH
0054 E4                CLR     A
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 130
0056 904E01            MOV     DPTR,#04E01H
0059 7414              MOV     A,#014H
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 133
005C 900000      R     MOV     DPTR,#?_ADC_GainCompensation?BYTE+05H
005F 740C              MOV     A,#0CH
0061 F0                MOVX    @DPTR,A
0062 A3                INC     DPTR
0063 7401              MOV     A,#01H
0065 F0                MOVX    @DPTR,A
0066 7B00              MOV     R3,#00H
0068 7A80              MOV     R2,#080H
006A 7D6B              MOV     R5,#06BH
006C 7C8D              MOV     R4,#08DH
006E 7F02              MOV     R7,#02H
0070 120000      R     LCALL   _ADC_GainCompensation
                                           ; SOURCE LINE # 161
0073 900000      R     MOV     DPTR,#ADC_Config
0076 E0                MOVX    A,@DPTR
0077 75F003            MOV     B,#03H
007A A4                MUL     AB
007B 2400        R     ADD     A,#LOW ADC_gcor+0FFFFH
007D F582              MOV     DPL,A
007F E4                CLR     A
0080 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFFH
0082 F583              MOV     DPH,A
0084 E0                MOVX    A,@DPTR
0085 904E0E            MOV     DPTR,#04E0EH
0088 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 162
0089 900000      R     MOV     DPTR,#ADC_Config
008C E0                MOVX    A,@DPTR
008D 75F003            MOV     B,#03H
0090 A4                MUL     AB
0091 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
0093 F582              MOV     DPL,A
0095 E4                CLR     A
0096 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
0098 F583              MOV     DPH,A
009A E0                MOVX    A,@DPTR
009B FC                MOV     R4,A
009C A3                INC     DPTR
009D E0                MOVX    A,@DPTR
009E FD                MOV     R5,A
009F 7B02              MOV     R3,#02H
00A1 7A4E              MOV     R2,#04EH
00A3 790C              MOV     R1,#0CH
00A5 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 165
00A8 900000      R     MOV     DPTR,#ADC_Config
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 33  

00AB E0                MOVX    A,@DPTR
00AC FF                MOV     R7,A
00AD 120000      R     LCALL   _ADC_InitConfig
                                           ; SOURCE LINE # 166
00B0 22                RET     
             ; FUNCTION ADC_Init (END)

             ; FUNCTION ADC_Enable (BEGIN)
                                           ; SOURCE LINE # 184
                                           ; SOURCE LINE # 185
                                           ; SOURCE LINE # 188
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 191
0008 900000      R     MOV     DPTR,#ADC_Config
000B E0                MOVX    A,@DPTR
000C 900000      R     MOV     DPTR,#config
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 194
0010 9043AA            MOV     DPTR,#043AAH
0013 E0                MOVX    A,@DPTR
0014 4401              ORL     A,#01H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 195
0017 E0                MOVX    A,@DPTR
0018 4410              ORL     A,#010H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 198
001B 9043BA            MOV     DPTR,#043BAH
001E E0                MOVX    A,@DPTR
001F 4401              ORL     A,#01H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 199
0022 E0                MOVX    A,@DPTR
0023 4410              ORL     A,#010H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 202
0026 9046F8            MOV     DPTR,#046F8H
0029 E0                MOVX    A,@DPTR
002A 4402              ORL     A,#02H
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 203
002D A3                INC     DPTR
002E E0                MOVX    A,@DPTR
002F 4402              ORL     A,#02H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 205
0032 905891            MOV     DPTR,#05891H
0035 E0                MOVX    A,@DPTR
0036 4403              ORL     A,#03H
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 265
                                           ; SOURCE LINE # 266
                                           ; SOURCE LINE # 268
0039         ?C0002:
                                           ; SOURCE LINE # 271
0039 7F03              MOV     R7,#03H
003B 7E00              MOV     R6,#00H
003D 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 274
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 34  

0040 9046F8            MOV     DPTR,#046F8H
0043 E0                MOVX    A,@DPTR
0044 54FD              ANL     A,#0FDH
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 275
0047 A3                INC     DPTR
0048 E0                MOVX    A,@DPTR
0049 54FD              ANL     A,#0FDH
004B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 278
004C 905877            MOV     DPTR,#05877H
004F E0                MOVX    A,@DPTR
0050 4406              ORL     A,#06H
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 281
0053 905882            MOV     DPTR,#05882H
0056 747A              MOV     A,#07AH
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 285
0059 9043A1            MOV     DPTR,#043A1H
005C E0                MOVX    A,@DPTR
005D 4401              ORL     A,#01H
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 286
0060 9043B1            MOV     DPTR,#043B1H
0063 E0                MOVX    A,@DPTR
0064 4401              ORL     A,#01H
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 290
0067 9043A2            MOV     DPTR,#043A2H
006A E0                MOVX    A,@DPTR
006B 4402              ORL     A,#02H
006D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 291
006E 9043B2            MOV     DPTR,#043B2H
0071 E0                MOVX    A,@DPTR
0072 4402              ORL     A,#02H
0074 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 295
0075 9044DB            MOV     DPTR,#044DBH
0078 7420              MOV     A,#020H
007A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 297
007B 9044C3            MOV     DPTR,#044C3H
007E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 300
007F 900000      R     MOV     DPTR,#enableInterrupts
0082 E0                MOVX    A,@DPTR
0083 FF                MOV     R7,A
0084 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 302
0087 22                RET     
             ; FUNCTION ADC_Enable (END)

             ; FUNCTION ADC_Start (BEGIN)
                                           ; SOURCE LINE # 329
                                           ; SOURCE LINE # 330
                                           ; SOURCE LINE # 331
0000 900000      R     MOV     DPTR,#ADC_initVar
0003 E0                MOVX    A,@DPTR
0004 700F              JNZ     ?C0004
                                           ; SOURCE LINE # 332
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 35  

                                           ; SOURCE LINE # 333
0006 900000      R     MOV     DPTR,#ADC_started
0009 E0                MOVX    A,@DPTR
000A 7003              JNZ     ?C0005
                                           ; SOURCE LINE # 334
                                           ; SOURCE LINE # 335
000C 120000      R     LCALL   ADC_Init
                                           ; SOURCE LINE # 336
000F         ?C0005:
                                           ; SOURCE LINE # 337
000F 900000      R     MOV     DPTR,#ADC_initVar
0012 7401              MOV     A,#01H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 338
0015         ?C0004:
                                           ; SOURCE LINE # 341
0015 120000      R     LCALL   ADC_Enable
                                           ; SOURCE LINE # 342
0018 22                RET     
             ; FUNCTION ADC_Start (END)

             ; FUNCTION ADC_Stop (BEGIN)
                                           ; SOURCE LINE # 362
                                           ; SOURCE LINE # 363
                                           ; SOURCE LINE # 365
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 368
0008 904E00            MOV     DPTR,#04E00H
000B E0                MOVX    A,@DPTR
000C 54FE              ANL     A,#0FEH
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 369
000F A3                INC     DPTR
0010 E0                MOVX    A,@DPTR
0011 4404              ORL     A,#04H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 373
0014 9046F8            MOV     DPTR,#046F8H
0017 E0                MOVX    A,@DPTR
0018 4402              ORL     A,#02H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 374
001B A3                INC     DPTR
001C E0                MOVX    A,@DPTR
001D 4402              ORL     A,#02H
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 376
0020 905891            MOV     DPTR,#05891H
0023 E0                MOVX    A,@DPTR
0024 54FC              ANL     A,#0FCH
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 377
0027 A3                INC     DPTR
0028 E0                MOVX    A,@DPTR
0029 54F7              ANL     A,#0F7H
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 380
002C 7F03              MOV     R7,#03H
002E 7E00              MOV     R6,#00H
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 36  

0030 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 383
0033 9046F8            MOV     DPTR,#046F8H
0036 E0                MOVX    A,@DPTR
0037 54FD              ANL     A,#0FDH
0039 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 384
003A A3                INC     DPTR
003B E0                MOVX    A,@DPTR
003C 54FD              ANL     A,#0FDH
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 387
003F 9043AA            MOV     DPTR,#043AAH
0042 E0                MOVX    A,@DPTR
0043 54EF              ANL     A,#0EFH
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 390
0046 E0                MOVX    A,@DPTR
0047 54FE              ANL     A,#0FEH
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 393
004A 9043BA            MOV     DPTR,#043BAH
004D E0                MOVX    A,@DPTR
004E 54FE              ANL     A,#0FEH
0050 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 394
0051 E0                MOVX    A,@DPTR
0052 54EF              ANL     A,#0EFH
0054 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 397
0055 905877            MOV     DPTR,#05877H
0058 E0                MOVX    A,@DPTR
0059 54F9              ANL     A,#0F9H
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 401
005C 9043A1            MOV     DPTR,#043A1H
005F E0                MOVX    A,@DPTR
0060 54FE              ANL     A,#0FEH
0062 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 402
0063 9043B1            MOV     DPTR,#043B1H
0066 E0                MOVX    A,@DPTR
0067 54FE              ANL     A,#0FEH
0069 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 406
006A 905882            MOV     DPTR,#05882H
006D E0                MOVX    A,@DPTR
006E 54F7              ANL     A,#0F7H
0070 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 408
0071 9043A2            MOV     DPTR,#043A2H
0074 E0                MOVX    A,@DPTR
0075 54FD              ANL     A,#0FDH
0077 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 409
0078 9043B2            MOV     DPTR,#043B2H
007B E0                MOVX    A,@DPTR
007C 54FD              ANL     A,#0FDH
007E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 411
007F 900000      R     MOV     DPTR,#enableInterrupts
0082 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 37  

0083 FF                MOV     R7,A
0084 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 412
0087 22                RET     
             ; FUNCTION ADC_Stop (END)

             ; FUNCTION _ADC_SetBufferGain (BEGIN)
                                           ; SOURCE LINE # 429
;---- Variable 'gain' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 430
                                           ; SOURCE LINE # 432
0000 90589B            MOV     DPTR,#0589BH
0003 E0                MOVX    A,@DPTR
0004 54F3              ANL     A,#0F3H
0006 FE                MOV     R6,A
;---- Variable 'tmpReg' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 433
0007 EF                MOV     A,R7
0008 25E0              ADD     A,ACC
000A 25E0              ADD     A,ACC
000C 540C              ANL     A,#0CH
000E 4E                ORL     A,R6
000F FE                MOV     R6,A
                                           ; SOURCE LINE # 434
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 435
0011 22                RET     
             ; FUNCTION _ADC_SetBufferGain (END)

             ; FUNCTION _ADC_SetCoherency (BEGIN)
                                           ; SOURCE LINE # 465
;---- Variable 'coherency' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 466
                                           ; SOURCE LINE # 469
0000 904E14            MOV     DPTR,#04E14H
0003 E0                MOVX    A,@DPTR
0004 54FC              ANL     A,#0FCH
0006 FE                MOV     R6,A
;---- Variable 'tmpReg' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 470
0007 EF                MOV     A,R7
0008 5403              ANL     A,#03H
000A 4E                ORL     A,R6
000B FE                MOV     R6,A
                                           ; SOURCE LINE # 471
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 472
000D 22                RET     
             ; FUNCTION _ADC_SetCoherency (END)

             ; FUNCTION _ADC_SetGCOR (BEGIN)
                                           ; SOURCE LINE # 505
0000 900000      R     MOV     DPTR,#gainAdjust
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 506
                                           ; SOURCE LINE # 511
0006 900000      R     MOV     DPTR,#ADC_Config
0009 E0                MOVX    A,@DPTR
000A 75F003            MOV     B,#03H
000D A4                MUL     AB
000E 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
0010 F582              MOV     DPL,A
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 38  

0012 E4                CLR     A
0013 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
0015 F583              MOV     DPH,A
0017 E0                MOVX    A,@DPTR
0018 FF                MOV     R7,A
0019 A3                INC     DPTR
001A E0                MOVX    A,@DPTR
001B 900000      R     MOV     DPTR,#tmpReg
001E CF                XCH     A,R7
001F F0                MOVX    @DPTR,A
0020 A3                INC     DPTR
0021 EF                MOV     A,R7
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 512
0023 900000      R     MOV     DPTR,#tmpReg
0026 E0                MOVX    A,@DPTR
0027 FC                MOV     R4,A
0028 A3                INC     DPTR
0029 E0                MOVX    A,@DPTR
002A FD                MOV     R5,A
002B E4                CLR     A
002C 120000      E     LCALL   ?C?FCASTI
002F E4                CLR     A
0030 FB                MOV     R3,A
0031 FA                MOV     R2,A
0032 F9                MOV     R1,A
0033 7847              MOV     R0,#047H
0035 120000      E     LCALL   ?C?FPDIV
0038 900000      R     MOV     DPTR,#tmpValue
003B 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 513
003E 900000      R     MOV     DPTR,#tmpValue
0041 E0                MOVX    A,@DPTR
0042 FC                MOV     R4,A
0043 A3                INC     DPTR
0044 E0                MOVX    A,@DPTR
0045 FD                MOV     R5,A
0046 A3                INC     DPTR
0047 E0                MOVX    A,@DPTR
0048 FE                MOV     R6,A
0049 A3                INC     DPTR
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
004C 900000      R     MOV     DPTR,#gainAdjust
004F E0                MOVX    A,@DPTR
0050 F8                MOV     R0,A
0051 A3                INC     DPTR
0052 E0                MOVX    A,@DPTR
0053 F9                MOV     R1,A
0054 A3                INC     DPTR
0055 E0                MOVX    A,@DPTR
0056 FA                MOV     R2,A
0057 A3                INC     DPTR
0058 E0                MOVX    A,@DPTR
0059 FB                MOV     R3,A
005A 120000      E     LCALL   ?C?FPMUL
005D 900000      R     MOV     DPTR,#tmpValue
0060 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 515
0063 7FB9              MOV     R7,#0B9H
0065 7EFC              MOV     R6,#0FCH
0067 7DFF              MOV     R5,#0FFH
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 39  

0069 7C3F              MOV     R4,#03FH
006B 900000      R     MOV     DPTR,#tmpValue
006E E0                MOVX    A,@DPTR
006F F8                MOV     R0,A
0070 A3                INC     DPTR
0071 E0                MOVX    A,@DPTR
0072 F9                MOV     R1,A
0073 A3                INC     DPTR
0074 E0                MOVX    A,@DPTR
0075 FA                MOV     R2,A
0076 A3                INC     DPTR
0077 E0                MOVX    A,@DPTR
0078 FB                MOV     R3,A
0079 120000      E     LCALL   ?C?FPCMP3
007C 600A              JZ      ?C0010
007E 4008              JC      ?C0010
                                           ; SOURCE LINE # 516
                                           ; SOURCE LINE # 517
0080 900000      R     MOV     DPTR,#status
0083 7401              MOV     A,#01H
0085 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 518
0086 8064              SJMP    ?C0011
0088         ?C0010:
                                           ; SOURCE LINE # 520
                                           ; SOURCE LINE # 521
0088 900000      R     MOV     DPTR,#tmpValue
008B E0                MOVX    A,@DPTR
008C FC                MOV     R4,A
008D A3                INC     DPTR
008E E0                MOVX    A,@DPTR
008F FD                MOV     R5,A
0090 A3                INC     DPTR
0091 E0                MOVX    A,@DPTR
0092 FE                MOV     R6,A
0093 A3                INC     DPTR
0094 E0                MOVX    A,@DPTR
0095 FF                MOV     R7,A
0096 E4                CLR     A
0097 FB                MOV     R3,A
0098 FA                MOV     R2,A
0099 F9                MOV     R1,A
009A 7847              MOV     R0,#047H
009C 120000      E     LCALL   ?C?FPMUL
009F 900000      R     MOV     DPTR,#tmpValue
00A2 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 522
00A5 900000      R     MOV     DPTR,#tmpValue
00A8 E0                MOVX    A,@DPTR
00A9 FC                MOV     R4,A
00AA A3                INC     DPTR
00AB E0                MOVX    A,@DPTR
00AC FD                MOV     R5,A
00AD A3                INC     DPTR
00AE E0                MOVX    A,@DPTR
00AF FE                MOV     R6,A
00B0 A3                INC     DPTR
00B1 E0                MOVX    A,@DPTR
00B2 FF                MOV     R7,A
00B3 120000      E     LCALL   ?C?CASTF
00B6 900000      R     MOV     DPTR,#tmpReg
00B9 EE                MOV     A,R6
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 40  

00BA F0                MOVX    @DPTR,A
00BB FC                MOV     R4,A
00BC A3                INC     DPTR
00BD EF                MOV     A,R7
00BE F0                MOVX    @DPTR,A
00BF FD                MOV     R5,A
                                           ; SOURCE LINE # 523
00C0 7B02              MOV     R3,#02H
00C2 7A4E              MOV     R2,#04EH
00C4 790C              MOV     R1,#0CH
00C6 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 525
00C9 900000      R     MOV     DPTR,#tmpReg
00CC E0                MOVX    A,@DPTR
00CD FE                MOV     R6,A
00CE A3                INC     DPTR
00CF E0                MOVX    A,@DPTR
00D0 FF                MOV     R7,A
00D1 900000      R     MOV     DPTR,#ADC_Config
00D4 E0                MOVX    A,@DPTR
00D5 75F003            MOV     B,#03H
00D8 A4                MUL     AB
00D9 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
00DB F582              MOV     DPL,A
00DD E4                CLR     A
00DE 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
00E0 F583              MOV     DPH,A
00E2 EE                MOV     A,R6
00E3 F0                MOVX    @DPTR,A
00E4 A3                INC     DPTR
00E5 EF                MOV     A,R7
00E6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 527
00E7 E4                CLR     A
00E8 900000      R     MOV     DPTR,#status
00EB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 529
00EC         ?C0011:
                                           ; SOURCE LINE # 530
00EC 900000      R     MOV     DPTR,#status
00EF E0                MOVX    A,@DPTR
00F0 FF                MOV     R7,A
                                           ; SOURCE LINE # 531
00F1         ?C0012:
00F1 22                RET     
             ; FUNCTION _ADC_SetGCOR (END)

             ; FUNCTION ADC_ReadGCOR (BEGIN)
                                           ; SOURCE LINE # 552
                                           ; SOURCE LINE # 553
                                           ; SOURCE LINE # 557
0000 904E0E            MOV     DPTR,#04E0EH
0003 E0                MOVX    A,@DPTR
0004 900000      R     MOV     DPTR,#gValue
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 558
0008 7B02              MOV     R3,#02H
000A 7A4E              MOV     R2,#04EH
000C 790C              MOV     R1,#0CH
000E 120000      E     LCALL   _cyread16_nodpx
;---- Variable 'gcorValue' assigned to Register 'R4/R5' ----
0011 AD07              MOV     R5,AR7
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 41  

0013 AC06              MOV     R4,AR6
                                           ; SOURCE LINE # 560
0015 900000      R     MOV     DPTR,#gValue
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A C3                CLR     C
001B 940F              SUBB    A,#0FH
001D 5015              JNC     ?C0013
                                           ; SOURCE LINE # 561
                                           ; SOURCE LINE # 562
001F C3                CLR     C
0020 740F              MOV     A,#0FH
0022 9F                SUBB    A,R7
0023 FF                MOV     R7,A
0024 ED                MOV     A,R5
0025 A807              MOV     R0,AR7
0027 08                INC     R0
0028 8005              SJMP    ?C0091
002A         ?C0090:
002A C3                CLR     C
002B 33                RLC     A
002C CE                XCH     A,R6
002D 33                RLC     A
002E CE                XCH     A,R6
002F         ?C0091:
002F D8F9              DJNZ    R0,?C0090
0031 FD                MOV     R5,A
0032 AC06              MOV     R4,AR6
                                           ; SOURCE LINE # 563
0034         ?C0013:
                                           ; SOURCE LINE # 565
0034 AE04              MOV     R6,AR4
0036 AF05              MOV     R7,AR5
                                           ; SOURCE LINE # 566
0038         ?C0014:
0038 22                RET     
             ; FUNCTION ADC_ReadGCOR (END)

             ; FUNCTION ADC_StartConvert (BEGIN)
                                           ; SOURCE LINE # 586
                                           ; SOURCE LINE # 587
                                           ; SOURCE LINE # 589
0000 904E00            MOV     DPTR,#04E00H
0003 E0                MOVX    A,@DPTR
0004 4401              ORL     A,#01H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 590
0007 22                RET     
             ; FUNCTION ADC_StartConvert (END)

             ; FUNCTION ADC_StopConvert (BEGIN)
                                           ; SOURCE LINE # 609
                                           ; SOURCE LINE # 610
                                           ; SOURCE LINE # 612
0000 904E00            MOV     DPTR,#04E00H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 613
0007 22                RET     
             ; FUNCTION ADC_StopConvert (END)

C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 42  

             ; FUNCTION _ADC_IsEndConversion (BEGIN)
                                           ; SOURCE LINE # 644
;---- Variable 'status' assigned to Register 'R6' ----
;---- Variable 'retMode' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 645
0000         ?C0019:
                                           ; SOURCE LINE # 649
                                           ; SOURCE LINE # 653
0000 900000      R     MOV     DPTR,#ADC_stopConversion
0003 E0                MOVX    A,@DPTR
0004 6007              JZ      ?C0020
                                           ; SOURCE LINE # 654
                                           ; SOURCE LINE # 655
0006 900000      R     MOV     DPTR,#ADC_convDone
0009 E0                MOVX    A,@DPTR
000A FE                MOV     R6,A
                                           ; SOURCE LINE # 656
000B 8007              SJMP    ?C0017
000D         ?C0020:
                                           ; SOURCE LINE # 658
                                           ; SOURCE LINE # 659
000D 904E01            MOV     DPTR,#04E01H
0010 E0                MOVX    A,@DPTR
0011 5401              ANL     A,#01H
0013 FE                MOV     R6,A
                                           ; SOURCE LINE # 660
                                           ; SOURCE LINE # 661
0014         ?C0017:
0014 EE                MOV     A,R6
0015 6401              XRL     A,#01H
0017 6003              JZ      ?C0018
0019 EF                MOV     A,R7
001A 60E4              JZ      ?C0019
001C         ?C0018:
                                           ; SOURCE LINE # 663
001C AF06              MOV     R7,AR6
                                           ; SOURCE LINE # 664
001E         ?C0023:
001E 22                RET     
             ; FUNCTION _ADC_IsEndConversion (END)

             ; FUNCTION ADC_GetResult8 (BEGIN)
                                           ; SOURCE LINE # 691
                                           ; SOURCE LINE # 692
                                           ; SOURCE LINE # 697
0000 904E14            MOV     DPTR,#04E14H
0003 E0                MOVX    A,@DPTR
0004 5403              ANL     A,#03H
0006 FF                MOV     R7,A
;---- Variable 'coherency' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 699
0007 904E10            MOV     DPTR,#04E10H
000A E0                MOVX    A,@DPTR
000B FE                MOV     R6,A
;---- Variable 'result' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 701
000C EF                MOV     A,R7
000D B40205            CJNE    A,#02H,?C0024
                                           ; SOURCE LINE # 702
                                           ; SOURCE LINE # 703
0010 A3                INC     DPTR
0011 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 43  

0012 FD                MOV     R5,A
                                           ; SOURCE LINE # 704
0013 8009              SJMP    ?C0025
0015         ?C0024:
                                           ; SOURCE LINE # 705
0015 EF                MOV     A,R7
0016 B40305            CJNE    A,#03H,?C0025
                                           ; SOURCE LINE # 706
                                           ; SOURCE LINE # 707
0019 904E12            MOV     DPTR,#04E12H
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
                                           ; SOURCE LINE # 708
                                           ; SOURCE LINE # 710
                                           ; SOURCE LINE # 711
001E         ?C0025:
                                           ; SOURCE LINE # 713
001E 900000      R     MOV     DPTR,#ADC_stopConversion
0021 E0                MOVX    A,@DPTR
0022 6005              JZ      ?C0028
                                           ; SOURCE LINE # 714
                                           ; SOURCE LINE # 715
0024 E4                CLR     A
0025 900000      R     MOV     DPTR,#ADC_convDone
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 716
0029         ?C0028:
                                           ; SOURCE LINE # 717
0029 AF06              MOV     R7,AR6
                                           ; SOURCE LINE # 718
002B         ?C0029:
002B 22                RET     
             ; FUNCTION ADC_GetResult8 (END)

             ; FUNCTION ADC_GetResult16 (BEGIN)
                                           ; SOURCE LINE # 745
                                           ; SOURCE LINE # 746
                                           ; SOURCE LINE # 751
0000 904E14            MOV     DPTR,#04E14H
0003 E0                MOVX    A,@DPTR
0004 5403              ANL     A,#03H
0006 900000      R     MOV     DPTR,#coherency
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 753
000A E0                MOVX    A,@DPTR
000B D3                SETB    C
000C 9401              SUBB    A,#01H
000E 5021              JNC     ?C0030
                                           ; SOURCE LINE # 754
                                           ; SOURCE LINE # 756
0010 904E11            MOV     DPTR,#04E11H
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 900000      R     MOV     DPTR,#result
0018 E4                CLR     A
0019 F0                MOVX    @DPTR,A
001A A3                INC     DPTR
001B EF                MOV     A,R7
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 757
001D E0                MOVX    A,@DPTR
001E FE                MOV     R6,A
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 44  

001F 904E10            MOV     DPTR,#04E10H
0022 E0                MOVX    A,@DPTR
0023 FD                MOV     R5,A
0024 EE                MOV     A,R6
0025 ED                MOV     A,R5
0026 FF                MOV     R7,A
0027 900000      R     MOV     DPTR,#result
002A EE                MOV     A,R6
002B F0                MOVX    @DPTR,A
002C A3                INC     DPTR
002D EF                MOV     A,R7
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 761
002F 801B              SJMP    ?C0031
0031         ?C0030:
                                           ; SOURCE LINE # 763
                                           ; SOURCE LINE # 765
0031 7B02              MOV     R3,#02H
0033 7A4E              MOV     R2,#04EH
0035 7910              MOV     R1,#010H
0037 120000      E     LCALL   _cyread16_nodpx
003A 900000      R     MOV     DPTR,#result
003D EE                MOV     A,R6
003E F0                MOVX    @DPTR,A
003F A3                INC     DPTR
0040 EF                MOV     A,R7
0041 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 770
0042 A3                INC     DPTR
0043 E0                MOVX    A,@DPTR
0044 B40305            CJNE    A,#03H,?C0031
                                           ; SOURCE LINE # 771
                                           ; SOURCE LINE # 772
0047 904E12            MOV     DPTR,#04E12H
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
                                           ; SOURCE LINE # 773
                                           ; SOURCE LINE # 774
004C         ?C0031:
                                           ; SOURCE LINE # 776
004C 900000      R     MOV     DPTR,#ADC_stopConversion
004F E0                MOVX    A,@DPTR
0050 6005              JZ      ?C0033
                                           ; SOURCE LINE # 777
                                           ; SOURCE LINE # 778
0052 E4                CLR     A
0053 900000      R     MOV     DPTR,#ADC_convDone
0056 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 779
0057         ?C0033:
                                           ; SOURCE LINE # 781
0057 900000      R     MOV     DPTR,#result
005A E0                MOVX    A,@DPTR
005B FE                MOV     R6,A
005C A3                INC     DPTR
005D E0                MOVX    A,@DPTR
005E FF                MOV     R7,A
                                           ; SOURCE LINE # 782
005F         ?C0034:
005F 22                RET     
             ; FUNCTION ADC_GetResult16 (END)

C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 45  

             ; FUNCTION ADC_GetResult32 (BEGIN)
                                           ; SOURCE LINE # 805
                                           ; SOURCE LINE # 806
                                           ; SOURCE LINE # 814
0000 904E14            MOV     DPTR,#04E14H
0003 E0                MOVX    A,@DPTR
0004 5403              ANL     A,#03H
0006 900000      R     MOV     DPTR,#coherency
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 816
000A E0                MOVX    A,@DPTR
000B D3                SETB    C
000C 9401              SUBB    A,#01H
000E 4003              JC      $ + 5H
0010 020000      R     LJMP    ?C0035
                                           ; SOURCE LINE # 817
                                           ; SOURCE LINE # 819
0013 904E12            MOV     DPTR,#04E12H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 E4                CLR     A
0019 FC                MOV     R4,A
001A FD                MOV     R5,A
001B FE                MOV     R6,A
001C 900000      R     MOV     DPTR,#result
001F 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 820
0022 900000      R     MOV     DPTR,#result
0025 E0                MOVX    A,@DPTR
0026 FC                MOV     R4,A
0027 A3                INC     DPTR
0028 E0                MOVX    A,@DPTR
0029 FD                MOV     R5,A
002A A3                INC     DPTR
002B E0                MOVX    A,@DPTR
002C FE                MOV     R6,A
002D A3                INC     DPTR
002E E0                MOVX    A,@DPTR
002F 5480              ANL     A,#080H
0031 FF                MOV     R7,A
0032 E4                CLR     A
0033 EF                MOV     A,R7
0034 6016              JZ      ?C0036
                                           ; SOURCE LINE # 821
                                           ; SOURCE LINE # 822
0036 900000      R     MOV     DPTR,#result
0039 E0                MOVX    A,@DPTR
003A A3                INC     DPTR
003B E0                MOVX    A,@DPTR
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 74FF              MOV     A,#0FFH
0043 FE                MOV     R6,A
0044 ED                MOV     A,R5
0045 EC                MOV     A,R4
0046 900000      R     MOV     DPTR,#result
0049 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 823
004C         ?C0036:
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 46  

                                           ; SOURCE LINE # 824
004C 900000      R     MOV     DPTR,#result
004F E0                MOVX    A,@DPTR
0050 FC                MOV     R4,A
0051 A3                INC     DPTR
0052 E0                MOVX    A,@DPTR
0053 FD                MOV     R5,A
0054 A3                INC     DPTR
0055 E0                MOVX    A,@DPTR
0056 FE                MOV     R6,A
0057 A3                INC     DPTR
0058 E0                MOVX    A,@DPTR
0059 FF                MOV     R7,A
005A 7808              MOV     R0,#08H
005C 120000      E     LCALL   ?C?LSHL
005F A804              MOV     R0,AR4
0061 A905              MOV     R1,AR5
0063 AA06              MOV     R2,AR6
0065 AB07              MOV     R3,AR7
0067 904E11            MOV     DPTR,#04E11H
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C E4                CLR     A
006D EB                MOV     A,R3
006E 4F                ORL     A,R7
006F FF                MOV     R7,A
0070 EA                MOV     A,R2
0071 FE                MOV     R6,A
0072 E9                MOV     A,R1
0073 FD                MOV     R5,A
0074 E8                MOV     A,R0
0075 FC                MOV     R4,A
0076 900000      R     MOV     DPTR,#result
0079 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 825
007C 900000      R     MOV     DPTR,#result
007F E0                MOVX    A,@DPTR
0080 FC                MOV     R4,A
0081 A3                INC     DPTR
0082 E0                MOVX    A,@DPTR
0083 FD                MOV     R5,A
0084 A3                INC     DPTR
0085 E0                MOVX    A,@DPTR
0086 FE                MOV     R6,A
0087 A3                INC     DPTR
0088 E0                MOVX    A,@DPTR
0089 FF                MOV     R7,A
008A 7808              MOV     R0,#08H
008C 120000      E     LCALL   ?C?LSHL
008F A804              MOV     R0,AR4
0091 A905              MOV     R1,AR5
0093 AA06              MOV     R2,AR6
0095 AB07              MOV     R3,AR7
0097 904E10            MOV     DPTR,#04E10H
009A E0                MOVX    A,@DPTR
009B FF                MOV     R7,A
009C E4                CLR     A
009D EB                MOV     A,R3
009E 4F                ORL     A,R7
009F FF                MOV     R7,A
00A0 EA                MOV     A,R2
00A1 FE                MOV     R6,A
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 47  

00A2 E9                MOV     A,R1
00A3 FD                MOV     R5,A
00A4 E8                MOV     A,R0
00A5 FC                MOV     R4,A
00A6 900000      R     MOV     DPTR,#result
00A9 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 830
00AC 020000      R     LJMP    ?C0037
00AF         ?C0035:
                                           ; SOURCE LINE # 831
00AF 900000      R     MOV     DPTR,#coherency
00B2 E0                MOVX    A,@DPTR
00B3 6402              XRL     A,#02H
00B5 707C              JNZ     ?C0038
                                           ; SOURCE LINE # 832
                                           ; SOURCE LINE # 834
00B7 904E12            MOV     DPTR,#04E12H
00BA E0                MOVX    A,@DPTR
00BB FF                MOV     R7,A
00BC E4                CLR     A
00BD FC                MOV     R4,A
00BE FD                MOV     R5,A
00BF FE                MOV     R6,A
00C0 900000      R     MOV     DPTR,#result
00C3 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 835
00C6 900000      R     MOV     DPTR,#result
00C9 E0                MOVX    A,@DPTR
00CA FC                MOV     R4,A
00CB A3                INC     DPTR
00CC E0                MOVX    A,@DPTR
00CD FD                MOV     R5,A
00CE A3                INC     DPTR
00CF E0                MOVX    A,@DPTR
00D0 FE                MOV     R6,A
00D1 A3                INC     DPTR
00D2 E0                MOVX    A,@DPTR
00D3 5480              ANL     A,#080H
00D5 FF                MOV     R7,A
00D6 E4                CLR     A
00D7 EF                MOV     A,R7
00D8 6016              JZ      ?C0039
                                           ; SOURCE LINE # 836
                                           ; SOURCE LINE # 837
00DA 900000      R     MOV     DPTR,#result
00DD E0                MOVX    A,@DPTR
00DE A3                INC     DPTR
00DF E0                MOVX    A,@DPTR
00E0 A3                INC     DPTR
00E1 E0                MOVX    A,@DPTR
00E2 A3                INC     DPTR
00E3 E0                MOVX    A,@DPTR
00E4 FF                MOV     R7,A
00E5 74FF              MOV     A,#0FFH
00E7 FE                MOV     R6,A
00E8 ED                MOV     A,R5
00E9 EC                MOV     A,R4
00EA 900000      R     MOV     DPTR,#result
00ED 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 838
00F0         ?C0039:
                                           ; SOURCE LINE # 839
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 48  

00F0 7B02              MOV     R3,#02H
00F2 7A4E              MOV     R2,#04EH
00F4 7910              MOV     R1,#010H
00F6 120000      E     LCALL   _cyread16_nodpx
00F9 E4                CLR     A
00FA FC                MOV     R4,A
00FB FD                MOV     R5,A
00FC C004              PUSH    AR4
00FE C005              PUSH    AR5
0100 C006              PUSH    AR6
0102 C007              PUSH    AR7
0104 900000      R     MOV     DPTR,#result
0107 E0                MOVX    A,@DPTR
0108 FC                MOV     R4,A
0109 A3                INC     DPTR
010A E0                MOVX    A,@DPTR
010B FD                MOV     R5,A
010C A3                INC     DPTR
010D E0                MOVX    A,@DPTR
010E FE                MOV     R6,A
010F A3                INC     DPTR
0110 E0                MOVX    A,@DPTR
0111 FF                MOV     R7,A
0112 7810              MOV     R0,#010H
0114 120000      E     LCALL   ?C?LSHL
0117 D003              POP     AR3
0119 D002              POP     AR2
011B D001              POP     AR1
011D D000              POP     AR0
011F EF                MOV     A,R7
0120 4B                ORL     A,R3
0121 FF                MOV     R7,A
0122 EE                MOV     A,R6
0123 4A                ORL     A,R2
0124 FE                MOV     R6,A
0125 ED                MOV     A,R5
0126 49                ORL     A,R1
0127 FD                MOV     R5,A
0128 EC                MOV     A,R4
0129 48                ORL     A,R0
012A FC                MOV     R4,A
012B 900000      R     MOV     DPTR,#result
012E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 845
0131 8067              SJMP    ?C0037
0133         ?C0038:
                                           ; SOURCE LINE # 847
                                           ; SOURCE LINE # 850
0133 7B02              MOV     R3,#02H
0135 7A4E              MOV     R2,#04EH
0137 7910              MOV     R1,#010H
0139 120000      E     LCALL   _cyread16_nodpx
013C E4                CLR     A
013D FC                MOV     R4,A
013E FD                MOV     R5,A
013F 900000      R     MOV     DPTR,#result
0142 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 851
0145 904E12            MOV     DPTR,#04E12H
0148 E0                MOVX    A,@DPTR
0149 FF                MOV     R7,A
014A 900000      R     MOV     DPTR,#tmp
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 49  

014D E4                CLR     A
014E F0                MOVX    @DPTR,A
014F A3                INC     DPTR
0150 EF                MOV     A,R7
0151 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 852
0152 900000      R     MOV     DPTR,#tmp
0155 E0                MOVX    A,@DPTR
0156 FE                MOV     R6,A
0157 A3                INC     DPTR
0158 E0                MOVX    A,@DPTR
0159 FF                MOV     R7,A
015A 30E709            JNB     ACC.7,?C0041
                                           ; SOURCE LINE # 853
                                           ; SOURCE LINE # 854
015D 900000      R     MOV     DPTR,#tmp
0160 74FF              MOV     A,#0FFH
0162 F0                MOVX    @DPTR,A
0163 A3                INC     DPTR
0164 EF                MOV     A,R7
0165 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 855
0166         ?C0041:
                                           ; SOURCE LINE # 856
0166 900000      R     MOV     DPTR,#result
0169 E0                MOVX    A,@DPTR
016A F8                MOV     R0,A
016B A3                INC     DPTR
016C E0                MOVX    A,@DPTR
016D F9                MOV     R1,A
016E A3                INC     DPTR
016F E0                MOVX    A,@DPTR
0170 FA                MOV     R2,A
0171 A3                INC     DPTR
0172 E0                MOVX    A,@DPTR
0173 FB                MOV     R3,A
0174 C000              PUSH    AR0
0176 900000      R     MOV     DPTR,#tmp
0179 E0                MOVX    A,@DPTR
017A FE                MOV     R6,A
017B A3                INC     DPTR
017C E0                MOVX    A,@DPTR
017D FF                MOV     R7,A
017E E4                CLR     A
017F FC                MOV     R4,A
0180 FD                MOV     R5,A
0181 7810              MOV     R0,#010H
0183 120000      E     LCALL   ?C?LSHL
0186 D000              POP     AR0
0188 EB                MOV     A,R3
0189 4F                ORL     A,R7
018A FF                MOV     R7,A
018B EA                MOV     A,R2
018C 4E                ORL     A,R6
018D FE                MOV     R6,A
018E E9                MOV     A,R1
018F 4D                ORL     A,R5
0190 FD                MOV     R5,A
0191 E8                MOV     A,R0
0192 4C                ORL     A,R4
0193 FC                MOV     R4,A
0194 900000      R     MOV     DPTR,#result
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 50  

0197 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 861
019A         ?C0037:
                                           ; SOURCE LINE # 863
019A 900000      R     MOV     DPTR,#ADC_stopConversion
019D E0                MOVX    A,@DPTR
019E 6005              JZ      ?C0042
                                           ; SOURCE LINE # 864
                                           ; SOURCE LINE # 865
01A0 E4                CLR     A
01A1 900000      R     MOV     DPTR,#ADC_convDone
01A4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 866
01A5         ?C0042:
                                           ; SOURCE LINE # 868
01A5 900000      R     MOV     DPTR,#result
01A8 E0                MOVX    A,@DPTR
01A9 FC                MOV     R4,A
01AA A3                INC     DPTR
01AB E0                MOVX    A,@DPTR
01AC FD                MOV     R5,A
01AD A3                INC     DPTR
01AE E0                MOVX    A,@DPTR
01AF FE                MOV     R6,A
01B0 A3                INC     DPTR
01B1 E0                MOVX    A,@DPTR
01B2 FF                MOV     R7,A
                                           ; SOURCE LINE # 869
01B3         ?C0043:
01B3 22                RET     
             ; FUNCTION ADC_GetResult32 (END)

             ; FUNCTION _ADC_SetOffset (BEGIN)
                                           ; SOURCE LINE # 898
;---- Variable 'offset' assigned to Register 'R4/R5/R6/R7' ----
                                           ; SOURCE LINE # 899
                                           ; SOURCE LINE # 901
0000 900000      R     MOV     DPTR,#ADC_Offset
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 902
0006 22                RET     
             ; FUNCTION _ADC_SetOffset (END)

             ; FUNCTION _ADC_SetGain (BEGIN)
                                           ; SOURCE LINE # 933
;---- Variable 'adcGain' assigned to Register 'R4/R5/R6/R7' ----
                                           ; SOURCE LINE # 934
                                           ; SOURCE LINE # 935
0000 900000      R     MOV     DPTR,#ADC_CountsPerVolt
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 936
0006 22                RET     
             ; FUNCTION _ADC_SetGain (END)

             ; FUNCTION _ADC_CountsTo_mVolts (BEGIN)
                                           ; SOURCE LINE # 960
0000 900000      R     MOV     DPTR,#adcCounts
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 961
                                           ; SOURCE LINE # 992
0006 900000      R     MOV     DPTR,#adcCounts
0009 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 51  

000A FC                MOV     R4,A
000B A3                INC     DPTR
000C E0                MOVX    A,@DPTR
000D FD                MOV     R5,A
000E A3                INC     DPTR
000F E0                MOVX    A,@DPTR
0010 FE                MOV     R6,A
0011 A3                INC     DPTR
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 900000      R     MOV     DPTR,#ADC_Offset
0017 E0                MOVX    A,@DPTR
0018 F8                MOV     R0,A
0019 A3                INC     DPTR
001A E0                MOVX    A,@DPTR
001B F9                MOV     R1,A
001C A3                INC     DPTR
001D E0                MOVX    A,@DPTR
001E FA                MOV     R2,A
001F A3                INC     DPTR
0020 E0                MOVX    A,@DPTR
0021 FB                MOV     R3,A
0022 C3                CLR     C
0023 EF                MOV     A,R7
0024 9B                SUBB    A,R3
0025 FF                MOV     R7,A
0026 EE                MOV     A,R6
0027 9A                SUBB    A,R2
0028 FE                MOV     R6,A
0029 ED                MOV     A,R5
002A 99                SUBB    A,R1
002B FD                MOV     R5,A
002C EC                MOV     A,R4
002D 98                SUBB    A,R0
002E FC                MOV     R4,A
002F 900000      R     MOV     DPTR,#adcCounts
0032 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 994
0035 E4                CLR     A
0036 7FE8              MOV     R7,#0E8H
0038 7E03              MOV     R6,#03H
003A FD                MOV     R5,A
003B FC                MOV     R4,A
003C 900000      R     MOV     DPTR,#adcCounts
003F E0                MOVX    A,@DPTR
0040 F8                MOV     R0,A
0041 A3                INC     DPTR
0042 E0                MOVX    A,@DPTR
0043 F9                MOV     R1,A
0044 A3                INC     DPTR
0045 E0                MOVX    A,@DPTR
0046 FA                MOV     R2,A
0047 A3                INC     DPTR
0048 E0                MOVX    A,@DPTR
0049 FB                MOV     R3,A
004A 120000      E     LCALL   ?C?LMUL
004D 900000      R     MOV     DPTR,#ADC_CountsPerVolt
0050 E0                MOVX    A,@DPTR
0051 F8                MOV     R0,A
0052 A3                INC     DPTR
0053 E0                MOVX    A,@DPTR
0054 F9                MOV     R1,A
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 52  

0055 A3                INC     DPTR
0056 E0                MOVX    A,@DPTR
0057 FA                MOV     R2,A
0058 A3                INC     DPTR
0059 E0                MOVX    A,@DPTR
005A FB                MOV     R3,A
005B 120000      E     LCALL   ?C?SLDIV
;---- Variable 'mVolts' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 996
                                           ; SOURCE LINE # 997
005E         ?C0046:
005E 22                RET     
             ; FUNCTION _ADC_CountsTo_mVolts (END)

             ; FUNCTION _ADC_CountsTo_Volts (BEGIN)
                                           ; SOURCE LINE # 1021
0000 900000      R     MOV     DPTR,#adcCounts
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1022
                                           ; SOURCE LINE # 1053
0006 900000      R     MOV     DPTR,#adcCounts
0009 E0                MOVX    A,@DPTR
000A FC                MOV     R4,A
000B A3                INC     DPTR
000C E0                MOVX    A,@DPTR
000D FD                MOV     R5,A
000E A3                INC     DPTR
000F E0                MOVX    A,@DPTR
0010 FE                MOV     R6,A
0011 A3                INC     DPTR
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 900000      R     MOV     DPTR,#ADC_Offset
0017 E0                MOVX    A,@DPTR
0018 F8                MOV     R0,A
0019 A3                INC     DPTR
001A E0                MOVX    A,@DPTR
001B F9                MOV     R1,A
001C A3                INC     DPTR
001D E0                MOVX    A,@DPTR
001E FA                MOV     R2,A
001F A3                INC     DPTR
0020 E0                MOVX    A,@DPTR
0021 FB                MOV     R3,A
0022 C3                CLR     C
0023 EF                MOV     A,R7
0024 9B                SUBB    A,R3
0025 FF                MOV     R7,A
0026 EE                MOV     A,R6
0027 9A                SUBB    A,R2
0028 FE                MOV     R6,A
0029 ED                MOV     A,R5
002A 99                SUBB    A,R1
002B FD                MOV     R5,A
002C EC                MOV     A,R4
002D 98                SUBB    A,R0
002E FC                MOV     R4,A
002F 900000      R     MOV     DPTR,#adcCounts
0032 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1055
0035 900000      R     MOV     DPTR,#ADC_CountsPerVolt
0038 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 53  

0039 FC                MOV     R4,A
003A A3                INC     DPTR
003B E0                MOVX    A,@DPTR
003C FD                MOV     R5,A
003D A3                INC     DPTR
003E E0                MOVX    A,@DPTR
003F FE                MOV     R6,A
0040 A3                INC     DPTR
0041 E0                MOVX    A,@DPTR
0042 FF                MOV     R7,A
0043 EC                MOV     A,R4
0044 120000      E     LCALL   ?C?FCASTL
0047 C004              PUSH    AR4
0049 C005              PUSH    AR5
004B C006              PUSH    AR6
004D C007              PUSH    AR7
004F 900000      R     MOV     DPTR,#adcCounts
0052 E0                MOVX    A,@DPTR
0053 FC                MOV     R4,A
0054 A3                INC     DPTR
0055 E0                MOVX    A,@DPTR
0056 FD                MOV     R5,A
0057 A3                INC     DPTR
0058 E0                MOVX    A,@DPTR
0059 FE                MOV     R6,A
005A A3                INC     DPTR
005B E0                MOVX    A,@DPTR
005C FF                MOV     R7,A
005D EC                MOV     A,R4
005E 120000      E     LCALL   ?C?FCASTL
0061 D003              POP     AR3
0063 D002              POP     AR2
0065 D001              POP     AR1
0067 D000              POP     AR0
0069 120000      E     LCALL   ?C?FPDIV
;---- Variable 'Volts' assigned to Register 'R4/R5/R6/R7' ----
                                           ; SOURCE LINE # 1057
                                           ; SOURCE LINE # 1058
006C         ?C0047:
006C 22                RET     
             ; FUNCTION _ADC_CountsTo_Volts (END)

             ; FUNCTION _ADC_CountsTo_uVolts (BEGIN)
                                           ; SOURCE LINE # 1087
0000 900000      R     MOV     DPTR,#adcCounts
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1088
                                           ; SOURCE LINE # 1097
0006 900000      R     MOV     DPTR,#ADC_Config
0009 E0                MOVX    A,@DPTR
000A B40108            CJNE    A,#01H,?C0048
                                           ; SOURCE LINE # 1098
                                           ; SOURCE LINE # 1099
000D 900000      R     MOV     DPTR,#resolution
0010 740C              MOV     A,#0CH
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1103
0013 8024              SJMP    ?C0049
0015         ?C0048:
                                           ; SOURCE LINE # 1104
0015 900000      R     MOV     DPTR,#ADC_Config
0018 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 54  

0019 B40208            CJNE    A,#02H,?C0050
                                           ; SOURCE LINE # 1105
                                           ; SOURCE LINE # 1106
001C 900000      R     MOV     DPTR,#resolution
001F 7410              MOV     A,#010H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1110
0022 8015              SJMP    ?C0049
0024         ?C0050:
                                           ; SOURCE LINE # 1111
0024 900000      R     MOV     DPTR,#ADC_Config
0027 E0                MOVX    A,@DPTR
0028 B40308            CJNE    A,#03H,?C0052
                                           ; SOURCE LINE # 1112
                                           ; SOURCE LINE # 1113
002B 900000      R     MOV     DPTR,#resolution
002E 7410              MOV     A,#010H
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1117
0031 8006              SJMP    ?C0049
0033         ?C0052:
                                           ; SOURCE LINE # 1119
                                           ; SOURCE LINE # 1120
0033 900000      R     MOV     DPTR,#resolution
0036 7410              MOV     A,#010H
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1124
0039         ?C0049:
                                           ; SOURCE LINE # 1126
0039 900000      R     MOV     DPTR,#resolution
003C E0                MOVX    A,@DPTR
003D 24F0              ADD     A,#0F0H
003F 6020              JZ      ?C0056
0041 2404              ADD     A,#04H
0043 7037              JNZ     ?C0057
                                           ; SOURCE LINE # 1127
                                           ; SOURCE LINE # 1132
0045         ?C0055:
                                           ; SOURCE LINE # 1133
0045 7F20              MOV     R7,#020H
0047 7EA1              MOV     R6,#0A1H
0049 7D07              MOV     R5,#07H
004B 7C00              MOV     R4,#00H
004D 900000      R     MOV     DPTR,#coefA
0050 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1134
0053 E4                CLR     A
0054 7F02              MOV     R7,#02H
0056 FE                MOV     R6,A
0057 FD                MOV     R5,A
0058 FC                MOV     R4,A
0059 900000      R     MOV     DPTR,#coefB
005C 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1135
005F 8035              SJMP    ?C0054
                                           ; SOURCE LINE # 1168
0061         ?C0056:
                                           ; SOURCE LINE # 1169
0061 E4                CLR     A
0062 7F12              MOV     R7,#012H
0064 7E7A              MOV     R6,#07AH
0066 FD                MOV     R5,A
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 55  

0067 FC                MOV     R4,A
0068 900000      R     MOV     DPTR,#coefA
006B 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1170
006E E4                CLR     A
006F 7F20              MOV     R7,#020H
0071 FE                MOV     R6,A
0072 FD                MOV     R5,A
0073 FC                MOV     R4,A
0074 900000      R     MOV     DPTR,#coefB
0077 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1171
007A 801A              SJMP    ?C0054
                                           ; SOURCE LINE # 1209
007C         ?C0057:
                                           ; SOURCE LINE # 1211
007C 7F40              MOV     R7,#040H
007E 7E42              MOV     R6,#042H
0080 7D0F              MOV     R5,#0FH
0082 7C00              MOV     R4,#00H
0084 900000      R     MOV     DPTR,#coefA
0087 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1212
008A E4                CLR     A
008B 7F01              MOV     R7,#01H
008D FE                MOV     R6,A
008E FD                MOV     R5,A
008F FC                MOV     R4,A
0090 900000      R     MOV     DPTR,#coefB
0093 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1213
                                           ; SOURCE LINE # 1214
0096         ?C0054:
                                           ; SOURCE LINE # 1215
0096 900000      R     MOV     DPTR,#coefB
0099 E0                MOVX    A,@DPTR
009A F8                MOV     R0,A
009B A3                INC     DPTR
009C E0                MOVX    A,@DPTR
009D F9                MOV     R1,A
009E A3                INC     DPTR
009F E0                MOVX    A,@DPTR
00A0 FA                MOV     R2,A
00A1 A3                INC     DPTR
00A2 E0                MOVX    A,@DPTR
00A3 FB                MOV     R3,A
00A4 900000      R     MOV     DPTR,#ADC_CountsPerVolt
00A7 E0                MOVX    A,@DPTR
00A8 FC                MOV     R4,A
00A9 A3                INC     DPTR
00AA E0                MOVX    A,@DPTR
00AB FD                MOV     R5,A
00AC A3                INC     DPTR
00AD E0                MOVX    A,@DPTR
00AE FE                MOV     R6,A
00AF A3                INC     DPTR
00B0 E0                MOVX    A,@DPTR
00B1 FF                MOV     R7,A
00B2 120000      E     LCALL   ?C?SLDIV
00B5 900000      R     MOV     DPTR,#coefB
00B8 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1216
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 56  

00BB 900000      R     MOV     DPTR,#ADC_Offset
00BE E0                MOVX    A,@DPTR
00BF FC                MOV     R4,A
00C0 A3                INC     DPTR
00C1 E0                MOVX    A,@DPTR
00C2 FD                MOV     R5,A
00C3 A3                INC     DPTR
00C4 E0                MOVX    A,@DPTR
00C5 FE                MOV     R6,A
00C6 A3                INC     DPTR
00C7 E0                MOVX    A,@DPTR
00C8 FF                MOV     R7,A
00C9 900000      R     MOV     DPTR,#coefA
00CC E0                MOVX    A,@DPTR
00CD F8                MOV     R0,A
00CE A3                INC     DPTR
00CF E0                MOVX    A,@DPTR
00D0 F9                MOV     R1,A
00D1 A3                INC     DPTR
00D2 E0                MOVX    A,@DPTR
00D3 FA                MOV     R2,A
00D4 A3                INC     DPTR
00D5 E0                MOVX    A,@DPTR
00D6 FB                MOV     R3,A
00D7 120000      E     LCALL   ?C?LMUL
00DA 900000      R     MOV     DPTR,#coefB
00DD E0                MOVX    A,@DPTR
00DE F8                MOV     R0,A
00DF A3                INC     DPTR
00E0 E0                MOVX    A,@DPTR
00E1 F9                MOV     R1,A
00E2 A3                INC     DPTR
00E3 E0                MOVX    A,@DPTR
00E4 FA                MOV     R2,A
00E5 A3                INC     DPTR
00E6 E0                MOVX    A,@DPTR
00E7 FB                MOV     R3,A
00E8 120000      E     LCALL   ?C?SLDIV
00EB C004              PUSH    AR4
00ED C005              PUSH    AR5
00EF C006              PUSH    AR6
00F1 C007              PUSH    AR7
00F3 900000      R     MOV     DPTR,#adcCounts
00F6 E0                MOVX    A,@DPTR
00F7 FC                MOV     R4,A
00F8 A3                INC     DPTR
00F9 E0                MOVX    A,@DPTR
00FA FD                MOV     R5,A
00FB A3                INC     DPTR
00FC E0                MOVX    A,@DPTR
00FD FE                MOV     R6,A
00FE A3                INC     DPTR
00FF E0                MOVX    A,@DPTR
0100 FF                MOV     R7,A
0101 A3                INC     DPTR
0102 E0                MOVX    A,@DPTR
0103 F8                MOV     R0,A
0104 A3                INC     DPTR
0105 E0                MOVX    A,@DPTR
0106 F9                MOV     R1,A
0107 A3                INC     DPTR
0108 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 57  

0109 FA                MOV     R2,A
010A A3                INC     DPTR
010B E0                MOVX    A,@DPTR
010C FB                MOV     R3,A
010D 120000      E     LCALL   ?C?LMUL
0110 900000      R     MOV     DPTR,#coefB
0113 E0                MOVX    A,@DPTR
0114 F8                MOV     R0,A
0115 A3                INC     DPTR
0116 E0                MOVX    A,@DPTR
0117 F9                MOV     R1,A
0118 A3                INC     DPTR
0119 E0                MOVX    A,@DPTR
011A FA                MOV     R2,A
011B A3                INC     DPTR
011C E0                MOVX    A,@DPTR
011D FB                MOV     R3,A
011E 120000      E     LCALL   ?C?SLDIV
0121 D003              POP     AR3
0123 D002              POP     AR2
0125 D001              POP     AR1
0127 D000              POP     AR0
0129 C3                CLR     C
012A EF                MOV     A,R7
012B 9B                SUBB    A,R3
012C FF                MOV     R7,A
012D EE                MOV     A,R6
012E 9A                SUBB    A,R2
012F FE                MOV     R6,A
0130 ED                MOV     A,R5
0131 99                SUBB    A,R1
0132 FD                MOV     R5,A
0133 EC                MOV     A,R4
0134 98                SUBB    A,R0
0135 FC                MOV     R4,A
;---- Variable 'uVolts' assigned to Register 'R4/R5/R6/R7' ----
                                           ; SOURCE LINE # 1218
                                           ; SOURCE LINE # 1219
0136         ?C0058:
0136 22                RET     
             ; FUNCTION _ADC_CountsTo_uVolts (END)

             ; FUNCTION _ADC_InitConfig (BEGIN)
                                           ; SOURCE LINE # 1242
;---- Variable 'config' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1243
                                           ; SOURCE LINE # 1244
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#ADC_stopConversion
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1246
0005 EF                MOV     A,R7
0006 6401              XRL     A,#01H
0008 6003              JZ      $ + 5H
000A 020000      R     LJMP    ?C0060
                                           ; SOURCE LINE # 1247
                                           ; SOURCE LINE # 1249
000D 904E00            MOV     DPTR,#04E00H
0010 7432              MOV     A,#032H
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1250
0013 904E02            MOV     DPTR,#04E02H
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 58  

0016 7406              MOV     A,#06H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1251
0019 A3                INC     DPTR
001A 7408              MOV     A,#08H
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1252
001D A3                INC     DPTR
001E E4                CLR     A
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1253
0020 A3                INC     DPTR
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1254
0022 A3                INC     DPTR
0023 741F              MOV     A,#01FH
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1255
0026 904E08            MOV     DPTR,#04E08H
0029 E4                CLR     A
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1256
002B A3                INC     DPTR
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1257
002D A3                INC     DPTR
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1258
002F 904E14            MOV     DPTR,#04E14H
0032 04                INC     A
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1260
0034 905884            MOV     DPTR,#05884H
0037 7414              MOV     A,#014H
0039 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1261
003A A3                INC     DPTR
003B 7405              MOV     A,#05H
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1262
003E A3                INC     DPTR
003F 7416              MOV     A,#016H
0041 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1263
0042 A3                INC     DPTR
0043 E4                CLR     A
0044 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1264
0045 90588A            MOV     DPTR,#0588AH
0048 7444              MOV     A,#044H
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1265
004B A3                INC     DPTR
004C 7448              MOV     A,#048H
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1266
004F A3                INC     DPTR
0050 7401              MOV     A,#01H
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1267
0053 90588E            MOV     DPTR,#0588EH
0056 04                INC     A
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 59  

0057 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1268
0058 A3                INC     DPTR
0059 7422              MOV     A,#022H
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1269
005C A3                INC     DPTR
005D 7428              MOV     A,#028H
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1270
0060 A3                INC     DPTR
0061 74EB              MOV     A,#0EBH
0063 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1272
0064 7F52              MOV     R7,#052H
0066 120000      R     LCALL   _ADC_SetDSMRef0Reg
                                           ; SOURCE LINE # 1273
0069 905894            MOV     DPTR,#05894H
006C 7458              MOV     A,#058H
006E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1274
006F A3                INC     DPTR
0070 E4                CLR     A
0071 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1276
0072 90589A            MOV     DPTR,#0589AH
0075 04                INC     A
0076 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1277
0077 A3                INC     DPTR
0078 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1278
0079 A3                INC     DPTR
007A E4                CLR     A
007B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1279
007C A3                INC     DPTR
007D 740A              MOV     A,#0AH
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1288
0080 E4                CLR     A
0081 FF                MOV     R7,A
0082 120000      E     LCALL   _ADC_AMux_Select
                                           ; SOURCE LINE # 1300
0085 E4                CLR     A
0086 7F33              MOV     R7,#033H
0088 7E03              MOV     R6,#03H
008A FD                MOV     R5,A
008B FC                MOV     R4,A
008C 900000      R     MOV     DPTR,#ADC_CountsPerVolt
008F 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1302
0092 7D01              MOV     R5,#01H
0094 7F04              MOV     R7,#04H
0096 7E00              MOV     R6,#00H
0098 120000      E     LCALL   _ADC_Ext_CP_Clk_SetDividerRegister
                                           ; SOURCE LINE # 1306
009B 7D01              MOV     R5,#01H
009D 7F15              MOV     R7,#015H
009F 7E00              MOV     R6,#00H
00A1 120000      E     LCALL   _ADC_theACLK_SetDividerRegister
                                           ; SOURCE LINE # 1311
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 60  

00A4 7C00        E     MOV     R4,#HIGH ADC_ISR1
00A6 7D00        E     MOV     R5,#LOW ADC_ISR1
00A8 7F1D              MOV     R7,#01DH
00AA 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 1313
                                           ; SOURCE LINE # 1526
00AD         ?C0060:
00AD 22                RET     
             ; FUNCTION _ADC_InitConfig (END)

             ; FUNCTION _ADC_SelectConfiguration (BEGIN)
                                           ; SOURCE LINE # 1552
0000 900000      R     MOV     DPTR,#restart
0003 ED                MOV     A,R5
0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#config
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1554
                                           ; SOURCE LINE # 1556
000A D3                SETB    C
000B 9400              SUBB    A,#00H
000D 4062              JC      ?C0065
000F E0                MOVX    A,@DPTR
0010 FF                MOV     R7,A
0011 D3                SETB    C
0012 9401              SUBB    A,#01H
0014 505B              JNC     ?C0065
                                           ; SOURCE LINE # 1557
                                           ; SOURCE LINE # 1561
0016 900000      R     MOV     DPTR,#ADC_initVar
0019 E0                MOVX    A,@DPTR
001A 7005              JNZ     ?C0062
                                           ; SOURCE LINE # 1562
                                           ; SOURCE LINE # 1563
001C 900000      R     MOV     DPTR,#ADC_started
001F 04                INC     A
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1564
0021         ?C0062:
                                           ; SOURCE LINE # 1567
0021 900000      R     MOV     DPTR,#ADC_Config
0024 EF                MOV     A,R7
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1570
0026 120000      R     LCALL   ADC_Stop
                                           ; SOURCE LINE # 1573
0029 900000      R     MOV     DPTR,#config
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E 120000      R     LCALL   _ADC_InitConfig
                                           ; SOURCE LINE # 1576
0031 900000      R     MOV     DPTR,#config
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
0036 75F003            MOV     B,#03H
0039 A4                MUL     AB
003A 2400        R     ADD     A,#LOW ADC_gcor+0FFFFH
003C F582              MOV     DPL,A
003E E4                CLR     A
003F 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFFH
0041 F583              MOV     DPH,A
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 61  

0043 E0                MOVX    A,@DPTR
0044 904E0E            MOV     DPTR,#04E0EH
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1577
0048 EF                MOV     A,R7
0049 75F003            MOV     B,#03H
004C A4                MUL     AB
004D 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
004F F582              MOV     DPL,A
0051 E4                CLR     A
0052 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
0054 F583              MOV     DPH,A
0056 E0                MOVX    A,@DPTR
0057 FC                MOV     R4,A
0058 A3                INC     DPTR
0059 E0                MOVX    A,@DPTR
005A FD                MOV     R5,A
005B 7B02              MOV     R3,#02H
005D 7A4E              MOV     R2,#04EH
005F 790C              MOV     R1,#0CH
0061 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 1579
0064 900000      R     MOV     DPTR,#restart
0067 E0                MOVX    A,@DPTR
0068 B40106            CJNE    A,#01H,?C0065
                                           ; SOURCE LINE # 1580
                                           ; SOURCE LINE # 1582
006B 120000      R     LCALL   ADC_Start
                                           ; SOURCE LINE # 1585
006E 120000      R     LCALL   ADC_StartConvert
                                           ; SOURCE LINE # 1586
                                           ; SOURCE LINE # 1587
                                           ; SOURCE LINE # 1589
                                           ; SOURCE LINE # 1592
                                           ; SOURCE LINE # 1593
0071         ?C0065:
0071 22                RET     
             ; FUNCTION _ADC_SelectConfiguration (END)

             ; FUNCTION _ADC_GainCompensation (BEGIN)
                                           ; SOURCE LINE # 1617
0000 900000      R     MOV     DPTR,#idealDecGain
0003 EC                MOV     A,R4
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 EA                MOV     A,R2
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C EB                MOV     A,R3
000D F0                MOVX    @DPTR,A
;---- Variable 'inputRange' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1619
                                           ; SOURCE LINE # 1625
000E 900000      R     MOV     DPTR,#config
0011 E0                MOVX    A,@DPTR
0012 FE                MOV     R6,A
0013 D3                SETB    C
0014 9400              SUBB    A,#00H
0016 5003              JNC     $ + 5H
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 62  

0018 020000      R     LJMP    ?C0085
001B EE                MOV     A,R6
001C D3                SETB    C
001D 9401              SUBB    A,#01H
001F 4003              JC      $ + 5H
0021 020000      R     LJMP    ?C0085
                                           ; SOURCE LINE # 1626
                                           ; SOURCE LINE # 1627
0024 EF                MOV     A,R7
0025 24FC              ADD     A,#0FCH
0027 6015              JZ      ?C0069
0029 24FD              ADD     A,#0FDH
002B 603C              JZ      ?C0072
002D 14                DEC     A
002E 6062              JZ      ?C0075
0030 24FE              ADD     A,#0FEH
0032 7003              JNZ     $ + 5H
0034 020000      R     LJMP    ?C0078
0037 2409              ADD     A,#09H
0039 6003              JZ      $ + 5H
003B 020000      R     LJMP    ?C0081
                                           ; SOURCE LINE # 1628
                                           ; SOURCE LINE # 1629
                                           ; SOURCE LINE # 1630
003E         ?C0069:
                                           ; SOURCE LINE # 1632
003E 900000      R     MOV     DPTR,#resolution
0041 E0                MOVX    A,@DPTR
0042 D3                SETB    C
0043 940F              SUBB    A,#0FH
0045 4011              JC      ?C0070
                                           ; SOURCE LINE # 1633
                                           ; SOURCE LINE # 1634
0047 7B0C              MOV     R3,#0CH
0049 7A01              MOV     R2,#01H
004B 7918              MOV     R1,#018H
004D 120000      E     LCALL   _cyread8
0050 900000      R     MOV     DPTR,#flash
0053 EF                MOV     A,R7
0054 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1635
0055 020000      R     LJMP    ?C0067
0058         ?C0070:
                                           ; SOURCE LINE # 1637
                                           ; SOURCE LINE # 1638
0058 7B0C              MOV     R3,#0CH
005A 7A01              MOV     R2,#01H
005C 791C              MOV     R1,#01CH
005E 120000      E     LCALL   _cyread8
0061 900000      R     MOV     DPTR,#flash
0064 EF                MOV     A,R7
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1639
                                           ; SOURCE LINE # 1640
0066 020000      R     LJMP    ?C0067
                                           ; SOURCE LINE # 1642
0069         ?C0072:
                                           ; SOURCE LINE # 1644
0069 900000      R     MOV     DPTR,#resolution
006C E0                MOVX    A,@DPTR
006D D3                SETB    C
006E 940F              SUBB    A,#0FH
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 63  

0070 4010              JC      ?C0073
                                           ; SOURCE LINE # 1645
                                           ; SOURCE LINE # 1646
0072 7B0C              MOV     R3,#0CH
0074 7A01              MOV     R2,#01H
0076 7919              MOV     R1,#019H
0078 120000      E     LCALL   _cyread8
007B 900000      R     MOV     DPTR,#flash
007E EF                MOV     A,R7
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1647
0080 8067              SJMP    ?C0067
0082         ?C0073:
                                           ; SOURCE LINE # 1649
                                           ; SOURCE LINE # 1650
0082 7B0C              MOV     R3,#0CH
0084 7A01              MOV     R2,#01H
0086 791D              MOV     R1,#01DH
0088 120000      E     LCALL   _cyread8
008B 900000      R     MOV     DPTR,#flash
008E EF                MOV     A,R7
008F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1651
                                           ; SOURCE LINE # 1652
0090 8057              SJMP    ?C0067
                                           ; SOURCE LINE # 1654
0092         ?C0075:
                                           ; SOURCE LINE # 1656
0092 900000      R     MOV     DPTR,#resolution
0095 E0                MOVX    A,@DPTR
0096 D3                SETB    C
0097 940F              SUBB    A,#0FH
0099 4010              JC      ?C0076
                                           ; SOURCE LINE # 1657
                                           ; SOURCE LINE # 1658
009B 7B0C              MOV     R3,#0CH
009D 7A01              MOV     R2,#01H
009F 791A              MOV     R1,#01AH
00A1 120000      E     LCALL   _cyread8
00A4 900000      R     MOV     DPTR,#flash
00A7 EF                MOV     A,R7
00A8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1659
00A9 803E              SJMP    ?C0067
00AB         ?C0076:
                                           ; SOURCE LINE # 1661
                                           ; SOURCE LINE # 1662
00AB 7B0C              MOV     R3,#0CH
00AD 7A01              MOV     R2,#01H
00AF 791E              MOV     R1,#01EH
00B1 120000      E     LCALL   _cyread8
00B4 900000      R     MOV     DPTR,#flash
00B7 EF                MOV     A,R7
00B8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1663
                                           ; SOURCE LINE # 1664
00B9 802E              SJMP    ?C0067
                                           ; SOURCE LINE # 1666
00BB         ?C0078:
                                           ; SOURCE LINE # 1668
00BB 900000      R     MOV     DPTR,#resolution
00BE E0                MOVX    A,@DPTR
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 64  

00BF D3                SETB    C
00C0 940F              SUBB    A,#0FH
00C2 4010              JC      ?C0079
                                           ; SOURCE LINE # 1669
                                           ; SOURCE LINE # 1670
00C4 7B0C              MOV     R3,#0CH
00C6 7A01              MOV     R2,#01H
00C8 791B              MOV     R1,#01BH
00CA 120000      E     LCALL   _cyread8
00CD 900000      R     MOV     DPTR,#flash
00D0 EF                MOV     A,R7
00D1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1671
00D2 8015              SJMP    ?C0067
00D4         ?C0079:
                                           ; SOURCE LINE # 1673
                                           ; SOURCE LINE # 1674
00D4 7B0C              MOV     R3,#0CH
00D6 7A01              MOV     R2,#01H
00D8 791F              MOV     R1,#01FH
00DA 120000      E     LCALL   _cyread8
00DD 900000      R     MOV     DPTR,#flash
00E0 EF                MOV     A,R7
00E1 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1675
                                           ; SOURCE LINE # 1676
00E2 8005              SJMP    ?C0067
                                           ; SOURCE LINE # 1678
00E4         ?C0081:
                                           ; SOURCE LINE # 1679
00E4 E4                CLR     A
00E5 900000      R     MOV     DPTR,#flash
00E8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1680
                                           ; SOURCE LINE # 1681
00E9         ?C0067:
                                           ; SOURCE LINE # 1684
00E9 900000      R     MOV     DPTR,#flash
00EC E0                MOVX    A,@DPTR
00ED FF                MOV     R7,A
00EE 33                RLC     A
00EF 95E0              SUBB    A,ACC
00F1 FE                MOV     R6,A
00F2 FD                MOV     R5,A
00F3 FC                MOV     R4,A
00F4 E4                CLR     A
00F5 7B20              MOV     R3,#020H
00F7 FA                MOV     R2,A
00F8 F9                MOV     R1,A
00F9 F8                MOV     R0,A
00FA 120000      E     LCALL   ?C?LMUL
00FD A804              MOV     R0,AR4
00FF A905              MOV     R1,AR5
0101 AA06              MOV     R2,AR6
0103 AB07              MOV     R3,AR7
0105 900000      R     MOV     DPTR,#idealDecGain
0108 E0                MOVX    A,@DPTR
0109 FE                MOV     R6,A
010A A3                INC     DPTR
010B E0                MOVX    A,@DPTR
010C FF                MOV     R7,A
010D E4                CLR     A
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 65  

010E FC                MOV     R4,A
010F FD                MOV     R5,A
0110 EB                MOV     A,R3
0111 2F                ADD     A,R7
0112 FF                MOV     R7,A
0113 EA                MOV     A,R2
0114 3E                ADDC    A,R6
0115 FE                MOV     R6,A
0116 ED                MOV     A,R5
0117 39                ADDC    A,R1
0118 FD                MOV     R5,A
0119 EC                MOV     A,R4
011A 38                ADDC    A,R0
011B FC                MOV     R4,A
;---- Variable 'normalised' assigned to Register 'R4/R5/R6/R7' ----
                                           ; SOURCE LINE # 1685
011C AB07              MOV     R3,AR7
011E AA06              MOV     R2,AR6
0120 A905              MOV     R1,AR5
0122 F8                MOV     R0,A
0123 A3                INC     DPTR
0124 E0                MOVX    A,@DPTR
0125 FE                MOV     R6,A
0126 A3                INC     DPTR
0127 E0                MOVX    A,@DPTR
0128 FF                MOV     R7,A
0129 E4                CLR     A
012A FC                MOV     R4,A
012B FD                MOV     R5,A
012C 120000      E     LCALL   ?C?LMUL
;---- Variable 'gcorTmp' assigned to Register 'R4/R5/R6/R7' ----
                                           ; SOURCE LINE # 1686
012F E4                CLR     A
0130 FB                MOV     R3,A
0131 7A80              MOV     R2,#080H
0133 F9                MOV     R1,A
0134 F8                MOV     R0,A
0135 120000      E     LCALL   ?C?ULDIV
;---- Variable 'gcorValue' assigned to Register 'R4/R5' ----
0138 AD07              MOV     R5,AR7
013A AC06              MOV     R4,AR6
                                           ; SOURCE LINE # 1688
013C 900000      R     MOV     DPTR,#resolution
013F E0                MOVX    A,@DPTR
0140 C3                CLR     C
0141 940E              SUBB    A,#0EH
0143 502F              JNC     ?C0082
                                           ; SOURCE LINE # 1689
                                           ; SOURCE LINE # 1690
0145 E0                MOVX    A,@DPTR
0146 FB                MOV     R3,A
0147 C3                CLR     C
0148 740E              MOV     A,#0EH
014A 9B                SUBB    A,R3
014B FF                MOV     R7,A
014C ED                MOV     A,R5
014D A807              MOV     R0,AR7
014F 08                INC     R0
0150 8005              SJMP    ?C0093
0152         ?C0092:
0152 CE                XCH     A,R6
0153 C3                CLR     C
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 66  

0154 13                RRC     A
0155 CE                XCH     A,R6
0156 13                RRC     A
0157         ?C0093:
0157 D8F9              DJNZ    R0,?C0092
0159 FD                MOV     R5,A
015A AC06              MOV     R4,AR6
                                           ; SOURCE LINE # 1691
015C EB                MOV     A,R3
015D 04                INC     A
015E FF                MOV     R7,A
015F 900000      R     MOV     DPTR,#config
0162 E0                MOVX    A,@DPTR
0163 75F003            MOV     B,#03H
0166 A4                MUL     AB
0167 2400        R     ADD     A,#LOW ADC_gcor+0FFFFH
0169 F582              MOV     DPL,A
016B E4                CLR     A
016C 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFFH
016E F583              MOV     DPH,A
0170 EF                MOV     A,R7
0171 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1692
0172 8014              SJMP    ?C0083
0174         ?C0082:
                                           ; SOURCE LINE # 1694
                                           ; SOURCE LINE # 1696
0174 900000      R     MOV     DPTR,#config
0177 E0                MOVX    A,@DPTR
0178 75F003            MOV     B,#03H
017B A4                MUL     AB
017C 2400        R     ADD     A,#LOW ADC_gcor+0FFFFH
017E F582              MOV     DPL,A
0180 E4                CLR     A
0181 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFFH
0183 F583              MOV     DPH,A
0185 740F              MOV     A,#0FH
0187 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1697
0188         ?C0083:
                                           ; SOURCE LINE # 1700
0188 AF05              MOV     R7,AR5
018A 900000      R     MOV     DPTR,#config
018D E0                MOVX    A,@DPTR
018E 75F003            MOV     B,#03H
0191 A4                MUL     AB
0192 2400        R     ADD     A,#LOW ADC_gcor+0FFFDH
0194 F582              MOV     DPL,A
0196 E4                CLR     A
0197 3400        R     ADDC    A,#HIGH ADC_gcor+0FFFDH
0199 F583              MOV     DPH,A
019B EC                MOV     A,R4
019C F0                MOVX    @DPTR,A
019D A3                INC     DPTR
019E EF                MOV     A,R7
019F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1701
                                           ; SOURCE LINE # 1703
                                           ; SOURCE LINE # 1706
                                           ; SOURCE LINE # 1707
01A0         ?C0085:
01A0 22                RET     
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 67  

             ; FUNCTION _ADC_GainCompensation (END)

             ; FUNCTION _ADC_SetDSMRef0Reg (BEGIN)
                                           ; SOURCE LINE # 1724
0000 900000      R     MOV     DPTR,#value
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1725
                                           ; SOURCE LINE # 1727
0005 120000      E     LCALL   CyEnterCriticalSection
0008 900000      R     MOV     DPTR,#enableInterrupts
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1730
000D 9046F8            MOV     DPTR,#046F8H
0010 E0                MOVX    A,@DPTR
0011 4403              ORL     A,#03H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1731
0014 A3                INC     DPTR
0015 E0                MOVX    A,@DPTR
0016 4403              ORL     A,#03H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1732
0019 900000      R     MOV     DPTR,#value
001C E0                MOVX    A,@DPTR
001D 905892            MOV     DPTR,#05892H
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1735
0021 7F03              MOV     R7,#03H
0023 7E00              MOV     R6,#00H
0025 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1737
0028 9046F8            MOV     DPTR,#046F8H
002B E0                MOVX    A,@DPTR
002C 54FC              ANL     A,#0FCH
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1738
002F A3                INC     DPTR
0030 E0                MOVX    A,@DPTR
0031 54FC              ANL     A,#0FCH
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1740
0034 900000      R     MOV     DPTR,#enableInterrupts
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1741
003C 22                RET     
             ; FUNCTION _ADC_SetDSMRef0Reg (END)

             ; FUNCTION ADC_Read8 (BEGIN)
                                           ; SOURCE LINE # 1762
                                           ; SOURCE LINE # 1763
                                           ; SOURCE LINE # 1767
0000 904E01            MOV     DPTR,#04E01H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1768
0007 120000      R     LCALL   ADC_StartConvert
                                           ; SOURCE LINE # 1769
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 68  

000A E4                CLR     A
000B FF                MOV     R7,A
000C 120000      R     LCALL   _ADC_IsEndConversion
                                           ; SOURCE LINE # 1770
000F 120000      R     LCALL   ADC_GetResult8
;---- Variable 'result' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1771
0012 120000      R     LCALL   ADC_StopConvert
                                           ; SOURCE LINE # 1773
                                           ; SOURCE LINE # 1774
0015         ?C0087:
0015 22                RET     
             ; FUNCTION ADC_Read8 (END)

             ; FUNCTION ADC_Read16 (BEGIN)
                                           ; SOURCE LINE # 1795
                                           ; SOURCE LINE # 1796
                                           ; SOURCE LINE # 1800
0000 904E01            MOV     DPTR,#04E01H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1801
0007 120000      R     LCALL   ADC_StartConvert
                                           ; SOURCE LINE # 1802
000A E4                CLR     A
000B FF                MOV     R7,A
000C 120000      R     LCALL   _ADC_IsEndConversion
                                           ; SOURCE LINE # 1803
000F 120000      R     LCALL   ADC_GetResult16
;---- Variable 'result' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 1804
0012 120000      R     LCALL   ADC_StopConvert
                                           ; SOURCE LINE # 1806
                                           ; SOURCE LINE # 1807
0015         ?C0088:
0015 22                RET     
             ; FUNCTION ADC_Read16 (END)

             ; FUNCTION ADC_Read32 (BEGIN)
                                           ; SOURCE LINE # 1828
                                           ; SOURCE LINE # 1829
                                           ; SOURCE LINE # 1833
0000 904E01            MOV     DPTR,#04E01H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1834
0007 120000      R     LCALL   ADC_StartConvert
                                           ; SOURCE LINE # 1835
000A E4                CLR     A
000B FF                MOV     R7,A
000C 120000      R     LCALL   _ADC_IsEndConversion
                                           ; SOURCE LINE # 1836
000F 120000      R     LCALL   ADC_GetResult32
;---- Variable 'result' assigned to Register 'R4/R5/R6/R7' ----
                                           ; SOURCE LINE # 1837
0012 120000      R     LCALL   ADC_StopConvert
                                           ; SOURCE LINE # 1839
                                           ; SOURCE LINE # 1840
0015         ?C0089:
0015 22                RET     
C51 COMPILER V9.51   ADC                                                                   02/07/2017 16:12:16 PAGE 69  

             ; FUNCTION ADC_Read32 (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2789    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     16      58
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
