C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE UART_RS485
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Release\UART_RS485.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\4.0\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -Generated_Source\PSoC3\UART_RS485.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB DF(NDEBU
                    -G) WL(2) PR(.\DP8051_Keil_951\Release/UART_RS485.lst) CD OT(8,SPEED) OJ(.\DP8051_Keil_951\Release\UART_RS485.obj)

line level    source

*** MESSAGE C286 IN LINE 0 OF (null): license limits optimization to level 5
   1          /*******************************************************************************
   2          * File Name: UART_RS485.c
   3          * Version 2.50
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the UART component
   7          *
   8          * Note:
   9          *
  10          ********************************************************************************
  11          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  12          * You may use this file only in accordance with the license, terms, conditions,
  13          * disclaimers, and limitations in the end user license agreement accompanying
  14          * the software package with which this file was provided.
  15          *******************************************************************************/
  16          
  17          #include "UART_RS485.h"
  18          #if (UART_RS485_INTERNAL_CLOCK_USED)
                  #include "UART_RS485_IntClock.h"
              #endif /* End UART_RS485_INTERNAL_CLOCK_USED */
  21          
  22          
  23          /***************************************
  24          * Global data allocation
  25          ***************************************/
  26          
  27          uint8 UART_RS485_initVar = 0u;
  28          
  29          #if (UART_RS485_TX_INTERRUPT_ENABLED && UART_RS485_TX_ENABLED)
                  volatile uint8 UART_RS485_txBuffer[UART_RS485_TX_BUFFER_SIZE];
                  volatile uint8 UART_RS485_txBufferRead = 0u;
                  uint8 UART_RS485_txBufferWrite = 0u;
              #endif /* (UART_RS485_TX_INTERRUPT_ENABLED && UART_RS485_TX_ENABLED) */
  34          
  35          #if (UART_RS485_RX_INTERRUPT_ENABLED && (UART_RS485_RX_ENABLED || UART_RS485_HD_ENABLED))
  36              uint8 UART_RS485_errorStatus = 0u;
  37              volatile uint8 UART_RS485_rxBuffer[UART_RS485_RX_BUFFER_SIZE];
  38              volatile uint8 UART_RS485_rxBufferRead  = 0u;
  39              volatile uint8 UART_RS485_rxBufferWrite = 0u;
  40              volatile uint8 UART_RS485_rxBufferLoopDetect = 0u;
  41              volatile uint8 UART_RS485_rxBufferOverflow   = 0u;
  42              #if (UART_RS485_RXHW_ADDRESS_ENABLED)
                      volatile uint8 UART_RS485_rxAddressMode = UART_RS485_RX_ADDRESS_MODE;
                      volatile uint8 UART_RS485_rxAddressDetected = 0u;
                  #endif /* (UART_RS485_RXHW_ADDRESS_ENABLED) */
  46          #endif /* (UART_RS485_RX_INTERRUPT_ENABLED && (UART_RS485_RX_ENABLED || UART_RS485_HD_ENABLED)) */
  47          
  48          
  49          /*******************************************************************************
  50          * Function Name: UART_RS485_Start
  51          ********************************************************************************
  52          *
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 2   

  53          * Summary:
  54          *  This is the preferred method to begin component operation.
  55          *  UART_RS485_Start() sets the initVar variable, calls the
  56          *  UART_RS485_Init() function, and then calls the
  57          *  UART_RS485_Enable() function.
  58          *
  59          * Parameters:
  60          *  None.
  61          *
  62          * Return:
  63          *  None.
  64          *
  65          * Global variables:
  66          *  The UART_RS485_intiVar variable is used to indicate initial
  67          *  configuration of this component. The variable is initialized to zero (0u)
  68          *  and set to one (1u) the first time UART_RS485_Start() is called. This
  69          *  allows for component initialization without re-initialization in all
  70          *  subsequent calls to the UART_RS485_Start() routine.
  71          *
  72          * Reentrant:
  73          *  No.
  74          *
  75          *******************************************************************************/
  76          void UART_RS485_Start(void) 
  77          {
  78   1          /* If not initialized then initialize all required hardware and software */
  79   1          if(UART_RS485_initVar == 0u)
  80   1          {
  81   2              UART_RS485_Init();
  82   2              UART_RS485_initVar = 1u;
  83   2          }
  84   1      
  85   1          UART_RS485_Enable();
  86   1      }
  87          
  88          
  89          /*******************************************************************************
  90          * Function Name: UART_RS485_Init
  91          ********************************************************************************
  92          *
  93          * Summary:
  94          *  Initializes or restores the component according to the customizer Configure
  95          *  dialog settings. It is not necessary to call UART_RS485_Init() because
  96          *  the UART_RS485_Start() API calls this function and is the preferred
  97          *  method to begin component operation.
  98          *
  99          * Parameters:
 100          *  None.
 101          *
 102          * Return:
 103          *  None.
 104          *
 105          *******************************************************************************/
 106          void UART_RS485_Init(void) 
 107          {
 108   1          #if(UART_RS485_RX_ENABLED || UART_RS485_HD_ENABLED)
 109   1      
 110   1              #if (UART_RS485_RX_INTERRUPT_ENABLED)
 111   1                  /* Set RX interrupt vector and priority */
 112   1                  (void) CyIntSetVector(UART_RS485_RX_VECT_NUM, &UART_RS485_RXISR);
 113   1                  CyIntSetPriority(UART_RS485_RX_VECT_NUM, UART_RS485_RX_PRIOR_NUM);
 114   1                  UART_RS485_errorStatus = 0u;
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 3   

 115   1              #endif /* (UART_RS485_RX_INTERRUPT_ENABLED) */
 116   1      
 117   1              #if (UART_RS485_RXHW_ADDRESS_ENABLED)
                          UART_RS485_SetRxAddressMode(UART_RS485_RX_ADDRESS_MODE);
                          UART_RS485_SetRxAddress1(UART_RS485_RX_HW_ADDRESS1);
                          UART_RS485_SetRxAddress2(UART_RS485_RX_HW_ADDRESS2);
                      #endif /* End UART_RS485_RXHW_ADDRESS_ENABLED */
 122   1      
 123   1              /* Init Count7 period */
 124   1              UART_RS485_RXBITCTR_PERIOD_REG = UART_RS485_RXBITCTR_INIT;
 125   1              /* Configure the Initial RX interrupt mask */
 126   1              UART_RS485_RXSTATUS_MASK_REG  = UART_RS485_INIT_RX_INTERRUPTS_MASK;
 127   1          #endif /* End UART_RS485_RX_ENABLED || UART_RS485_HD_ENABLED*/
 128   1      
 129   1          #if(UART_RS485_TX_ENABLED)
 130   1              #if (UART_RS485_TX_INTERRUPT_ENABLED)
                          /* Set TX interrupt vector and priority */
                          (void) CyIntSetVector(UART_RS485_TX_VECT_NUM, &UART_RS485_TXISR);
                          CyIntSetPriority(UART_RS485_TX_VECT_NUM, UART_RS485_TX_PRIOR_NUM);
                      #endif /* (UART_RS485_TX_INTERRUPT_ENABLED) */
 135   1      
 136   1              /* Write Counter Value for TX Bit Clk Generator*/
 137   1              #if (UART_RS485_TXCLKGEN_DP)
 138   1                  UART_RS485_TXBITCLKGEN_CTR_REG = UART_RS485_BIT_CENTER;
 139   1                  UART_RS485_TXBITCLKTX_COMPLETE_REG = ((UART_RS485_NUMBER_OF_DATA_BITS +
 140   1                              UART_RS485_NUMBER_OF_START_BIT) * UART_RS485_OVER_SAMPLE_COUNT) - 1u;
 141   1              #else
                          UART_RS485_TXBITCTR_PERIOD_REG = ((UART_RS485_NUMBER_OF_DATA_BITS +
                                      UART_RS485_NUMBER_OF_START_BIT) * UART_RS485_OVER_SAMPLE_8) - 1u;
                      #endif /* End UART_RS485_TXCLKGEN_DP */
 145   1      
 146   1              /* Configure the Initial TX interrupt mask */
 147   1              #if (UART_RS485_TX_INTERRUPT_ENABLED)
                          UART_RS485_TXSTATUS_MASK_REG = UART_RS485_TX_STS_FIFO_EMPTY;
                      #else
 150   1                  UART_RS485_TXSTATUS_MASK_REG = UART_RS485_INIT_TX_INTERRUPTS_MASK;
 151   1              #endif /*End UART_RS485_TX_INTERRUPT_ENABLED*/
 152   1      
 153   1          #endif /* End UART_RS485_TX_ENABLED */
 154   1      
 155   1          #if(UART_RS485_PARITY_TYPE_SW)  /* Write Parity to Control Register */
                      UART_RS485_WriteControlRegister( \
                          (UART_RS485_ReadControlRegister() & (uint8)~UART_RS485_CTRL_PARITY_TYPE_MASK) | \
                          (uint8)(UART_RS485_PARITY_TYPE << UART_RS485_CTRL_PARITY_TYPE0_SHIFT) );
                  #endif /* End UART_RS485_PARITY_TYPE_SW */
 160   1      }
 161          
 162          
 163          /*******************************************************************************
 164          * Function Name: UART_RS485_Enable
 165          ********************************************************************************
 166          *
 167          * Summary:
 168          *  Activates the hardware and begins component operation. It is not necessary
 169          *  to call UART_RS485_Enable() because the UART_RS485_Start() API
 170          *  calls this function, which is the preferred method to begin component
 171          *  operation.
 172          
 173          * Parameters:
 174          *  None.
 175          *
 176          * Return:
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 4   

 177          *  None.
 178          *
 179          * Global Variables:
 180          *  UART_RS485_rxAddressDetected - set to initial state (0).
 181          *
 182          *******************************************************************************/
 183          void UART_RS485_Enable(void) 
 184          {
 185   1          uint8 enableInterrupts;
 186   1          enableInterrupts = CyEnterCriticalSection();
 187   1      
 188   1          #if (UART_RS485_RX_ENABLED || UART_RS485_HD_ENABLED)
 189   1              /* RX Counter (Count7) Enable */
 190   1              UART_RS485_RXBITCTR_CONTROL_REG |= UART_RS485_CNTR_ENABLE;
 191   1      
 192   1              /* Enable the RX Interrupt */
 193   1              UART_RS485_RXSTATUS_ACTL_REG  |= UART_RS485_INT_ENABLE;
 194   1      
 195   1              #if (UART_RS485_RX_INTERRUPT_ENABLED)
 196   1                  UART_RS485_EnableRxInt();
 197   1      
 198   1                  #if (UART_RS485_RXHW_ADDRESS_ENABLED)
                              UART_RS485_rxAddressDetected = 0u;
                          #endif /* (UART_RS485_RXHW_ADDRESS_ENABLED) */
 201   1              #endif /* (UART_RS485_RX_INTERRUPT_ENABLED) */
 202   1          #endif /* (UART_RS485_RX_ENABLED || UART_RS485_HD_ENABLED) */
 203   1      
 204   1          #if(UART_RS485_TX_ENABLED)
 205   1              /* TX Counter (DP/Count7) Enable */
 206   1              #if(!UART_RS485_TXCLKGEN_DP)
                          UART_RS485_TXBITCTR_CONTROL_REG |= UART_RS485_CNTR_ENABLE;
                      #endif /* End UART_RS485_TXCLKGEN_DP */
 209   1      
 210   1              /* Enable the TX Interrupt */
 211   1              UART_RS485_TXSTATUS_ACTL_REG |= UART_RS485_INT_ENABLE;
 212   1              #if (UART_RS485_TX_INTERRUPT_ENABLED)
                          UART_RS485_ClearPendingTxInt(); /* Clear history of TX_NOT_EMPTY */
                          UART_RS485_EnableTxInt();
                      #endif /* (UART_RS485_TX_INTERRUPT_ENABLED) */
 216   1           #endif /* (UART_RS485_TX_INTERRUPT_ENABLED) */
 217   1      
 218   1          #if (UART_RS485_INTERNAL_CLOCK_USED)
                      UART_RS485_IntClock_Start();  /* Enable the clock */
                  #endif /* (UART_RS485_INTERNAL_CLOCK_USED) */
 221   1      
 222   1          CyExitCriticalSection(enableInterrupts);
 223   1      }
 224          
 225          
 226          /*******************************************************************************
 227          * Function Name: UART_RS485_Stop
 228          ********************************************************************************
 229          *
 230          * Summary:
 231          *  Disables the UART operation.
 232          *
 233          * Parameters:
 234          *  None.
 235          *
 236          * Return:
 237          *  None.
 238          *
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 5   

 239          *******************************************************************************/
 240          void UART_RS485_Stop(void) 
 241          {
 242   1          uint8 enableInterrupts;
 243   1          enableInterrupts = CyEnterCriticalSection();
 244   1      
 245   1          /* Write Bit Counter Disable */
 246   1          #if (UART_RS485_RX_ENABLED || UART_RS485_HD_ENABLED)
 247   1              UART_RS485_RXBITCTR_CONTROL_REG &= (uint8) ~UART_RS485_CNTR_ENABLE;
 248   1          #endif /* (UART_RS485_RX_ENABLED || UART_RS485_HD_ENABLED) */
 249   1      
 250   1          #if (UART_RS485_TX_ENABLED)
 251   1              #if(!UART_RS485_TXCLKGEN_DP)
                          UART_RS485_TXBITCTR_CONTROL_REG &= (uint8) ~UART_RS485_CNTR_ENABLE;
                      #endif /* (!UART_RS485_TXCLKGEN_DP) */
 254   1          #endif /* (UART_RS485_TX_ENABLED) */
 255   1      
 256   1          #if (UART_RS485_INTERNAL_CLOCK_USED)
                      UART_RS485_IntClock_Stop();   /* Disable the clock */
                  #endif /* (UART_RS485_INTERNAL_CLOCK_USED) */
 259   1      
 260   1          /* Disable internal interrupt component */
 261   1          #if (UART_RS485_RX_ENABLED || UART_RS485_HD_ENABLED)
 262   1              UART_RS485_RXSTATUS_ACTL_REG  &= (uint8) ~UART_RS485_INT_ENABLE;
 263   1      
 264   1              #if (UART_RS485_RX_INTERRUPT_ENABLED)
 265   1                  UART_RS485_DisableRxInt();
 266   1              #endif /* (UART_RS485_RX_INTERRUPT_ENABLED) */
 267   1          #endif /* (UART_RS485_RX_ENABLED || UART_RS485_HD_ENABLED) */
 268   1      
 269   1          #if (UART_RS485_TX_ENABLED)
 270   1              UART_RS485_TXSTATUS_ACTL_REG &= (uint8) ~UART_RS485_INT_ENABLE;
 271   1      
 272   1              #if (UART_RS485_TX_INTERRUPT_ENABLED)
                          UART_RS485_DisableTxInt();
                      #endif /* (UART_RS485_TX_INTERRUPT_ENABLED) */
 275   1          #endif /* (UART_RS485_TX_ENABLED) */
 276   1      
 277   1          CyExitCriticalSection(enableInterrupts);
 278   1      }
 279          
 280          
 281          /*******************************************************************************
 282          * Function Name: UART_RS485_ReadControlRegister
 283          ********************************************************************************
 284          *
 285          * Summary:
 286          *  Returns the current value of the control register.
 287          *
 288          * Parameters:
 289          *  None.
 290          *
 291          * Return:
 292          *  Contents of the control register.
 293          *
 294          *******************************************************************************/
 295          uint8 UART_RS485_ReadControlRegister(void) 
 296          {
 297   1          #if (UART_RS485_CONTROL_REG_REMOVED)
 298   1              return(0u);
 299   1          #else
                      return(UART_RS485_CONTROL_REG);
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 6   

                  #endif /* (UART_RS485_CONTROL_REG_REMOVED) */
 302   1      }
 303          
 304          
 305          /*******************************************************************************
 306          * Function Name: UART_RS485_WriteControlRegister
 307          ********************************************************************************
 308          *
 309          * Summary:
 310          *  Writes an 8-bit value into the control register
 311          *
 312          * Parameters:
 313          *  control:  control register value
 314          *
 315          * Return:
 316          *  None.
 317          *
 318          *******************************************************************************/
 319          void  UART_RS485_WriteControlRegister(uint8 control) 
 320          {
 321   1          #if (UART_RS485_CONTROL_REG_REMOVED)
 322   1              if(0u != control)
 323   1              {
 324   2                  /* Suppress compiler warning */
 325   2              }
 326   1          #else
                     UART_RS485_CONTROL_REG = control;
                  #endif /* (UART_RS485_CONTROL_REG_REMOVED) */
 329   1      }
 330          
 331          
 332          #if(UART_RS485_RX_ENABLED || UART_RS485_HD_ENABLED)
 333              /*******************************************************************************
 334              * Function Name: UART_RS485_SetRxInterruptMode
 335              ********************************************************************************
 336              *
 337              * Summary:
 338              *  Configures the RX interrupt sources enabled.
 339              *
 340              * Parameters:
 341              *  IntSrc:  Bit field containing the RX interrupts to enable. Based on the 
 342              *  bit-field arrangement of the status register. This value must be a 
 343              *  combination of status register bit-masks shown below:
 344              *      UART_RS485_RX_STS_FIFO_NOTEMPTY    Interrupt on byte received.
 345              *      UART_RS485_RX_STS_PAR_ERROR        Interrupt on parity error.
 346              *      UART_RS485_RX_STS_STOP_ERROR       Interrupt on stop error.
 347              *      UART_RS485_RX_STS_BREAK            Interrupt on break.
 348              *      UART_RS485_RX_STS_OVERRUN          Interrupt on overrun error.
 349              *      UART_RS485_RX_STS_ADDR_MATCH       Interrupt on address match.
 350              *      UART_RS485_RX_STS_MRKSPC           Interrupt on address detect.
 351              *
 352              * Return:
 353              *  None.
 354              *
 355              * Theory:
 356              *  Enables the output of specific status bits to the interrupt controller
 357              *
 358              *******************************************************************************/
 359              void UART_RS485_SetRxInterruptMode(uint8 intSrc) 
 360              {
 361   1              UART_RS485_RXSTATUS_MASK_REG  = intSrc;
 362   1          }
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 7   

 363          
 364          
 365              /*******************************************************************************
 366              * Function Name: UART_RS485_ReadRxData
 367              ********************************************************************************
 368              *
 369              * Summary:
 370              *  Returns the next byte of received data. This function returns data without
 371              *  checking the status. You must check the status separately.
 372              *
 373              * Parameters:
 374              *  None.
 375              *
 376              * Return:
 377              *  Received data from RX register
 378              *
 379              * Global Variables:
 380              *  UART_RS485_rxBuffer - RAM buffer pointer for save received data.
 381              *  UART_RS485_rxBufferWrite - cyclic index for write to rxBuffer,
 382              *     checked to identify new data.
 383              *  UART_RS485_rxBufferRead - cyclic index for read from rxBuffer,
 384              *     incremented after each byte has been read from buffer.
 385              *  UART_RS485_rxBufferLoopDetect - cleared if loop condition was detected
 386              *     in RX ISR.
 387              *
 388              * Reentrant:
 389              *  No.
 390              *
 391              *******************************************************************************/
 392              uint8 UART_RS485_ReadRxData(void) 
 393              {
 394   1              uint8 rxData;
 395   1      
 396   1          #if (UART_RS485_RX_INTERRUPT_ENABLED)
 397   1      
 398   1              uint8 locRxBufferRead;
 399   1              uint8 locRxBufferWrite;
 400   1      
 401   1              /* Protect variables that could change on interrupt */
 402   1              UART_RS485_DisableRxInt();
 403   1      
 404   1              locRxBufferRead  = UART_RS485_rxBufferRead;
 405   1              locRxBufferWrite = UART_RS485_rxBufferWrite;
 406   1      
 407   1              if( (UART_RS485_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 408   1              {
 409   2                  rxData = UART_RS485_rxBuffer[locRxBufferRead];
 410   2                  locRxBufferRead++;
 411   2      
 412   2                  if(locRxBufferRead >= UART_RS485_RX_BUFFER_SIZE)
 413   2                  {
 414   3                      locRxBufferRead = 0u;
 415   3                  }
 416   2                  /* Update the real pointer */
 417   2                  UART_RS485_rxBufferRead = locRxBufferRead;
 418   2      
 419   2                  if(UART_RS485_rxBufferLoopDetect != 0u)
 420   2                  {
 421   3                      UART_RS485_rxBufferLoopDetect = 0u;
 422   3                      #if ((UART_RS485_RX_INTERRUPT_ENABLED) && (UART_RS485_FLOW_CONTROL != 0u))
                                  /* When Hardware Flow Control selected - return RX mask */
                                  #if( UART_RS485_HD_ENABLED )
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 8   

                                      if((UART_RS485_CONTROL_REG & UART_RS485_CTRL_HD_SEND) == 0u)
                                      {   /* In Half duplex mode return RX mask only in RX
                                          *  configuration set, otherwise
                                          *  mask will be returned in LoadRxConfig() API.
                                          */
                                          UART_RS485_RXSTATUS_MASK_REG  |= UART_RS485_RX_STS_FIFO_NOTEMPTY;
                                      }
                                  #else
                                      UART_RS485_RXSTATUS_MASK_REG  |= UART_RS485_RX_STS_FIFO_NOTEMPTY;
                                  #endif /* end UART_RS485_HD_ENABLED */
                              #endif /* ((UART_RS485_RX_INTERRUPT_ENABLED) && (UART_RS485_FLOW_CONTROL != 0u)) */
 436   3                  }
 437   2              }
 438   1              else
 439   1              {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 440   2                  rxData = UART_RS485_RXDATA_REG;
 441   2              }
 442   1      
 443   1              UART_RS485_EnableRxInt();
 444   1      
 445   1          #else
              
                      /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
                      rxData = UART_RS485_RXDATA_REG;
              
                  #endif /* (UART_RS485_RX_INTERRUPT_ENABLED) */
 451   1      
 452   1              return(rxData);
 453   1          }
 454          
 455          
 456              /*******************************************************************************
 457              * Function Name: UART_RS485_ReadRxStatus
 458              ********************************************************************************
 459              *
 460              * Summary:
 461              *  Returns the current state of the receiver status register and the software
 462              *  buffer overflow status.
 463              *
 464              * Parameters:
 465              *  None.
 466              *
 467              * Return:
 468              *  Current state of the status register.
 469              *
 470              * Side Effect:
 471              *  All status register bits are clear-on-read except
 472              *  UART_RS485_RX_STS_FIFO_NOTEMPTY.
 473              *  UART_RS485_RX_STS_FIFO_NOTEMPTY clears immediately after RX data
 474              *  register read.
 475              *
 476              * Global Variables:
 477              *  UART_RS485_rxBufferOverflow - used to indicate overload condition.
 478              *   It set to one in RX interrupt when there isn't free space in
 479              *   UART_RS485_rxBufferRead to write new data. This condition returned
 480              *   and cleared to zero by this API as an
 481              *   UART_RS485_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 482              *   bits.
 483              *
 484              *******************************************************************************/
 485              uint8 UART_RS485_ReadRxStatus(void) 
 486              {
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 9   

 487   1              uint8 status;
 488   1      
 489   1              status = UART_RS485_RXSTATUS_REG & UART_RS485_RX_HW_MASK;
 490   1      
 491   1          #if (UART_RS485_RX_INTERRUPT_ENABLED)
 492   1              if(UART_RS485_rxBufferOverflow != 0u)
 493   1              {
 494   2                  status |= UART_RS485_RX_STS_SOFT_BUFF_OVER;
 495   2                  UART_RS485_rxBufferOverflow = 0u;
 496   2              }
 497   1          #endif /* (UART_RS485_RX_INTERRUPT_ENABLED) */
 498   1      
 499   1              return(status);
 500   1          }
 501          
 502          
 503              /*******************************************************************************
 504              * Function Name: UART_RS485_GetChar
 505              ********************************************************************************
 506              *
 507              * Summary:
 508              *  Returns the last received byte of data. UART_RS485_GetChar() is
 509              *  designed for ASCII characters and returns a uint8 where 1 to 255 are values
 510              *  for valid characters and 0 indicates an error occurred or no data is present.
 511              *
 512              * Parameters:
 513              *  None.
 514              *
 515              * Return:
 516              *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 517              *  A returned zero signifies an error condition or no data available.
 518              *
 519              * Global Variables:
 520              *  UART_RS485_rxBuffer - RAM buffer pointer for save received data.
 521              *  UART_RS485_rxBufferWrite - cyclic index for write to rxBuffer,
 522              *     checked to identify new data.
 523              *  UART_RS485_rxBufferRead - cyclic index for read from rxBuffer,
 524              *     incremented after each byte has been read from buffer.
 525              *  UART_RS485_rxBufferLoopDetect - cleared if loop condition was detected
 526              *     in RX ISR.
 527              *
 528              * Reentrant:
 529              *  No.
 530              *
 531              *******************************************************************************/
 532              uint8 UART_RS485_GetChar(void) 
 533              {
 534   1              uint8 rxData = 0u;
 535   1              uint8 rxStatus;
 536   1      
 537   1          #if (UART_RS485_RX_INTERRUPT_ENABLED)
 538   1              uint8 locRxBufferRead;
 539   1              uint8 locRxBufferWrite;
 540   1      
 541   1              /* Protect variables that could change on interrupt */
 542   1              UART_RS485_DisableRxInt();
 543   1      
 544   1              locRxBufferRead  = UART_RS485_rxBufferRead;
 545   1              locRxBufferWrite = UART_RS485_rxBufferWrite;
 546   1      
 547   1              if( (UART_RS485_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 548   1              {
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 10  

 549   2                  rxData = UART_RS485_rxBuffer[locRxBufferRead];
 550   2                  locRxBufferRead++;
 551   2                  if(locRxBufferRead >= UART_RS485_RX_BUFFER_SIZE)
 552   2                  {
 553   3                      locRxBufferRead = 0u;
 554   3                  }
 555   2                  /* Update the real pointer */
 556   2                  UART_RS485_rxBufferRead = locRxBufferRead;
 557   2      
 558   2                  if(UART_RS485_rxBufferLoopDetect != 0u)
 559   2                  {
 560   3                      UART_RS485_rxBufferLoopDetect = 0u;
 561   3                      #if( (UART_RS485_RX_INTERRUPT_ENABLED) && (UART_RS485_FLOW_CONTROL != 0u) )
                                  /* When Hardware Flow Control selected - return RX mask */
                                  #if( UART_RS485_HD_ENABLED )
                                      if((UART_RS485_CONTROL_REG & UART_RS485_CTRL_HD_SEND) == 0u)
                                      {   /* In Half duplex mode return RX mask only if
                                          *  RX configuration set, otherwise
                                          *  mask will be returned in LoadRxConfig() API.
                                          */
                                          UART_RS485_RXSTATUS_MASK_REG |= UART_RS485_RX_STS_FIFO_NOTEMPTY;
                                      }
                                  #else
                                      UART_RS485_RXSTATUS_MASK_REG |= UART_RS485_RX_STS_FIFO_NOTEMPTY;
                                  #endif /* end UART_RS485_HD_ENABLED */
                              #endif /* UART_RS485_RX_INTERRUPT_ENABLED and Hardware flow control*/
 575   3                  }
 576   2      
 577   2              }
 578   1              else
 579   1              {   rxStatus = UART_RS485_RXSTATUS_REG;
 580   2                  if((rxStatus & UART_RS485_RX_STS_FIFO_NOTEMPTY) != 0u)
 581   2                  {   /* Read received data from FIFO */
 582   3                      rxData = UART_RS485_RXDATA_REG;
 583   3                      /*Check status on error*/
 584   3                      if((rxStatus & (UART_RS485_RX_STS_BREAK | UART_RS485_RX_STS_PAR_ERROR |
 585   3                                      UART_RS485_RX_STS_STOP_ERROR | UART_RS485_RX_STS_OVERRUN)) != 0u)
 586   3                      {
 587   4                          rxData = 0u;
 588   4                      }
 589   3                  }
 590   2              }
 591   1      
 592   1              UART_RS485_EnableRxInt();
 593   1      
 594   1          #else
              
                      rxStatus =UART_RS485_RXSTATUS_REG;
                      if((rxStatus & UART_RS485_RX_STS_FIFO_NOTEMPTY) != 0u)
                      {
                          /* Read received data from FIFO */
                          rxData = UART_RS485_RXDATA_REG;
              
                          /*Check status on error*/
                          if((rxStatus & (UART_RS485_RX_STS_BREAK | UART_RS485_RX_STS_PAR_ERROR |
                                          UART_RS485_RX_STS_STOP_ERROR | UART_RS485_RX_STS_OVERRUN)) != 0u)
                          {
                              rxData = 0u;
                          }
                      }
                  #endif /* (UART_RS485_RX_INTERRUPT_ENABLED) */
 610   1      
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 11  

 611   1              return(rxData);
 612   1          }
 613          
 614          
 615              /*******************************************************************************
 616              * Function Name: UART_RS485_GetByte
 617              ********************************************************************************
 618              *
 619              * Summary:
 620              *  Reads UART RX buffer immediately, returns received character and error
 621              *  condition.
 622              *
 623              * Parameters:
 624              *  None.
 625              *
 626              * Return:
 627              *  MSB contains status and LSB contains UART RX data. If the MSB is nonzero,
 628              *  an error has occurred.
 629              *
 630              * Reentrant:
 631              *  No.
 632              *
 633              *******************************************************************************/
 634              uint16 UART_RS485_GetByte(void) 
 635              {
 636   1              
 637   1          #if (UART_RS485_RX_INTERRUPT_ENABLED)
 638   1              uint16 locErrorStatus;
 639   1              /* Protect variables that could change on interrupt */
 640   1              UART_RS485_DisableRxInt();
 641   1              locErrorStatus = (uint16)UART_RS485_errorStatus;
 642   1              UART_RS485_errorStatus = 0u;
 643   1              UART_RS485_EnableRxInt();
 644   1              return ( (uint16)(locErrorStatus << 8u) | UART_RS485_ReadRxData() );
 645   1          #else
                      return ( ((uint16)UART_RS485_ReadRxStatus() << 8u) | UART_RS485_ReadRxData() );
                  #endif /* UART_RS485_RX_INTERRUPT_ENABLED */
 648   1              
 649   1          }
 650          
 651          
 652              /*******************************************************************************
 653              * Function Name: UART_RS485_GetRxBufferSize
 654              ********************************************************************************
 655              *
 656              * Summary:
 657              *  Returns the number of received bytes available in the RX buffer.
 658              *  * RX software buffer is disabled (RX Buffer Size parameter is equal to 4): 
 659              *    returns 0 for empty RX FIFO or 1 for not empty RX FIFO.
 660              *  * RX software buffer is enabled: returns the number of bytes available in 
 661              *    the RX software buffer. Bytes available in the RX FIFO do not take to 
 662              *    account.
 663              *
 664              * Parameters:
 665              *  None.
 666              *
 667              * Return:
 668              *  uint8: Number of bytes in the RX buffer. 
 669              *    Return value type depends on RX Buffer Size parameter.
 670              *
 671              * Global Variables:
 672              *  UART_RS485_rxBufferWrite - used to calculate left bytes.
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 12  

 673              *  UART_RS485_rxBufferRead - used to calculate left bytes.
 674              *  UART_RS485_rxBufferLoopDetect - checked to decide left bytes amount.
 675              *
 676              * Reentrant:
 677              *  No.
 678              *
 679              * Theory:
 680              *  Allows the user to find out how full the RX Buffer is.
 681              *
 682              *******************************************************************************/
 683              uint8 UART_RS485_GetRxBufferSize(void)
 684                                                                      
 685              {
 686   1              uint8 size;
 687   1      
 688   1          #if (UART_RS485_RX_INTERRUPT_ENABLED)
 689   1      
 690   1              /* Protect variables that could change on interrupt */
 691   1              UART_RS485_DisableRxInt();
 692   1      
 693   1              if(UART_RS485_rxBufferRead == UART_RS485_rxBufferWrite)
 694   1              {
 695   2                  if(UART_RS485_rxBufferLoopDetect != 0u)
 696   2                  {
 697   3                      size = UART_RS485_RX_BUFFER_SIZE;
 698   3                  }
 699   2                  else
 700   2                  {
 701   3                      size = 0u;
 702   3                  }
 703   2              }
 704   1              else if(UART_RS485_rxBufferRead < UART_RS485_rxBufferWrite)
 705   1              {
 706   2                  size = (UART_RS485_rxBufferWrite - UART_RS485_rxBufferRead);
 707   2              }
 708   1              else
 709   1              {
 710   2                  size = (UART_RS485_RX_BUFFER_SIZE - UART_RS485_rxBufferRead) + UART_RS485_rxBufferWrite;
 711   2              }
 712   1      
 713   1              UART_RS485_EnableRxInt();
 714   1      
 715   1          #else
              
                      /* We can only know if there is data in the fifo. */
                      size = ((UART_RS485_RXSTATUS_REG & UART_RS485_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
              
                  #endif /* (UART_RS485_RX_INTERRUPT_ENABLED) */
 721   1      
 722   1              return(size);
 723   1          }
 724          
 725          
 726              /*******************************************************************************
 727              * Function Name: UART_RS485_ClearRxBuffer
 728              ********************************************************************************
 729              *
 730              * Summary:
 731              *  Clears the receiver memory buffer and hardware RX FIFO of all received data.
 732              *
 733              * Parameters:
 734              *  None.
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 13  

 735              *
 736              * Return:
 737              *  None.
 738              *
 739              * Global Variables:
 740              *  UART_RS485_rxBufferWrite - cleared to zero.
 741              *  UART_RS485_rxBufferRead - cleared to zero.
 742              *  UART_RS485_rxBufferLoopDetect - cleared to zero.
 743              *  UART_RS485_rxBufferOverflow - cleared to zero.
 744              *
 745              * Reentrant:
 746              *  No.
 747              *
 748              * Theory:
 749              *  Setting the pointers to zero makes the system believe there is no data to
 750              *  read and writing will resume at address 0 overwriting any data that may
 751              *  have remained in the RAM.
 752              *
 753              * Side Effects:
 754              *  Any received data not read from the RAM or FIFO buffer will be lost.
 755              *
 756              *******************************************************************************/
 757              void UART_RS485_ClearRxBuffer(void) 
 758              {
 759   1              uint8 enableInterrupts;
 760   1      
 761   1              /* Clear the HW FIFO */
 762   1              enableInterrupts = CyEnterCriticalSection();
 763   1              UART_RS485_RXDATA_AUX_CTL_REG |= (uint8)  UART_RS485_RX_FIFO_CLR;
 764   1              UART_RS485_RXDATA_AUX_CTL_REG &= (uint8) ~UART_RS485_RX_FIFO_CLR;
 765   1              CyExitCriticalSection(enableInterrupts);
 766   1      
 767   1          #if (UART_RS485_RX_INTERRUPT_ENABLED)
 768   1      
 769   1              /* Protect variables that could change on interrupt. */
 770   1              UART_RS485_DisableRxInt();
 771   1      
 772   1              UART_RS485_rxBufferRead = 0u;
 773   1              UART_RS485_rxBufferWrite = 0u;
 774   1              UART_RS485_rxBufferLoopDetect = 0u;
 775   1              UART_RS485_rxBufferOverflow = 0u;
 776   1      
 777   1              UART_RS485_EnableRxInt();
 778   1      
 779   1          #endif /* (UART_RS485_RX_INTERRUPT_ENABLED) */
 780   1      
 781   1          }
 782          
 783          
 784              /*******************************************************************************
 785              * Function Name: UART_RS485_SetRxAddressMode
 786              ********************************************************************************
 787              *
 788              * Summary:
 789              *  Sets the software controlled Addressing mode used by the RX portion of the
 790              *  UART.
 791              *
 792              * Parameters:
 793              *  addressMode: Enumerated value indicating the mode of RX addressing
 794              *  UART_RS485__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 795              *                                               detection
 796              *  UART_RS485__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 14  

 797              *                                               address detection
 798              *  UART_RS485__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 799              *                                               detection
 800              *  UART_RS485__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 801              *                                               address detection
 802              *  UART_RS485__B_UART__AM_NONE - No address detection
 803              *
 804              * Return:
 805              *  None.
 806              *
 807              * Global Variables:
 808              *  UART_RS485_rxAddressMode - the parameter stored in this variable for
 809              *   the farther usage in RX ISR.
 810              *  UART_RS485_rxAddressDetected - set to initial state (0).
 811              *
 812              *******************************************************************************/
 813              void UART_RS485_SetRxAddressMode(uint8 addressMode)
 814                                                                  
 815              {
 816   1              #if(UART_RS485_RXHW_ADDRESS_ENABLED)
                          #if(UART_RS485_CONTROL_REG_REMOVED)
                              if(0u != addressMode)
                              {
                                  /* Suppress compiler warning */
                              }
                          #else /* UART_RS485_CONTROL_REG_REMOVED */
                              uint8 tmpCtrl;
                              tmpCtrl = UART_RS485_CONTROL_REG & (uint8)~UART_RS485_CTRL_RXADDR_MODE_MASK;
                              tmpCtrl |= (uint8)(addressMode << UART_RS485_CTRL_RXADDR_MODE0_SHIFT);
                              UART_RS485_CONTROL_REG = tmpCtrl;
              
                              #if(UART_RS485_RX_INTERRUPT_ENABLED && \
                                 (UART_RS485_RXBUFFERSIZE > UART_RS485_FIFO_LENGTH) )
                                  UART_RS485_rxAddressMode = addressMode;
                                  UART_RS485_rxAddressDetected = 0u;
                              #endif /* End UART_RS485_RXBUFFERSIZE > UART_RS485_FIFO_LENGTH*/
                          #endif /* End UART_RS485_CONTROL_REG_REMOVED */
                      #else /* UART_RS485_RXHW_ADDRESS_ENABLED */
 835   1                  if(0u != addressMode)
 836   1                  {
 837   2                      /* Suppress compiler warning */
 838   2                  }
 839   1              #endif /* End UART_RS485_RXHW_ADDRESS_ENABLED */
 840   1          }
 841          
 842          
 843              /*******************************************************************************
 844              * Function Name: UART_RS485_SetRxAddress1
 845              ********************************************************************************
 846              *
 847              * Summary:
 848              *  Sets the first of two hardware-detectable receiver addresses.
 849              *
 850              * Parameters:
 851              *  address: Address #1 for hardware address detection.
 852              *
 853              * Return:
 854              *  None.
 855              *
 856              *******************************************************************************/
 857              void UART_RS485_SetRxAddress1(uint8 address) 
 858              {
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 15  

 859   1              UART_RS485_RXADDRESS1_REG = address;
 860   1          }
 861          
 862          
 863              /*******************************************************************************
 864              * Function Name: UART_RS485_SetRxAddress2
 865              ********************************************************************************
 866              *
 867              * Summary:
 868              *  Sets the second of two hardware-detectable receiver addresses.
 869              *
 870              * Parameters:
 871              *  address: Address #2 for hardware address detection.
 872              *
 873              * Return:
 874              *  None.
 875              *
 876              *******************************************************************************/
 877              void UART_RS485_SetRxAddress2(uint8 address) 
 878              {
 879   1              UART_RS485_RXADDRESS2_REG = address;
 880   1          }
 881          
 882          #endif  /* UART_RS485_RX_ENABLED || UART_RS485_HD_ENABLED*/
 883          
 884          
 885          #if( (UART_RS485_TX_ENABLED) || (UART_RS485_HD_ENABLED) )
 886              /*******************************************************************************
 887              * Function Name: UART_RS485_SetTxInterruptMode
 888              ********************************************************************************
 889              *
 890              * Summary:
 891              *  Configures the TX interrupt sources to be enabled, but does not enable the
 892              *  interrupt.
 893              *
 894              * Parameters:
 895              *  intSrc: Bit field containing the TX interrupt sources to enable
 896              *   UART_RS485_TX_STS_COMPLETE        Interrupt on TX byte complete
 897              *   UART_RS485_TX_STS_FIFO_EMPTY      Interrupt when TX FIFO is empty
 898              *   UART_RS485_TX_STS_FIFO_FULL       Interrupt when TX FIFO is full
 899              *   UART_RS485_TX_STS_FIFO_NOT_FULL   Interrupt when TX FIFO is not full
 900              *
 901              * Return:
 902              *  None.
 903              *
 904              * Theory:
 905              *  Enables the output of specific status bits to the interrupt controller
 906              *
 907              *******************************************************************************/
 908              void UART_RS485_SetTxInterruptMode(uint8 intSrc) 
 909              {
 910   1              UART_RS485_TXSTATUS_MASK_REG = intSrc;
 911   1          }
 912          
 913          
 914              /*******************************************************************************
 915              * Function Name: UART_RS485_WriteTxData
 916              ********************************************************************************
 917              *
 918              * Summary:
 919              *  Places a byte of data into the transmit buffer to be sent when the bus is
 920              *  available without checking the TX status register. You must check status
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 16  

 921              *  separately.
 922              *
 923              * Parameters:
 924              *  txDataByte: data byte
 925              *
 926              * Return:
 927              * None.
 928              *
 929              * Global Variables:
 930              *  UART_RS485_txBuffer - RAM buffer pointer for save data for transmission
 931              *  UART_RS485_txBufferWrite - cyclic index for write to txBuffer,
 932              *    incremented after each byte saved to buffer.
 933              *  UART_RS485_txBufferRead - cyclic index for read from txBuffer,
 934              *    checked to identify the condition to write to FIFO directly or to TX buffer
 935              *  UART_RS485_initVar - checked to identify that the component has been
 936              *    initialized.
 937              *
 938              * Reentrant:
 939              *  No.
 940              *
 941              *******************************************************************************/
 942              void UART_RS485_WriteTxData(uint8 txDataByte) 
 943              {
 944   1              /* If not Initialized then skip this function*/
 945   1              if(UART_RS485_initVar != 0u)
 946   1              {
 947   2              #if (UART_RS485_TX_INTERRUPT_ENABLED)
              
                          /* Protect variables that could change on interrupt. */
                          UART_RS485_DisableTxInt();
              
                          if( (UART_RS485_txBufferRead == UART_RS485_txBufferWrite) &&
                              ((UART_RS485_TXSTATUS_REG & UART_RS485_TX_STS_FIFO_FULL) == 0u) )
                          {
                              /* Add directly to the FIFO. */
                              UART_RS485_TXDATA_REG = txDataByte;
                          }
                          else
                          {
                              if(UART_RS485_txBufferWrite >= UART_RS485_TX_BUFFER_SIZE)
                              {
                                  UART_RS485_txBufferWrite = 0u;
                              }
              
                              UART_RS485_txBuffer[UART_RS485_txBufferWrite] = txDataByte;
              
                              /* Add to the software buffer. */
                              UART_RS485_txBufferWrite++;
                          }
              
                          UART_RS485_EnableTxInt();
              
                      #else
 974   2      
 975   2                  /* Add directly to the FIFO. */
 976   2                  UART_RS485_TXDATA_REG = txDataByte;
 977   2      
 978   2              #endif /*(UART_RS485_TX_INTERRUPT_ENABLED) */
 979   2              }
 980   1          }
 981          
 982          
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 17  

 983              /*******************************************************************************
 984              * Function Name: UART_RS485_ReadTxStatus
 985              ********************************************************************************
 986              *
 987              * Summary:
 988              *  Reads the status register for the TX portion of the UART.
 989              *
 990              * Parameters:
 991              *  None.
 992              *
 993              * Return:
 994              *  Contents of the status register
 995              *
 996              * Theory:
 997              *  This function reads the TX status register, which is cleared on read.
 998              *  It is up to the user to handle all bits in this return value accordingly,
 999              *  even if the bit was not enabled as an interrupt source the event happened
1000              *  and must be handled accordingly.
1001              *
1002              *******************************************************************************/
1003              uint8 UART_RS485_ReadTxStatus(void) 
1004              {
1005   1              return(UART_RS485_TXSTATUS_REG);
1006   1          }
1007          
1008          
1009              /*******************************************************************************
1010              * Function Name: UART_RS485_PutChar
1011              ********************************************************************************
1012              *
1013              * Summary:
1014              *  Puts a byte of data into the transmit buffer to be sent when the bus is
1015              *  available. This is a blocking API that waits until the TX buffer has room to
1016              *  hold the data.
1017              *
1018              * Parameters:
1019              *  txDataByte: Byte containing the data to transmit
1020              *
1021              * Return:
1022              *  None.
1023              *
1024              * Global Variables:
1025              *  UART_RS485_txBuffer - RAM buffer pointer for save data for transmission
1026              *  UART_RS485_txBufferWrite - cyclic index for write to txBuffer,
1027              *     checked to identify free space in txBuffer and incremented after each byte
1028              *     saved to buffer.
1029              *  UART_RS485_txBufferRead - cyclic index for read from txBuffer,
1030              *     checked to identify free space in txBuffer.
1031              *  UART_RS485_initVar - checked to identify that the component has been
1032              *     initialized.
1033              *
1034              * Reentrant:
1035              *  No.
1036              *
1037              * Theory:
1038              *  Allows the user to transmit any byte of data in a single transfer
1039              *
1040              *******************************************************************************/
1041              void UART_RS485_PutChar(uint8 txDataByte) 
1042              {
1043   1          #if (UART_RS485_TX_INTERRUPT_ENABLED)
                      /* The temporary output pointer is used since it takes two instructions
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 18  

                      *  to increment with a wrap, and we can't risk doing that with the real
                      *  pointer and getting an interrupt in between instructions.
                      */
                      uint8 locTxBufferWrite;
                      uint8 locTxBufferRead;
              
                      do
                      { /* Block if software buffer is full, so we don't overwrite. */
              
                      #if ((UART_RS485_TX_BUFFER_SIZE > UART_RS485_MAX_BYTE_VALUE) && (CY_PSOC3))
                          /* Disable TX interrupt to protect variables from modification */
                          UART_RS485_DisableTxInt();
                      #endif /* (UART_RS485_TX_BUFFER_SIZE > UART_RS485_MAX_BYTE_VALUE) && (CY_PSOC3) */
              
                          locTxBufferWrite = UART_RS485_txBufferWrite;
                          locTxBufferRead  = UART_RS485_txBufferRead;
              
                      #if ((UART_RS485_TX_BUFFER_SIZE > UART_RS485_MAX_BYTE_VALUE) && (CY_PSOC3))
                          /* Enable interrupt to continue transmission */
                          UART_RS485_EnableTxInt();
                      #endif /* (UART_RS485_TX_BUFFER_SIZE > UART_RS485_MAX_BYTE_VALUE) && (CY_PSOC3) */
                      }
                      while( (locTxBufferWrite < locTxBufferRead) ? (locTxBufferWrite == (locTxBufferRead - 1u)) :
                                              ((locTxBufferWrite - locTxBufferRead) ==
                                              (uint8)(UART_RS485_TX_BUFFER_SIZE - 1u)) );
              
                      if( (locTxBufferRead == locTxBufferWrite) &&
                          ((UART_RS485_TXSTATUS_REG & UART_RS485_TX_STS_FIFO_FULL) == 0u) )
                      {
                          /* Add directly to the FIFO */
                          UART_RS485_TXDATA_REG = txDataByte;
                      }
                      else
                      {
                          if(locTxBufferWrite >= UART_RS485_TX_BUFFER_SIZE)
                          {
                              locTxBufferWrite = 0u;
                          }
                          /* Add to the software buffer. */
                          UART_RS485_txBuffer[locTxBufferWrite] = txDataByte;
                          locTxBufferWrite++;
              
                          /* Finally, update the real output pointer */
                      #if ((UART_RS485_TX_BUFFER_SIZE > UART_RS485_MAX_BYTE_VALUE) && (CY_PSOC3))
                          UART_RS485_DisableTxInt();
                      #endif /* (UART_RS485_TX_BUFFER_SIZE > UART_RS485_MAX_BYTE_VALUE) && (CY_PSOC3) */
              
                          UART_RS485_txBufferWrite = locTxBufferWrite;
              
                      #if ((UART_RS485_TX_BUFFER_SIZE > UART_RS485_MAX_BYTE_VALUE) && (CY_PSOC3))
                          UART_RS485_EnableTxInt();
                      #endif /* (UART_RS485_TX_BUFFER_SIZE > UART_RS485_MAX_BYTE_VALUE) && (CY_PSOC3) */
              
                          if(0u != (UART_RS485_TXSTATUS_REG & UART_RS485_TX_STS_FIFO_EMPTY))
                          {
                              /* Trigger TX interrupt to send software buffer */
                              UART_RS485_SetPendingTxInt();
                          }
                      }
              
                  #else
1106   1      
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 19  

1107   1              while((UART_RS485_TXSTATUS_REG & UART_RS485_TX_STS_FIFO_FULL) != 0u)
1108   1              {
1109   2                  /* Wait for room in the FIFO */
1110   2              }
1111   1      
1112   1              /* Add directly to the FIFO */
1113   1              UART_RS485_TXDATA_REG = txDataByte;
1114   1      
1115   1          #endif /* UART_RS485_TX_INTERRUPT_ENABLED */
1116   1          }
1117          
1118          
1119              /*******************************************************************************
1120              * Function Name: UART_RS485_PutString
1121              ********************************************************************************
1122              *
1123              * Summary:
1124              *  Sends a NULL terminated string to the TX buffer for transmission.
1125              *
1126              * Parameters:
1127              *  string[]: Pointer to the null terminated string array residing in RAM or ROM
1128              *
1129              * Return:
1130              *  None.
1131              *
1132              * Global Variables:
1133              *  UART_RS485_initVar - checked to identify that the component has been
1134              *     initialized.
1135              *
1136              * Reentrant:
1137              *  No.
1138              *
1139              * Theory:
1140              *  If there is not enough memory in the TX buffer for the entire string, this
1141              *  function blocks until the last character of the string is loaded into the
1142              *  TX buffer.
1143              *
1144              *******************************************************************************/
1145              void UART_RS485_PutString(const char8 string[]) 
1146              {
1147   1              uint16 bufIndex = 0u;
1148   1      
1149   1              /* If not Initialized then skip this function */
1150   1              if(UART_RS485_initVar != 0u)
1151   1              {
1152   2                  /* This is a blocking function, it will not exit until all data is sent */
1153   2                  while(string[bufIndex] != (char8) 0)
1154   2                  {
1155   3                      UART_RS485_PutChar((uint8)string[bufIndex]);
1156   3                      bufIndex++;
1157   3                  }
1158   2              }
1159   1          }
1160          
1161          
1162              /*******************************************************************************
1163              * Function Name: UART_RS485_PutArray
1164              ********************************************************************************
1165              *
1166              * Summary:
1167              *  Places N bytes of data from a memory array into the TX buffer for
1168              *  transmission.
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 20  

1169              *
1170              * Parameters:
1171              *  string[]: Address of the memory array residing in RAM or ROM.
1172              *  byteCount: Number of bytes to be transmitted. The type depends on TX Buffer
1173              *             Size parameter.
1174              *
1175              * Return:
1176              *  None.
1177              *
1178              * Global Variables:
1179              *  UART_RS485_initVar - checked to identify that the component has been
1180              *     initialized.
1181              *
1182              * Reentrant:
1183              *  No.
1184              *
1185              * Theory:
1186              *  If there is not enough memory in the TX buffer for the entire string, this
1187              *  function blocks until the last character of the string is loaded into the
1188              *  TX buffer.
1189              *
1190              *******************************************************************************/
1191              void UART_RS485_PutArray(const uint8 string[], uint8 byteCount)
1192                                                                              
1193              {
1194   1              uint8 bufIndex = 0u;
1195   1      
1196   1              /* If not Initialized then skip this function */
1197   1              if(UART_RS485_initVar != 0u)
1198   1              {
1199   2                  while(bufIndex < byteCount)
1200   2                  {
1201   3                      UART_RS485_PutChar(string[bufIndex]);
1202   3                      bufIndex++;
1203   3                  }
1204   2              }
1205   1          }
1206          
1207          
1208              /*******************************************************************************
1209              * Function Name: UART_RS485_PutCRLF
1210              ********************************************************************************
1211              *
1212              * Summary:
1213              *  Writes a byte of data followed by a carriage return (0x0D) and line feed
1214              *  (0x0A) to the transmit buffer.
1215              *
1216              * Parameters:
1217              *  txDataByte: Data byte to transmit before the carriage return and line feed.
1218              *
1219              * Return:
1220              *  None.
1221              *
1222              * Global Variables:
1223              *  UART_RS485_initVar - checked to identify that the component has been
1224              *     initialized.
1225              *
1226              * Reentrant:
1227              *  No.
1228              *
1229              *******************************************************************************/
1230              void UART_RS485_PutCRLF(uint8 txDataByte) 
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 21  

1231              {
1232   1              /* If not Initialized then skip this function */
1233   1              if(UART_RS485_initVar != 0u)
1234   1              {
1235   2                  UART_RS485_PutChar(txDataByte);
1236   2                  UART_RS485_PutChar(0x0Du);
1237   2                  UART_RS485_PutChar(0x0Au);
1238   2              }
1239   1          }
1240          
1241          
1242              /*******************************************************************************
1243              * Function Name: UART_RS485_GetTxBufferSize
1244              ********************************************************************************
1245              *
1246              * Summary:
1247              *  Returns the number of bytes in the TX buffer which are waiting to be 
1248              *  transmitted.
1249              *  * TX software buffer is disabled (TX Buffer Size parameter is equal to 4): 
1250              *    returns 0 for empty TX FIFO, 1 for not full TX FIFO or 4 for full TX FIFO.
1251              *  * TX software buffer is enabled: returns the number of bytes in the TX 
1252              *    software buffer which are waiting to be transmitted. Bytes available in the
1253              *    TX FIFO do not count.
1254              *
1255              * Parameters:
1256              *  None.
1257              *
1258              * Return:
1259              *  Number of bytes used in the TX buffer. Return value type depends on the TX 
1260              *  Buffer Size parameter.
1261              *
1262              * Global Variables:
1263              *  UART_RS485_txBufferWrite - used to calculate left space.
1264              *  UART_RS485_txBufferRead - used to calculate left space.
1265              *
1266              * Reentrant:
1267              *  No.
1268              *
1269              * Theory:
1270              *  Allows the user to find out how full the TX Buffer is.
1271              *
1272              *******************************************************************************/
1273              uint8 UART_RS485_GetTxBufferSize(void)
1274                                                                      
1275              {
1276   1              uint8 size;
1277   1      
1278   1          #if (UART_RS485_TX_INTERRUPT_ENABLED)
              
                      /* Protect variables that could change on interrupt. */
                      UART_RS485_DisableTxInt();
              
                      if(UART_RS485_txBufferRead == UART_RS485_txBufferWrite)
                      {
                          size = 0u;
                      }
                      else if(UART_RS485_txBufferRead < UART_RS485_txBufferWrite)
                      {
                          size = (UART_RS485_txBufferWrite - UART_RS485_txBufferRead);
                      }
                      else
                      {
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 22  

                          size = (UART_RS485_TX_BUFFER_SIZE - UART_RS485_txBufferRead) +
                                  UART_RS485_txBufferWrite;
                      }
              
                      UART_RS485_EnableTxInt();
              
                  #else
1300   1      
1301   1              size = UART_RS485_TXSTATUS_REG;
1302   1      
1303   1              /* Is the fifo is full. */
1304   1              if((size & UART_RS485_TX_STS_FIFO_FULL) != 0u)
1305   1              {
1306   2                  size = UART_RS485_FIFO_LENGTH;
1307   2              }
1308   1              else if((size & UART_RS485_TX_STS_FIFO_EMPTY) != 0u)
1309   1              {
1310   2                  size = 0u;
1311   2              }
1312   1              else
1313   1              {
1314   2                  /* We only know there is data in the fifo. */
1315   2                  size = 1u;
1316   2              }
1317   1      
1318   1          #endif /* (UART_RS485_TX_INTERRUPT_ENABLED) */
1319   1      
1320   1          return(size);
1321   1          }
1322          
1323          
1324              /*******************************************************************************
1325              * Function Name: UART_RS485_ClearTxBuffer
1326              ********************************************************************************
1327              *
1328              * Summary:
1329              *  Clears all data from the TX buffer and hardware TX FIFO.
1330              *
1331              * Parameters:
1332              *  None.
1333              *
1334              * Return:
1335              *  None.
1336              *
1337              * Global Variables:
1338              *  UART_RS485_txBufferWrite - cleared to zero.
1339              *  UART_RS485_txBufferRead - cleared to zero.
1340              *
1341              * Reentrant:
1342              *  No.
1343              *
1344              * Theory:
1345              *  Setting the pointers to zero makes the system believe there is no data to
1346              *  read and writing will resume at address 0 overwriting any data that may have
1347              *  remained in the RAM.
1348              *
1349              * Side Effects:
1350              *  Data waiting in the transmit buffer is not sent; a byte that is currently
1351              *  transmitting finishes transmitting.
1352              *
1353              *******************************************************************************/
1354              void UART_RS485_ClearTxBuffer(void) 
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 23  

1355              {
1356   1              uint8 enableInterrupts;
1357   1      
1358   1              enableInterrupts = CyEnterCriticalSection();
1359   1              /* Clear the HW FIFO */
1360   1              UART_RS485_TXDATA_AUX_CTL_REG |= (uint8)  UART_RS485_TX_FIFO_CLR;
1361   1              UART_RS485_TXDATA_AUX_CTL_REG &= (uint8) ~UART_RS485_TX_FIFO_CLR;
1362   1              CyExitCriticalSection(enableInterrupts);
1363   1      
1364   1          #if (UART_RS485_TX_INTERRUPT_ENABLED)
              
                      /* Protect variables that could change on interrupt. */
                      UART_RS485_DisableTxInt();
              
                      UART_RS485_txBufferRead = 0u;
                      UART_RS485_txBufferWrite = 0u;
              
                      /* Enable Tx interrupt. */
                      UART_RS485_EnableTxInt();
              
                  #endif /* (UART_RS485_TX_INTERRUPT_ENABLED) */
1376   1          }
1377          
1378          
1379              /*******************************************************************************
1380              * Function Name: UART_RS485_SendBreak
1381              ********************************************************************************
1382              *
1383              * Summary:
1384              *  Transmits a break signal on the bus.
1385              *
1386              * Parameters:
1387              *  uint8 retMode:  Send Break return mode. See the following table for options.
1388              *   UART_RS485_SEND_BREAK - Initialize registers for break, send the Break
1389              *       signal and return immediately.
1390              *   UART_RS485_WAIT_FOR_COMPLETE_REINIT - Wait until break transmission is
1391              *       complete, reinitialize registers to normal transmission mode then return
1392              *   UART_RS485_REINIT - Reinitialize registers to normal transmission mode
1393              *       then return.
1394              *   UART_RS485_SEND_WAIT_REINIT - Performs both options: 
1395              *      UART_RS485_SEND_BREAK and UART_RS485_WAIT_FOR_COMPLETE_REINIT.
1396              *      This option is recommended for most cases.
1397              *
1398              * Return:
1399              *  None.
1400              *
1401              * Global Variables:
1402              *  UART_RS485_initVar - checked to identify that the component has been
1403              *     initialized.
1404              *  txPeriod - static variable, used for keeping TX period configuration.
1405              *
1406              * Reentrant:
1407              *  No.
1408              *
1409              * Theory:
1410              *  SendBreak function initializes registers to send 13-bit break signal. It is
1411              *  important to return the registers configuration to normal for continue 8-bit
1412              *  operation.
1413              *  There are 3 variants for this API usage:
1414              *  1) SendBreak(3) - function will send the Break signal and take care on the
1415              *     configuration returning. Function will block CPU until transmission
1416              *     complete.
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 24  

1417              *  2) User may want to use blocking time if UART configured to the low speed
1418              *     operation
1419              *     Example for this case:
1420              *     SendBreak(0);     - initialize Break signal transmission
1421              *         Add your code here to use CPU time
1422              *     SendBreak(1);     - complete Break operation
1423              *  3) Same to 2) but user may want to initialize and use the interrupt to
1424              *     complete break operation.
1425              *     Example for this case:
1426              *     Initialize TX interrupt with "TX - On TX Complete" parameter
1427              *     SendBreak(0);     - initialize Break signal transmission
1428              *         Add your code here to use CPU time
1429              *     When interrupt appear with UART_RS485_TX_STS_COMPLETE status:
1430              *     SendBreak(2);     - complete Break operation
1431              *
1432              * Side Effects:
1433              *  The UART_RS485_SendBreak() function initializes registers to send a
1434              *  break signal.
1435              *  Break signal length depends on the break signal bits configuration.
1436              *  The register configuration should be reinitialized before normal 8-bit
1437              *  communication can continue.
1438              *
1439              *******************************************************************************/
1440              void UART_RS485_SendBreak(uint8 retMode) 
1441              {
1442   1      
1443   1              /* If not Initialized then skip this function*/
1444   1              if(UART_RS485_initVar != 0u)
1445   1              {
1446   2                  /* Set the Counter to 13-bits and transmit a 00 byte */
1447   2                  /* When that is done then reset the counter value back */
1448   2                  uint8 tmpStat;
1449   2      
1450   2              #if(UART_RS485_HD_ENABLED) /* Half Duplex mode*/
              
                          if( (retMode == UART_RS485_SEND_BREAK) ||
                              (retMode == UART_RS485_SEND_WAIT_REINIT ) )
                          {
                              /* CTRL_HD_SEND_BREAK - sends break bits in HD mode */
                              UART_RS485_WriteControlRegister(UART_RS485_ReadControlRegister() |
                                                                    UART_RS485_CTRL_HD_SEND_BREAK);
                              /* Send zeros */
                              UART_RS485_TXDATA_REG = 0u;
              
                              do /* Wait until transmit starts */
                              {
                                  tmpStat = UART_RS485_TXSTATUS_REG;
                              }
                              while((tmpStat & UART_RS485_TX_STS_FIFO_EMPTY) != 0u);
                          }
              
                          if( (retMode == UART_RS485_WAIT_FOR_COMPLETE_REINIT) ||
                              (retMode == UART_RS485_SEND_WAIT_REINIT) )
                          {
                              do /* Wait until transmit complete */
                              {
                                  tmpStat = UART_RS485_TXSTATUS_REG;
                              }
                              while(((uint8)~tmpStat & UART_RS485_TX_STS_COMPLETE) != 0u);
                          }
              
                          if( (retMode == UART_RS485_WAIT_FOR_COMPLETE_REINIT) ||
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 25  

                              (retMode == UART_RS485_REINIT) ||
                              (retMode == UART_RS485_SEND_WAIT_REINIT) )
                          {
                              UART_RS485_WriteControlRegister(UART_RS485_ReadControlRegister() &
                                                            (uint8)~UART_RS485_CTRL_HD_SEND_BREAK);
                          }
              
                      #else /* UART_RS485_HD_ENABLED Full Duplex mode */
1487   2      
1488   2                  static uint8 txPeriod;
1489   2      
1490   2                  if( (retMode == UART_RS485_SEND_BREAK) ||
1491   2                      (retMode == UART_RS485_SEND_WAIT_REINIT) )
1492   2                  {
1493   3                      /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode */
1494   3                      #if( (UART_RS485_PARITY_TYPE != UART_RS485__B_UART__NONE_REVB) || \
1495   3                                          (UART_RS485_PARITY_TYPE_SW != 0u) )
                                  UART_RS485_WriteControlRegister(UART_RS485_ReadControlRegister() |
                                                                        UART_RS485_CTRL_HD_SEND_BREAK);
                              #endif /* End UART_RS485_PARITY_TYPE != UART_RS485__B_UART__NONE_REVB  */
1499   3      
1500   3                      #if(UART_RS485_TXCLKGEN_DP)
1501   3                          txPeriod = UART_RS485_TXBITCLKTX_COMPLETE_REG;
1502   3                          UART_RS485_TXBITCLKTX_COMPLETE_REG = UART_RS485_TXBITCTR_BREAKBITS;
1503   3                      #else
                                  txPeriod = UART_RS485_TXBITCTR_PERIOD_REG;
                                  UART_RS485_TXBITCTR_PERIOD_REG = UART_RS485_TXBITCTR_BREAKBITS8X;
                              #endif /* End UART_RS485_TXCLKGEN_DP */
1507   3      
1508   3                      /* Send zeros */
1509   3                      UART_RS485_TXDATA_REG = 0u;
1510   3      
1511   3                      do /* Wait until transmit starts */
1512   3                      {
1513   4                          tmpStat = UART_RS485_TXSTATUS_REG;
1514   4                      }
1515   3                      while((tmpStat & UART_RS485_TX_STS_FIFO_EMPTY) != 0u);
1516   3                  }
1517   2      
1518   2                  if( (retMode == UART_RS485_WAIT_FOR_COMPLETE_REINIT) ||
1519   2                      (retMode == UART_RS485_SEND_WAIT_REINIT) )
1520   2                  {
1521   3                      do /* Wait until transmit complete */
1522   3                      {
1523   4                          tmpStat = UART_RS485_TXSTATUS_REG;
1524   4                      }
1525   3                      while(((uint8)~tmpStat & UART_RS485_TX_STS_COMPLETE) != 0u);
1526   3                  }
1527   2      
1528   2                  if( (retMode == UART_RS485_WAIT_FOR_COMPLETE_REINIT) ||
1529   2                      (retMode == UART_RS485_REINIT) ||
1530   2                      (retMode == UART_RS485_SEND_WAIT_REINIT) )
1531   2                  {
1532   3      
1533   3                  #if(UART_RS485_TXCLKGEN_DP)
1534   3                      UART_RS485_TXBITCLKTX_COMPLETE_REG = txPeriod;
1535   3                  #else
                              UART_RS485_TXBITCTR_PERIOD_REG = txPeriod;
                          #endif /* End UART_RS485_TXCLKGEN_DP */
1538   3      
1539   3                  #if( (UART_RS485_PARITY_TYPE != UART_RS485__B_UART__NONE_REVB) || \
1540   3                       (UART_RS485_PARITY_TYPE_SW != 0u) )
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 26  

                              UART_RS485_WriteControlRegister(UART_RS485_ReadControlRegister() &
                                                                    (uint8) ~UART_RS485_CTRL_HD_SEND_BREAK);
                          #endif /* End UART_RS485_PARITY_TYPE != NONE */
1544   3                  }
1545   2              #endif    /* End UART_RS485_HD_ENABLED */
1546   2              }
1547   1          }
1548          
1549          
1550              /*******************************************************************************
1551              * Function Name: UART_RS485_SetTxAddressMode
1552              ********************************************************************************
1553              *
1554              * Summary:
1555              *  Configures the transmitter to signal the next bytes is address or data.
1556              *
1557              * Parameters:
1558              *  addressMode: 
1559              *       UART_RS485_SET_SPACE - Configure the transmitter to send the next
1560              *                                    byte as a data.
1561              *       UART_RS485_SET_MARK  - Configure the transmitter to send the next
1562              *                                    byte as an address.
1563              *
1564              * Return:
1565              *  None.
1566              *
1567              * Side Effects:
1568              *  This function sets and clears UART_RS485_CTRL_MARK bit in the Control
1569              *  register.
1570              *
1571              *******************************************************************************/
1572              void UART_RS485_SetTxAddressMode(uint8 addressMode) 
1573              {
1574   1              /* Mark/Space sending enable */
1575   1              if(addressMode != 0u)
1576   1              {
1577   2              #if( UART_RS485_CONTROL_REG_REMOVED == 0u )
                          UART_RS485_WriteControlRegister(UART_RS485_ReadControlRegister() |
                                                                UART_RS485_CTRL_MARK);
                      #endif /* End UART_RS485_CONTROL_REG_REMOVED == 0u */
1581   2              }
1582   1              else
1583   1              {
1584   2              #if( UART_RS485_CONTROL_REG_REMOVED == 0u )
                          UART_RS485_WriteControlRegister(UART_RS485_ReadControlRegister() &
                                                                (uint8) ~UART_RS485_CTRL_MARK);
                      #endif /* End UART_RS485_CONTROL_REG_REMOVED == 0u */
1588   2              }
1589   1          }
1590          
1591          #endif  /* EndUART_RS485_TX_ENABLED */
1592          
1593          #if(UART_RS485_HD_ENABLED)
              
              
                  /*******************************************************************************
                  * Function Name: UART_RS485_LoadRxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Loads the receiver configuration in half duplex mode. After calling this
                  *  function, the UART is ready to receive data.
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 27  

                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Side Effects:
                  *  Valid only in half duplex mode. You must make sure that the previous
                  *  transaction is complete and it is safe to unload the transmitter
                  *  configuration.
                  *
                  *******************************************************************************/
                  void UART_RS485_LoadRxConfig(void) 
                  {
                      UART_RS485_WriteControlRegister(UART_RS485_ReadControlRegister() &
                                                              (uint8)~UART_RS485_CTRL_HD_SEND);
                      UART_RS485_RXBITCTR_PERIOD_REG = UART_RS485_HD_RXBITCTR_INIT;
              
                  #if (UART_RS485_RX_INTERRUPT_ENABLED)
                      /* Enable RX interrupt after set RX configuration */
                      UART_RS485_SetRxInterruptMode(UART_RS485_INIT_RX_INTERRUPTS_MASK);
                  #endif /* (UART_RS485_RX_INTERRUPT_ENABLED) */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_RS485_LoadTxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Loads the transmitter configuration in half duplex mode. After calling this
                  *  function, the UART is ready to transmit data.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Side Effects:
                  *  Valid only in half duplex mode. You must make sure that the previous
                  *  transaction is complete and it is safe to unload the receiver configuration.
                  *
                  *******************************************************************************/
                  void UART_RS485_LoadTxConfig(void) 
                  {
                  #if (UART_RS485_RX_INTERRUPT_ENABLED)
                      /* Disable RX interrupts before set TX configuration */
                      UART_RS485_SetRxInterruptMode(0u);
                  #endif /* (UART_RS485_RX_INTERRUPT_ENABLED) */
              
                      UART_RS485_WriteControlRegister(UART_RS485_ReadControlRegister() | UART_RS485_CTRL_HD_SEND);
                      UART_RS485_RXBITCTR_PERIOD_REG = UART_RS485_HD_TXBITCTR_INIT;
                  }
              
              #endif  /* UART_RS485_HD_ENABLED */
1660          
1661          
1662          /* [] END OF FILE */
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 28  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION UART_RS485_Start (BEGIN)
                                           ; SOURCE LINE # 76
                                           ; SOURCE LINE # 77
                                           ; SOURCE LINE # 79
0000 900000      R     MOV     DPTR,#UART_RS485_initVar
0003 E0                MOVX    A,@DPTR
0004 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 80
                                           ; SOURCE LINE # 81
0006 120000      R     LCALL   UART_RS485_Init
                                           ; SOURCE LINE # 82
0009 900000      R     MOV     DPTR,#UART_RS485_initVar
000C 7401              MOV     A,#01H
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 83
000F         ?C0001:
                                           ; SOURCE LINE # 85
000F 120000      R     LCALL   UART_RS485_Enable
                                           ; SOURCE LINE # 86
0012 22                RET     
             ; FUNCTION UART_RS485_Start (END)

             ; FUNCTION UART_RS485_Init (BEGIN)
                                           ; SOURCE LINE # 106
                                           ; SOURCE LINE # 107
                                           ; SOURCE LINE # 112
0000 7C00        E     MOV     R4,#HIGH UART_RS485_RXISR
0002 7D00        E     MOV     R5,#LOW UART_RS485_RXISR
0004 7F01              MOV     R7,#01H
0006 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 113
0009 7D07              MOV     R5,#07H
000B 7F01              MOV     R7,#01H
000D 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 114
0010 E4                CLR     A
0011 900000      R     MOV     DPTR,#UART_RS485_errorStatus
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 124
0015 906587            MOV     DPTR,#06587H
0018 7469              MOV     A,#069H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 126
001B 906487            MOV     DPTR,#06487H
001E 7420              MOV     A,#020H
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 138
0021 906422            MOV     DPTR,#06422H
0024 7406              MOV     A,#06H
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 139
0027 906432            MOV     DPTR,#06432H
002A 7447              MOV     A,#047H
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 150
002D 906486            MOV     DPTR,#06486H
0030 E4                CLR     A
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 160
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 29  

0032 22                RET     
             ; FUNCTION UART_RS485_Init (END)

             ; FUNCTION UART_RS485_Enable (BEGIN)
                                           ; SOURCE LINE # 183
                                           ; SOURCE LINE # 184
                                           ; SOURCE LINE # 186
0000 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'enableInterrupts' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 190
0003 906597            MOV     DPTR,#06597H
0006 E0                MOVX    A,@DPTR
0007 4420              ORL     A,#020H
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 193
000A 906497            MOV     DPTR,#06497H
000D E0                MOVX    A,@DPTR
000E 4410              ORL     A,#010H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 196
0011 9044C0            MOV     DPTR,#044C0H
0014 7402              MOV     A,#02H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 211
0017 906496            MOV     DPTR,#06496H
001A E0                MOVX    A,@DPTR
001B 4410              ORL     A,#010H
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 222
001E 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 223
0021 22                RET     
             ; FUNCTION UART_RS485_Enable (END)

             ; FUNCTION UART_RS485_Stop (BEGIN)
                                           ; SOURCE LINE # 240
                                           ; SOURCE LINE # 241
                                           ; SOURCE LINE # 243
0000 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'enableInterrupts' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 247
0003 906597            MOV     DPTR,#06597H
0006 E0                MOVX    A,@DPTR
0007 54DF              ANL     A,#0DFH
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 262
000A 906497            MOV     DPTR,#06497H
000D E0                MOVX    A,@DPTR
000E 54EF              ANL     A,#0EFH
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 265
0011 9044C8            MOV     DPTR,#044C8H
0014 7402              MOV     A,#02H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 270
0017 906496            MOV     DPTR,#06496H
001A E0                MOVX    A,@DPTR
001B 54EF              ANL     A,#0EFH
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 277
001E 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 278
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 30  

0021 22                RET     
             ; FUNCTION UART_RS485_Stop (END)

             ; FUNCTION UART_RS485_ReadControlRegister (BEGIN)
                                           ; SOURCE LINE # 295
                                           ; SOURCE LINE # 296
                                           ; SOURCE LINE # 298
0000 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 302
0002         ?C0006:
0002 22                RET     
             ; FUNCTION UART_RS485_ReadControlRegister (END)

             ; FUNCTION _UART_RS485_WriteControlRegister (BEGIN)
                                           ; SOURCE LINE # 319
0000 900000      R     MOV     DPTR,#control
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 320
                                           ; SOURCE LINE # 322
                                           ; SOURCE LINE # 323
                                           ; SOURCE LINE # 325
                                           ; SOURCE LINE # 329
0005         ?C0008:
0005 22                RET     
             ; FUNCTION _UART_RS485_WriteControlRegister (END)

             ; FUNCTION _UART_RS485_SetRxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 359
;---- Variable 'intSrc' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 360
                                           ; SOURCE LINE # 361
0000 906487            MOV     DPTR,#06487H
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 362
0005 22                RET     
             ; FUNCTION _UART_RS485_SetRxInterruptMode (END)

             ; FUNCTION UART_RS485_ReadRxData (BEGIN)
                                           ; SOURCE LINE # 392
;---- Variable 'rxData' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 393
                                           ; SOURCE LINE # 402
0000 9044C8            MOV     DPTR,#044C8H
0003 7402              MOV     A,#02H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 404
0006 900000      R     MOV     DPTR,#UART_RS485_rxBufferRead
0009 E0                MOVX    A,@DPTR
000A FE                MOV     R6,A
;---- Variable 'locRxBufferRead' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 405
000B 900000      R     MOV     DPTR,#UART_RS485_rxBufferWrite
000E E0                MOVX    A,@DPTR
000F FD                MOV     R5,A
;---- Variable 'locRxBufferWrite' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 407
0010 900000      R     MOV     DPTR,#UART_RS485_rxBufferLoopDetect
0013 E0                MOVX    A,@DPTR
0014 7004              JNZ     ?C0011
0016 EE                MOV     A,R6
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 31  

0017 6D                XRL     A,R5
0018 6024              JZ      ?C0010
001A         ?C0011:
                                           ; SOURCE LINE # 408
                                           ; SOURCE LINE # 409
001A 7400        R     MOV     A,#LOW UART_RS485_rxBuffer
001C 2E                ADD     A,R6
001D F582              MOV     DPL,A
001F E4                CLR     A
0020 3400        R     ADDC    A,#HIGH UART_RS485_rxBuffer
0022 F583              MOV     DPH,A
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
                                           ; SOURCE LINE # 410
0026 0E                INC     R6
                                           ; SOURCE LINE # 412
0027 EE                MOV     A,R6
0028 C3                CLR     C
0029 9420              SUBB    A,#020H
002B 4002              JC      ?C0012
                                           ; SOURCE LINE # 413
                                           ; SOURCE LINE # 414
002D E4                CLR     A
002E FE                MOV     R6,A
                                           ; SOURCE LINE # 415
002F         ?C0012:
                                           ; SOURCE LINE # 417
002F 900000      R     MOV     DPTR,#UART_RS485_rxBufferRead
0032 EE                MOV     A,R6
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 419
0034 900000      R     MOV     DPTR,#UART_RS485_rxBufferLoopDetect
0037 E0                MOVX    A,@DPTR
0038 6009              JZ      ?C0014
                                           ; SOURCE LINE # 420
                                           ; SOURCE LINE # 421
003A E4                CLR     A
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 436
                                           ; SOURCE LINE # 437
003C 8005              SJMP    ?C0014
003E         ?C0010:
                                           ; SOURCE LINE # 439
                                           ; SOURCE LINE # 440
003E 906547            MOV     DPTR,#06547H
0041 E0                MOVX    A,@DPTR
0042 FF                MOV     R7,A
                                           ; SOURCE LINE # 441
0043         ?C0014:
                                           ; SOURCE LINE # 443
0043 9044C0            MOV     DPTR,#044C0H
0046 7402              MOV     A,#02H
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 452
                                           ; SOURCE LINE # 453
0049         ?C0015:
0049 22                RET     
             ; FUNCTION UART_RS485_ReadRxData (END)

             ; FUNCTION UART_RS485_ReadRxStatus (BEGIN)
                                           ; SOURCE LINE # 485
                                           ; SOURCE LINE # 486
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 32  

                                           ; SOURCE LINE # 489
0000 906467            MOV     DPTR,#06467H
0003 E0                MOVX    A,@DPTR
0004 547F              ANL     A,#07FH
0006 FF                MOV     R7,A
;---- Variable 'status' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 492
0007 900000      R     MOV     DPTR,#UART_RS485_rxBufferOverflow
000A E0                MOVX    A,@DPTR
000B 6006              JZ      ?C0016
                                           ; SOURCE LINE # 493
                                           ; SOURCE LINE # 494
000D EF                MOV     A,R7
000E 4480              ORL     A,#080H
0010 FF                MOV     R7,A
                                           ; SOURCE LINE # 495
0011 E4                CLR     A
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 496
0013         ?C0016:
                                           ; SOURCE LINE # 499
                                           ; SOURCE LINE # 500
0013         ?C0017:
0013 22                RET     
             ; FUNCTION UART_RS485_ReadRxStatus (END)

             ; FUNCTION UART_RS485_GetChar (BEGIN)
                                           ; SOURCE LINE # 532
                                           ; SOURCE LINE # 533
                                           ; SOURCE LINE # 534
;---- Variable 'rxData' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 542
0002 9044C8            MOV     DPTR,#044C8H
0005 7402              MOV     A,#02H
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 544
0008 900000      R     MOV     DPTR,#UART_RS485_rxBufferRead
000B E0                MOVX    A,@DPTR
000C FE                MOV     R6,A
;---- Variable 'locRxBufferRead' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 545
000D 900000      R     MOV     DPTR,#UART_RS485_rxBufferWrite
0010 E0                MOVX    A,@DPTR
0011 FD                MOV     R5,A
;---- Variable 'locRxBufferWrite' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 547
0012 900000      R     MOV     DPTR,#UART_RS485_rxBufferLoopDetect
0015 E0                MOVX    A,@DPTR
0016 7004              JNZ     ?C0019
0018 EE                MOV     A,R6
0019 6D                XRL     A,R5
001A 6024              JZ      ?C0018
001C         ?C0019:
                                           ; SOURCE LINE # 548
                                           ; SOURCE LINE # 549
001C 7400        R     MOV     A,#LOW UART_RS485_rxBuffer
001E 2E                ADD     A,R6
001F F582              MOV     DPL,A
0021 E4                CLR     A
0022 3400        R     ADDC    A,#HIGH UART_RS485_rxBuffer
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 33  

0024 F583              MOV     DPH,A
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
                                           ; SOURCE LINE # 550
0028 0E                INC     R6
                                           ; SOURCE LINE # 551
0029 EE                MOV     A,R6
002A C3                CLR     C
002B 9420              SUBB    A,#020H
002D 4002              JC      ?C0020
                                           ; SOURCE LINE # 552
                                           ; SOURCE LINE # 553
002F E4                CLR     A
0030 FE                MOV     R6,A
                                           ; SOURCE LINE # 554
0031         ?C0020:
                                           ; SOURCE LINE # 556
0031 900000      R     MOV     DPTR,#UART_RS485_rxBufferRead
0034 EE                MOV     A,R6
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 558
0036 900000      R     MOV     DPTR,#UART_RS485_rxBufferLoopDetect
0039 E0                MOVX    A,@DPTR
003A 6018              JZ      ?C0022
                                           ; SOURCE LINE # 559
                                           ; SOURCE LINE # 560
003C E4                CLR     A
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 575
                                           ; SOURCE LINE # 577
003E 8014              SJMP    ?C0022
0040         ?C0018:
                                           ; SOURCE LINE # 579
0040 906467            MOV     DPTR,#06467H
0043 E0                MOVX    A,@DPTR
0044 FE                MOV     R6,A
;---- Variable 'rxStatus' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 580
0045 30E50C            JNB     ACC.5,?C0022
                                           ; SOURCE LINE # 581
                                           ; SOURCE LINE # 582
0048 906547            MOV     DPTR,#06547H
004B E0                MOVX    A,@DPTR
004C FF                MOV     R7,A
                                           ; SOURCE LINE # 585
004D EE                MOV     A,R6
004E 541E              ANL     A,#01EH
0050 6002              JZ      ?C0022
                                           ; SOURCE LINE # 586
                                           ; SOURCE LINE # 587
0052 E4                CLR     A
0053 FF                MOV     R7,A
                                           ; SOURCE LINE # 588
                                           ; SOURCE LINE # 589
                                           ; SOURCE LINE # 590
0054         ?C0022:
                                           ; SOURCE LINE # 592
0054 9044C0            MOV     DPTR,#044C0H
0057 7402              MOV     A,#02H
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 611
                                           ; SOURCE LINE # 612
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 34  

005A         ?C0025:
005A 22                RET     
             ; FUNCTION UART_RS485_GetChar (END)

             ; FUNCTION UART_RS485_GetByte (BEGIN)
                                           ; SOURCE LINE # 634
                                           ; SOURCE LINE # 635
                                           ; SOURCE LINE # 640
0000 9044C8            MOV     DPTR,#044C8H
0003 7402              MOV     A,#02H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 641
0006 900000      R     MOV     DPTR,#UART_RS485_errorStatus
0009 E0                MOVX    A,@DPTR
;---- Variable 'locErrorStatus' assigned to Register 'R2/R3' ----
000A FB                MOV     R3,A
000B 7A00              MOV     R2,#00H
                                           ; SOURCE LINE # 642
000D E4                CLR     A
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 643
000F 9044C0            MOV     DPTR,#044C0H
0012 7402              MOV     A,#02H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 644
0015 120000      R     LCALL   UART_RS485_ReadRxData
0018 EF                MOV     A,R7
0019 FD                MOV     R5,A
001A EB                MOV     A,R3
001B FE                MOV     R6,A
001C ED                MOV     A,R5
001D FF                MOV     R7,A
                                           ; SOURCE LINE # 649
001E         ?C0026:
001E 22                RET     
             ; FUNCTION UART_RS485_GetByte (END)

             ; FUNCTION UART_RS485_GetRxBufferSize (BEGIN)
                                           ; SOURCE LINE # 683
;---- Variable 'size' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 685
                                           ; SOURCE LINE # 691
0000 9044C8            MOV     DPTR,#044C8H
0003 7402              MOV     A,#02H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 693
0006 900000      R     MOV     DPTR,#UART_RS485_rxBufferWrite
0009 E0                MOVX    A,@DPTR
000A FE                MOV     R6,A
000B 900000      R     MOV     DPTR,#UART_RS485_rxBufferRead
000E E0                MOVX    A,@DPTR
000F B5060E            CJNE    A,AR6,?C0027
                                           ; SOURCE LINE # 694
                                           ; SOURCE LINE # 695
0012 900000      R     MOV     DPTR,#UART_RS485_rxBufferLoopDetect
0015 E0                MOVX    A,@DPTR
0016 6004              JZ      ?C0028
                                           ; SOURCE LINE # 696
                                           ; SOURCE LINE # 697
0018 7F20              MOV     R7,#020H
                                           ; SOURCE LINE # 698
001A 802C              SJMP    ?C0030
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 35  

001C         ?C0028:
                                           ; SOURCE LINE # 700
                                           ; SOURCE LINE # 701
001C E4                CLR     A
001D FF                MOV     R7,A
                                           ; SOURCE LINE # 702
                                           ; SOURCE LINE # 703
001E 8028              SJMP    ?C0030
0020         ?C0027:
                                           ; SOURCE LINE # 704
0020 900000      R     MOV     DPTR,#UART_RS485_rxBufferWrite
0023 E0                MOVX    A,@DPTR
0024 FE                MOV     R6,A
0025 900000      R     MOV     DPTR,#UART_RS485_rxBufferRead
0028 E0                MOVX    A,@DPTR
0029 C3                CLR     C
002A 9E                SUBB    A,R6
002B 500B              JNC     ?C0031
                                           ; SOURCE LINE # 705
                                           ; SOURCE LINE # 706
002D E0                MOVX    A,@DPTR
002E FE                MOV     R6,A
002F 900000      R     MOV     DPTR,#UART_RS485_rxBufferWrite
0032 E0                MOVX    A,@DPTR
0033 C3                CLR     C
0034 9E                SUBB    A,R6
0035 FF                MOV     R7,A
                                           ; SOURCE LINE # 707
0036 8010              SJMP    ?C0030
0038         ?C0031:
                                           ; SOURCE LINE # 709
                                           ; SOURCE LINE # 710
0038 900000      R     MOV     DPTR,#UART_RS485_rxBufferRead
003B E0                MOVX    A,@DPTR
003C FE                MOV     R6,A
003D C3                CLR     C
003E 7420              MOV     A,#020H
0040 9E                SUBB    A,R6
0041 FE                MOV     R6,A
0042 900000      R     MOV     DPTR,#UART_RS485_rxBufferWrite
0045 E0                MOVX    A,@DPTR
0046 2E                ADD     A,R6
0047 FF                MOV     R7,A
                                           ; SOURCE LINE # 711
0048         ?C0030:
                                           ; SOURCE LINE # 713
0048 9044C0            MOV     DPTR,#044C0H
004B 7402              MOV     A,#02H
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 722
                                           ; SOURCE LINE # 723
004E         ?C0033:
004E 22                RET     
             ; FUNCTION UART_RS485_GetRxBufferSize (END)

             ; FUNCTION UART_RS485_ClearRxBuffer (BEGIN)
                                           ; SOURCE LINE # 757
                                           ; SOURCE LINE # 758
                                           ; SOURCE LINE # 762
0000 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'enableInterrupts' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 763
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 36  

0003 906597            MOV     DPTR,#06597H
0006 E0                MOVX    A,@DPTR
0007 4401              ORL     A,#01H
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 764
000A E0                MOVX    A,@DPTR
000B 54FE              ANL     A,#0FEH
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 765
000E 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 770
0011 9044C8            MOV     DPTR,#044C8H
0014 7402              MOV     A,#02H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 772
0017 E4                CLR     A
0018 900000      R     MOV     DPTR,#UART_RS485_rxBufferRead
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 773
001C 900000      R     MOV     DPTR,#UART_RS485_rxBufferWrite
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 774
0020 900000      R     MOV     DPTR,#UART_RS485_rxBufferLoopDetect
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 775
0024 900000      R     MOV     DPTR,#UART_RS485_rxBufferOverflow
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 777
0028 9044C0            MOV     DPTR,#044C0H
002B 7402              MOV     A,#02H
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 781
002E 22                RET     
             ; FUNCTION UART_RS485_ClearRxBuffer (END)

             ; FUNCTION _UART_RS485_SetRxAddressMode (BEGIN)
                                           ; SOURCE LINE # 813
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 815
                                           ; SOURCE LINE # 835
                                           ; SOURCE LINE # 836
                                           ; SOURCE LINE # 838
                                           ; SOURCE LINE # 840
0005         ?C0036:
0005 22                RET     
             ; FUNCTION _UART_RS485_SetRxAddressMode (END)

             ; FUNCTION _UART_RS485_SetRxAddress1 (BEGIN)
                                           ; SOURCE LINE # 857
;---- Variable 'address' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 858
                                           ; SOURCE LINE # 859
0000 906527            MOV     DPTR,#06527H
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 860
0005 22                RET     
             ; FUNCTION _UART_RS485_SetRxAddress1 (END)

             ; FUNCTION _UART_RS485_SetRxAddress2 (BEGIN)
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 37  

                                           ; SOURCE LINE # 877
;---- Variable 'address' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 878
                                           ; SOURCE LINE # 879
0000 906537            MOV     DPTR,#06537H
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 880
0005 22                RET     
             ; FUNCTION _UART_RS485_SetRxAddress2 (END)

             ; FUNCTION _UART_RS485_SetTxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 908
;---- Variable 'intSrc' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 909
                                           ; SOURCE LINE # 910
0000 906486            MOV     DPTR,#06486H
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 911
0005 22                RET     
             ; FUNCTION _UART_RS485_SetTxInterruptMode (END)

             ; FUNCTION _UART_RS485_WriteTxData (BEGIN)
                                           ; SOURCE LINE # 942
;---- Variable 'txDataByte' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 943
                                           ; SOURCE LINE # 945
0000 900000      R     MOV     DPTR,#UART_RS485_initVar
0003 E0                MOVX    A,@DPTR
0004 6005              JZ      ?C0041
                                           ; SOURCE LINE # 946
                                           ; SOURCE LINE # 976
0006 906446            MOV     DPTR,#06446H
0009 EF                MOV     A,R7
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 979
                                           ; SOURCE LINE # 980
000B         ?C0041:
000B 22                RET     
             ; FUNCTION _UART_RS485_WriteTxData (END)

             ; FUNCTION UART_RS485_ReadTxStatus (BEGIN)
                                           ; SOURCE LINE # 1003
                                           ; SOURCE LINE # 1004
                                           ; SOURCE LINE # 1005
0000 906466            MOV     DPTR,#06466H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 1006
0005         ?C0042:
0005 22                RET     
             ; FUNCTION UART_RS485_ReadTxStatus (END)

             ; FUNCTION _UART_RS485_PutChar (BEGIN)
                                           ; SOURCE LINE # 1041
;---- Variable 'txDataByte' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1042
0000         ?C0043:
                                           ; SOURCE LINE # 1107
0000 906466            MOV     DPTR,#06466H
0003 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 38  

0004 20E2F9            JB      ACC.2,?C0043
                                           ; SOURCE LINE # 1108
                                           ; SOURCE LINE # 1110
0007         ?C0044:
                                           ; SOURCE LINE # 1113
0007 906446            MOV     DPTR,#06446H
000A EF                MOV     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1116
000C 22                RET     
             ; FUNCTION _UART_RS485_PutChar (END)

             ; FUNCTION _UART_RS485_PutString (BEGIN)
                                           ; SOURCE LINE # 1145
0000 900000      R     MOV     DPTR,#string
0003 EB                MOV     A,R3
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EA                MOV     A,R2
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 E9                MOV     A,R1
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1146
                                           ; SOURCE LINE # 1147
;---- Variable 'bufIndex' assigned to Register 'R4/R5' ----
000B E4                CLR     A
000C FD                MOV     R5,A
000D FC                MOV     R4,A
                                           ; SOURCE LINE # 1150
000E 900000      R     MOV     DPTR,#UART_RS485_initVar
0011 E0                MOVX    A,@DPTR
0012 601F              JZ      ?C0049
                                           ; SOURCE LINE # 1151
0014         ?C0047:
                                           ; SOURCE LINE # 1153
0014 900000      R     MOV     DPTR,#string
0017 E0                MOVX    A,@DPTR
0018 FB                MOV     R3,A
0019 A3                INC     DPTR
001A E0                MOVX    A,@DPTR
001B FA                MOV     R2,A
001C A3                INC     DPTR
001D E0                MOVX    A,@DPTR
001E 2D                ADD     A,R5
001F F9                MOV     R1,A
0020 EA                MOV     A,R2
0021 3C                ADDC    A,R4
0022 FA                MOV     R2,A
0023 120000      E     LCALL   ?C?CLDPTR
0026 FF                MOV     R7,A
0027 600A              JZ      ?C0049
                                           ; SOURCE LINE # 1154
                                           ; SOURCE LINE # 1155
0029 120000      R     LCALL   _UART_RS485_PutChar
                                           ; SOURCE LINE # 1156
002C 0D                INC     R5
002D ED                MOV     A,R5
002E 7001              JNZ     ?C0079
0030 0C                INC     R4
0031         ?C0079:
                                           ; SOURCE LINE # 1157
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 39  

0031 80E1              SJMP    ?C0047
                                           ; SOURCE LINE # 1158
                                           ; SOURCE LINE # 1159
0033         ?C0049:
0033 22                RET     
             ; FUNCTION _UART_RS485_PutString (END)

             ; FUNCTION _UART_RS485_PutArray (BEGIN)
                                           ; SOURCE LINE # 1191
0000 900000      R     MOV     DPTR,#string
0003 EB                MOV     A,R3
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EA                MOV     A,R2
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 E9                MOV     A,R1
000A F0                MOVX    @DPTR,A
;---- Variable 'byteCount' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 1193
                                           ; SOURCE LINE # 1194
;---- Variable 'bufIndex' assigned to Register 'R6' ----
000B E4                CLR     A
000C FE                MOV     R6,A
                                           ; SOURCE LINE # 1197
000D 900000      R     MOV     DPTR,#UART_RS485_initVar
0010 E0                MOVX    A,@DPTR
0011 601E              JZ      ?C0053
                                           ; SOURCE LINE # 1198
0013         ?C0051:
                                           ; SOURCE LINE # 1199
0013 EE                MOV     A,R6
0014 C3                CLR     C
0015 9D                SUBB    A,R5
0016 5019              JNC     ?C0053
                                           ; SOURCE LINE # 1200
                                           ; SOURCE LINE # 1201
0018 900000      R     MOV     DPTR,#string
001B E0                MOVX    A,@DPTR
001C FB                MOV     R3,A
001D A3                INC     DPTR
001E E0                MOVX    A,@DPTR
001F FA                MOV     R2,A
0020 A3                INC     DPTR
0021 E0                MOVX    A,@DPTR
0022 2E                ADD     A,R6
0023 F9                MOV     R1,A
0024 E4                CLR     A
0025 3A                ADDC    A,R2
0026 FA                MOV     R2,A
0027 120000      E     LCALL   ?C?CLDPTR
002A FF                MOV     R7,A
002B 120000      R     LCALL   _UART_RS485_PutChar
                                           ; SOURCE LINE # 1202
002E 0E                INC     R6
                                           ; SOURCE LINE # 1203
002F 80E2              SJMP    ?C0051
                                           ; SOURCE LINE # 1204
                                           ; SOURCE LINE # 1205
0031         ?C0053:
0031 22                RET     
             ; FUNCTION _UART_RS485_PutArray (END)
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 40  


             ; FUNCTION _UART_RS485_PutCRLF (BEGIN)
                                           ; SOURCE LINE # 1230
;---- Variable 'txDataByte' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1231
                                           ; SOURCE LINE # 1233
0000 900000      R     MOV     DPTR,#UART_RS485_initVar
0003 E0                MOVX    A,@DPTR
0004 600D              JZ      ?C0055
                                           ; SOURCE LINE # 1234
                                           ; SOURCE LINE # 1235
0006 120000      R     LCALL   _UART_RS485_PutChar
                                           ; SOURCE LINE # 1236
0009 7F0D              MOV     R7,#0DH
000B 120000      R     LCALL   _UART_RS485_PutChar
                                           ; SOURCE LINE # 1237
000E 7F0A              MOV     R7,#0AH
0010 120000      R     LCALL   _UART_RS485_PutChar
                                           ; SOURCE LINE # 1238
                                           ; SOURCE LINE # 1239
0013         ?C0055:
0013 22                RET     
             ; FUNCTION _UART_RS485_PutCRLF (END)

             ; FUNCTION UART_RS485_GetTxBufferSize (BEGIN)
                                           ; SOURCE LINE # 1273
                                           ; SOURCE LINE # 1275
                                           ; SOURCE LINE # 1301
0000 906466            MOV     DPTR,#06466H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
;---- Variable 'size' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1304
0005 30E204            JNB     ACC.2,?C0056
                                           ; SOURCE LINE # 1305
                                           ; SOURCE LINE # 1306
0008 7F04              MOV     R7,#04H
                                           ; SOURCE LINE # 1307
000A 800A              SJMP    ?C0057
000C         ?C0056:
                                           ; SOURCE LINE # 1308
000C EF                MOV     A,R7
000D 30E104            JNB     ACC.1,?C0058
                                           ; SOURCE LINE # 1309
                                           ; SOURCE LINE # 1310
0010 E4                CLR     A
0011 FF                MOV     R7,A
                                           ; SOURCE LINE # 1311
0012 8002              SJMP    ?C0057
0014         ?C0058:
                                           ; SOURCE LINE # 1313
                                           ; SOURCE LINE # 1315
0014 7F01              MOV     R7,#01H
                                           ; SOURCE LINE # 1316
0016         ?C0057:
                                           ; SOURCE LINE # 1320
                                           ; SOURCE LINE # 1321
0016         ?C0060:
0016 22                RET     
             ; FUNCTION UART_RS485_GetTxBufferSize (END)

             ; FUNCTION UART_RS485_ClearTxBuffer (BEGIN)
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 41  

                                           ; SOURCE LINE # 1354
                                           ; SOURCE LINE # 1355
                                           ; SOURCE LINE # 1358
0000 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'enableInterrupts' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1360
0003 906496            MOV     DPTR,#06496H
0006 E0                MOVX    A,@DPTR
0007 4401              ORL     A,#01H
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1361
000A E0                MOVX    A,@DPTR
000B 54FE              ANL     A,#0FEH
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1362
000E 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1376
0011 22                RET     
             ; FUNCTION UART_RS485_ClearTxBuffer (END)

             ; FUNCTION _UART_RS485_SendBreak (BEGIN)
                                           ; SOURCE LINE # 1440
;---- Variable 'retMode' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1441
                                           ; SOURCE LINE # 1444
0000 900000      R     MOV     DPTR,#UART_RS485_initVar
0003 E0                MOVX    A,@DPTR
0004 6052              JZ      ?C0075
                                           ; SOURCE LINE # 1445
                                           ; SOURCE LINE # 1490
0006 EF                MOV     A,R7
0007 6004              JZ      ?C0064
0009 6403              XRL     A,#03H
000B 701F              JNZ     ?C0063
000D         ?C0064:
                                           ; SOURCE LINE # 1492
                                           ; SOURCE LINE # 1501
000D 906432            MOV     DPTR,#06432H
0010 E0                MOVX    A,@DPTR
0011 900000      R     MOV     DPTR,#txPeriod
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1502
0015 906432            MOV     DPTR,#06432H
0018 745F              MOV     A,#05FH
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1509
001B 906446            MOV     DPTR,#06446H
001E E4                CLR     A
001F F0                MOVX    @DPTR,A
0020         ?C0067:
                                           ; SOURCE LINE # 1512
                                           ; SOURCE LINE # 1513
0020 906466            MOV     DPTR,#06466H
0023 E0                MOVX    A,@DPTR
0024 900000      R     MOV     DPTR,#tmpStat
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1514
                                           ; SOURCE LINE # 1515
0028 E0                MOVX    A,@DPTR
0029 20E1F4            JB      ACC.1,?C0067
                                           ; SOURCE LINE # 1516
002C         ?C0063:
C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 42  

                                           ; SOURCE LINE # 1518
002C EF                MOV     A,R7
002D 6401              XRL     A,#01H
002F 6004              JZ      ?C0072
0031 EF                MOV     A,R7
0032 B4030D            CJNE    A,#03H,?C0068
                                           ; SOURCE LINE # 1520
0035         ?C0072:
                                           ; SOURCE LINE # 1522
                                           ; SOURCE LINE # 1523
0035 906466            MOV     DPTR,#06466H
0038 E0                MOVX    A,@DPTR
0039 900000      R     MOV     DPTR,#tmpStat
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1524
                                           ; SOURCE LINE # 1525
003D E0                MOVX    A,@DPTR
003E F4                CPL     A
003F 20E0F3            JB      ACC.0,?C0072
                                           ; SOURCE LINE # 1526
0042         ?C0068:
                                           ; SOURCE LINE # 1528
0042 EF                MOV     A,R7
0043 6401              XRL     A,#01H
0045 6009              JZ      ?C0074
0047 EF                MOV     A,R7
0048 6402              XRL     A,#02H
004A 6004              JZ      ?C0074
004C EF                MOV     A,R7
004D B40308            CJNE    A,#03H,?C0075
0050         ?C0074:
                                           ; SOURCE LINE # 1531
                                           ; SOURCE LINE # 1534
0050 900000      R     MOV     DPTR,#txPeriod
0053 E0                MOVX    A,@DPTR
0054 906432            MOV     DPTR,#06432H
0057 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1544
                                           ; SOURCE LINE # 1546
                                           ; SOURCE LINE # 1547
0058         ?C0075:
0058 22                RET     
             ; FUNCTION _UART_RS485_SendBreak (END)

             ; FUNCTION _UART_RS485_SetTxAddressMode (BEGIN)
                                           ; SOURCE LINE # 1572
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1573
                                           ; SOURCE LINE # 1575
                                           ; SOURCE LINE # 1576
                                           ; SOURCE LINE # 1581
0005         ?C0076:
                                           ; SOURCE LINE # 1583
                                           ; SOURCE LINE # 1588
                                           ; SOURCE LINE # 1589
0005         ?C0078:
0005 22                RET     
             ; FUNCTION _UART_RS485_SetTxAddressMode (END)


C51 COMPILER V9.51   UART_RS485                                                            02/07/2017 16:12:10 PAGE 43  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    808    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     39      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
